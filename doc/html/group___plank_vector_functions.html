<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pl-nk: Plank vector functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Plank vector functions</div>  </div>
<div class="ingroups"><a class="el" href="group___plank_functions.html">Plank functions</a></div></div>
<div class="contents">

<p>Vector processing functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf264cdbe70928e87484c7ef7c7e770da">pl_VectorFillF_N1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> value, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#gaf264cdbe70928e87484c7ef7c7e770da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56913dd2881acd870e0bf0b81761f29a">pl_VectorClearF_N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#ga56913dd2881acd870e0bf0b81761f29a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6083cf8cd3b19b6617c85b81dac22355">pl_VectorRampF_N11</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#ga6083cf8cd3b19b6617c85b81dac22355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5af8b83ed87be0faee019340b9cc07a3">pl_VectorLineF_N11</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga5af8b83ed87be0faee019340b9cc07a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6afd6f38943e06da5514a63e90c0faf9">pl_VectorMoveF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item in a vector.  <a href="#ga6afd6f38943e06da5514a63e90c0faf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3e8bc51e352f9e56102e8a6f8e591369">pl_VectorNegF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item in a vector.  <a href="#ga3e8bc51e352f9e56102e8a6f8e591369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0da76047e2f5935ce69ec1b4084959b7">pl_VectorAbsF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item in a vector.  <a href="#ga0da76047e2f5935ce69ec1b4084959b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167">pl_VectorLog2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item in a vector.  <a href="#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf552c917a97a8370eb14d70fa7fdbcd4">pl_VectorReciprocalF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item in a vector.  <a href="#gaf552c917a97a8370eb14d70fa7fdbcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8317e0ece295c3fe4c6ddcd0c9291b73">pl_VectorSinF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item in a vector.  <a href="#ga8317e0ece295c3fe4c6ddcd0c9291b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dc9e1a1005c50962f50b218bdd359f7">pl_VectorCosF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item in a vector.  <a href="#ga2dc9e1a1005c50962f50b218bdd359f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ff3f0a747f340ef59eb12ff9f5fa9ce">pl_VectorTanF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item in a vector.  <a href="#ga0ff3f0a747f340ef59eb12ff9f5fa9ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga40b4fd224d5c1df552bd36fd79e14d46">pl_VectorAsinF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item in a vector.  <a href="#ga40b4fd224d5c1df552bd36fd79e14d46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b0876ed78d4675a40aec91015020543">pl_VectorAcosF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item in a vector.  <a href="#ga4b0876ed78d4675a40aec91015020543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c392fc9382aa520c8d73f30ce097361">pl_VectorAtanF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item in a vector.  <a href="#ga1c392fc9382aa520c8d73f30ce097361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1d025408ed6a1435023aa7837cbbce26">pl_VectorSinhF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item in a vector.  <a href="#ga1d025408ed6a1435023aa7837cbbce26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae7fca130c7b57d8f99ba52546a3d401f">pl_VectorCoshF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item in a vector.  <a href="#gae7fca130c7b57d8f99ba52546a3d401f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac8184fcb4e00b71d0e152a6cd441e611">pl_VectorTanhF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item in a vector.  <a href="#gac8184fcb4e00b71d0e152a6cd441e611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac5eb6a022dcc12e47bb871209d94fa5b">pl_VectorSqrtF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item in a vector.  <a href="#gac5eb6a022dcc12e47bb871209d94fa5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6154ea39d75e68b9e9d5330cb3625eec">pl_VectorLogF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item in a vector.  <a href="#ga6154ea39d75e68b9e9d5330cb3625eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5680198a0c9c769ad052a505769d8e65">pl_VectorLog10F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item in a vector.  <a href="#ga5680198a0c9c769ad052a505769d8e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2832cd0f9496ce0c593be00454cc1d56">pl_VectorExpF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item in a vector.  <a href="#ga2832cd0f9496ce0c593be00454cc1d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga138489a0a09ca5131c997c9bf2785020">pl_VectorSquaredF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item in a vector.  <a href="#ga138489a0a09ca5131c997c9bf2785020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga14c2dd307d97ebea1a2b0a79a4f18f3f">pl_VectorCubedF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item in a vector.  <a href="#ga14c2dd307d97ebea1a2b0a79a4f18f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga624ee54e6e8bab7bd8f81997c07b7242">pl_VectorCeilF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item in a vector.  <a href="#ga624ee54e6e8bab7bd8f81997c07b7242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53d443eaba00cc8255d4d1dd7dc3de79">pl_VectorFloorF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item in a vector.  <a href="#ga53d443eaba00cc8255d4d1dd7dc3de79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga772400768495fd4fd693256ad3c48f33">pl_VectorFracF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item in a vector.  <a href="#ga772400768495fd4fd693256ad3c48f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga017d16bd185ae3cf9069e06cc9c2cf88">pl_VectorSignF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item in a vector.  <a href="#ga017d16bd185ae3cf9069e06cc9c2cf88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga434579ecb8b69a86b3c1b5e19640d3e9">pl_VectorM2FF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item in a vector.  <a href="#ga434579ecb8b69a86b3c1b5e19640d3e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346ccfb5366b8795fb98c20817553baf">pl_VectorF2MF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item in a vector.  <a href="#ga346ccfb5366b8795fb98c20817553baf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6d6a453af826e1347bbe6801068431e4">pl_VectorA2dBF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item in a vector.  <a href="#ga6d6a453af826e1347bbe6801068431e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf55e4f2965d3427a503f26e3e3d22a40">pl_VectordB2AF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item in a vector.  <a href="#gaf55e4f2965d3427a503f26e3e3d22a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac4ffbe59182ba1514ccd8969ed780394">pl_VectorD2RF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item in a vector.  <a href="#gac4ffbe59182ba1514ccd8969ed780394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdc0d266ab2c818ebf03503c1f1d0044">pl_VectorR2DF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item in a vector.  <a href="#gafdc0d266ab2c818ebf03503c1f1d0044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab1abd9fad50bb7512458ef32c19399f3">pl_VectorDistortF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item in a vector.  <a href="#gab1abd9fad50bb7512458ef32c19399f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6bd51dca6361c74850caf92244eefbf4">pl_VectorZapF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item in a vector.  <a href="#ga6bd51dca6361c74850caf92244eefbf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3874b7ec8eb9d6daa7e57928ac093a9c">pl_VectorAddF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item in two input vectors.  <a href="#ga3874b7ec8eb9d6daa7e57928ac093a9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53fdeba08d131bafeee9e2217b79f77a">pl_VectorAddF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="#ga53fdeba08d131bafeee9e2217b79f77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c458ac80a73ae97d9836e7cdff6653">pl_VectorAddF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="#ga96c458ac80a73ae97d9836e7cdff6653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9e7dc8aa04be89440e1440b3125cdffc">pl_VectorSubF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item in two input vectors.  <a href="#ga9e7dc8aa04be89440e1440b3125cdffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8935b522deb4e2baf1885c78ef3c5a2">pl_VectorSubF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="#gad8935b522deb4e2baf1885c78ef3c5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad545716dacb61f997567075c3a4a6720">pl_VectorSubF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="#gad545716dacb61f997567075c3a4a6720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09b89f66bb8148bc4d7f3ade8f12ab6b">pl_VectorMulF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item in two input vectors.  <a href="#ga09b89f66bb8148bc4d7f3ade8f12ab6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4d02adf1b7e3387b882aee06bf794bab">pl_VectorMulF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="#ga4d02adf1b7e3387b882aee06bf794bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga044d16cfcf2eda7978a038ca4a156144">pl_VectorMulF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="#ga044d16cfcf2eda7978a038ca4a156144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae6db0d03c2bb9e5a663ac3e1d4d3d76a">pl_VectorDivF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item in two input vectors.  <a href="#gae6db0d03c2bb9e5a663ac3e1d4d3d76a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga647b8c4642bc5c02b4b4ad7fca5434eb">pl_VectorDivF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="#ga647b8c4642bc5c02b4b4ad7fca5434eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fb4b91f3c0068e6b0805195a7899c34">pl_VectorDivF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="#ga7fb4b91f3c0068e6b0805195a7899c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa31eb103c9cb1b7af8ec1d68940fc816">pl_VectorMinF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item in two input vectors.  <a href="#gaa31eb103c9cb1b7af8ec1d68940fc816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa3a514ff8c829f3f0c34cc3cb8532fa9">pl_VectorMinF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="#gaa3a514ff8c829f3f0c34cc3cb8532fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8dd296051688e3035e6d0f7dff95c2ab">pl_VectorMinF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="#ga8dd296051688e3035e6d0f7dff95c2ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8ee95f778cdfcd034e902fb81f7c885">pl_VectorMaxF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item in two input vectors.  <a href="#gad8ee95f778cdfcd034e902fb81f7c885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2e548c19fcaaa84dc28e05af2b4cd88a">pl_VectorMaxF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="#ga2e548c19fcaaa84dc28e05af2b4cd88a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaabafa18c8dd0ec2c12e11b6f42cc2493">pl_VectorMaxF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="#gaabafa18c8dd0ec2c12e11b6f42cc2493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadf3b8ea80497eeec187a20e7e2848ed7">pl_VectorPowF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item in two input vectors.  <a href="#gadf3b8ea80497eeec187a20e7e2848ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga483ff2d8bea2cdeec487db5efffa3d3a">pl_VectorPowF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="#ga483ff2d8bea2cdeec487db5efffa3d3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c1025337d92429c8734e175143f1f7">pl_VectorPowF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="#ga96c1025337d92429c8734e175143f1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5cbc606bff150d3be2e698aac7dc5ce4">pl_VectorIsEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item in two input vectors.  <a href="#ga5cbc606bff150d3be2e698aac7dc5ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacf88f51bb6a26c2d0a68e994d863711c">pl_VectorIsEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="#gacf88f51bb6a26c2d0a68e994d863711c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedb79426fa90a29103fce022679f32f4">pl_VectorIsEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="#gaedb79426fa90a29103fce022679f32f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9a46a8c1db7476211bdd6b44fb19d49">pl_VectorIsNotEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item in two input vectors.  <a href="#gae9a46a8c1db7476211bdd6b44fb19d49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga774c6a0e634df1f397516a6a805a4d6d">pl_VectorIsNotEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="#ga774c6a0e634df1f397516a6a805a4d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56a9fe4ef33f7d81a29e7aab0a1592c0">pl_VectorIsNotEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="#ga56a9fe4ef33f7d81a29e7aab0a1592c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6030e695b7b354d7c668506b6dd8777e">pl_VectorIsGreaterThanF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item in two input vectors.  <a href="#ga6030e695b7b354d7c668506b6dd8777e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3298d662a1a1002f1a911cf89576f12e">pl_VectorIsGreaterThanF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="#ga3298d662a1a1002f1a911cf89576f12e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7ff4eb184fe6458d583af93f5f5d72a3">pl_VectorIsGreaterThanF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="#ga7ff4eb184fe6458d583af93f5f5d72a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga34dbb414e4e85a5dc21cab04efb36e17">pl_VectorIsGreaterThanOrEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item in two input vectors.  <a href="#ga34dbb414e4e85a5dc21cab04efb36e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5c70aa006400c76931250bdcccf52e37">pl_VectorIsGreaterThanOrEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga5c70aa006400c76931250bdcccf52e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9563d0b877e5656f9e68dbe1f172b1c2">pl_VectorIsGreaterThanOrEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga9563d0b877e5656f9e68dbe1f172b1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafc1473081b72235572bbcb4180f85532">pl_VectorIsLessThanF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item in two input vectors.  <a href="#gafc1473081b72235572bbcb4180f85532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gada27b912481be2974f2df10287c24cca">pl_VectorIsLessThanF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="#gada27b912481be2974f2df10287c24cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98ef2362c8ee3b97169746404863b0bb">pl_VectorIsLessThanF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="#ga98ef2362c8ee3b97169746404863b0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae336bfe2cf955934a4cee32d66b4817e">pl_VectorIsLessThanOrEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item in two input vectors.  <a href="#gae336bfe2cf955934a4cee32d66b4817e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f64176207c3d68ae22cddb34d496266">pl_VectorIsLessThanOrEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga5f64176207c3d68ae22cddb34d496266"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9b4e616e12b4510ed11658d46985b6d">pl_VectorIsLessThanOrEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#gaa9b4e616e12b4510ed11658d46985b6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabff48d9f05d09c6fc3024f2095a91630">pl_VectorHypotF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item in two input vectors.  <a href="#gabff48d9f05d09c6fc3024f2095a91630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga939e06569593c806d533ea61e4b98327">pl_VectorHypotF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="#ga939e06569593c806d533ea61e4b98327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf0893c32e31d72a7e91badc4abf62b3b">pl_VectorHypotF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="#gaf0893c32e31d72a7e91badc4abf62b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga44812f3688888b573be8c9db069b936a">pl_VectorAtan2F_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item in two input vectors.  <a href="#ga44812f3688888b573be8c9db069b936a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaece9a054e73c28bd180580b0cd016018">pl_VectorAtan2F_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="#gaece9a054e73c28bd180580b0cd016018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1570febbc25f8b9a3ef7ac8cc7af07ae">pl_VectorAtan2F_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="#ga1570febbc25f8b9a3ef7ac8cc7af07ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga52cc262cb6455a1ccb4bb7d6a3b78467">pl_VectorSumSqrF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item in two input vectors.  <a href="#ga52cc262cb6455a1ccb4bb7d6a3b78467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafaba968683dddc1cb6ee402811875181">pl_VectorSumSqrF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="#gafaba968683dddc1cb6ee402811875181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5484d71a34bd278e75b8cecf45e7263">pl_VectorSumSqrF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="#gad5484d71a34bd278e75b8cecf45e7263"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaecd22cb5b339a05a83a47ce9a5eb303d">pl_VectorDifSqrF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item in two input vectors.  <a href="#gaecd22cb5b339a05a83a47ce9a5eb303d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab11b4161a9b842caf8431aa6e578f81">pl_VectorDifSqrF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="#gaab11b4161a9b842caf8431aa6e578f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8c6f0bc2d31739420492413ade319f84">pl_VectorDifSqrF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="#ga8c6f0bc2d31739420492413ade319f84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa44f0e93a59157dc2ed7a1a320606de3">pl_VectorSqrSumF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item in two input vectors.  <a href="#gaa44f0e93a59157dc2ed7a1a320606de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0cc252e1e632dd35bbb13d318f6bf51b">pl_VectorSqrSumF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="#ga0cc252e1e632dd35bbb13d318f6bf51b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3568d95bc0f3df06126f00db48d52385">pl_VectorSqrSumF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="#ga3568d95bc0f3df06126f00db48d52385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae247f0ca7d07614d80fb70fd4f3b20ab">pl_VectorSqrDifF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item in two input vectors.  <a href="#gae247f0ca7d07614d80fb70fd4f3b20ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2229b5869509b5f0947e8927262f23b0">pl_VectorSqrDifF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="#ga2229b5869509b5f0947e8927262f23b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga381554ead66ca6856122b66b1e9bf063">pl_VectorSqrDifF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="#ga381554ead66ca6856122b66b1e9bf063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9d78883696faed1ffc7b1ed6cbb4bc8">pl_VectorAbsDifF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item in two input vectors.  <a href="#gaa9d78883696faed1ffc7b1ed6cbb4bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c8da37fdfd80aebd9d1743a0da9b497">pl_VectorAbsDifF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="#ga1c8da37fdfd80aebd9d1743a0da9b497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3a66577c30fc72bd6eff2271f9c10b16">pl_VectorAbsDifF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="#ga3a66577c30fc72bd6eff2271f9c10b16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3161963fd5d2e9453250a93f01226f5d">pl_VectorThreshF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item in two input vectors.  <a href="#ga3161963fd5d2e9453250a93f01226f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae27592fcf9a6e2511f691e2b840340a9">pl_VectorThreshF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="#gae27592fcf9a6e2511f691e2b840340a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9bc9357afdaecf35a48a2819a1673ec5">pl_VectorThreshF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="#ga9bc9357afdaecf35a48a2819a1673ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9877065544b3718d8d187d5f50cdf24">pl_VectorMulAddF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *io, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *mul, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *add, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gad9877065544b3718d8d187d5f50cdf24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaddee28f3d1f630066c181c8a6ac97aea">pl_VectorLookupF_NnN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *table, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> n, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *index, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gaddee28f3d1f630066c181c8a6ac97aea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3d51b6cf9010ce1fa63b9762249261a0">pl_VectorFillD_N1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> value, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#ga3d51b6cf9010ce1fa63b9762249261a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa347eccfa116a68b56f8f5eee79e5707">pl_VectorClearD_N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#gaa347eccfa116a68b56f8f5eee79e5707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac60fec7cc8a88e48270833135205ec12">pl_VectorRampD_N11</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#gac60fec7cc8a88e48270833135205ec12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga81e869fd2297a6c57b5e3a312fc33b74">pl_VectorLineD_N11</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga81e869fd2297a6c57b5e3a312fc33b74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga92916e1daf6e82d9404d525e42389b45">pl_VectorMoveD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item in a vector.  <a href="#ga92916e1daf6e82d9404d525e42389b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad49e011e4ca3f76de0b8ec5c1d6d81e6">pl_VectorNegD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item in a vector.  <a href="#gad49e011e4ca3f76de0b8ec5c1d6d81e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaec21dab0c087e0b170745b2e3efd207b">pl_VectorAbsD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item in a vector.  <a href="#gaec21dab0c087e0b170745b2e3efd207b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2f77253685ccd08349ad129a0bc09a23">pl_VectorLog2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item in a vector.  <a href="#ga2f77253685ccd08349ad129a0bc09a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga88f1c17c13d19ff647a659e21164ec91">pl_VectorReciprocalD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item in a vector.  <a href="#ga88f1c17c13d19ff647a659e21164ec91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab78a731a99877c501f2531b263ed0ff7">pl_VectorSinD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item in a vector.  <a href="#gab78a731a99877c501f2531b263ed0ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5eb1030590f71b5165e3f72b6bd656e5">pl_VectorCosD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item in a vector.  <a href="#ga5eb1030590f71b5165e3f72b6bd656e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga135af6226d8b96e81abaaba6f9cd0b06">pl_VectorTanD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item in a vector.  <a href="#ga135af6226d8b96e81abaaba6f9cd0b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedae3e19d90c4a4cb5212edadcd76f76">pl_VectorAsinD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item in a vector.  <a href="#gaedae3e19d90c4a4cb5212edadcd76f76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacac99df0db7dad5461861849601a0dc8">pl_VectorAcosD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item in a vector.  <a href="#gacac99df0db7dad5461861849601a0dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dcc5850da8f410f63fb5c929a0f7e76">pl_VectorAtanD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item in a vector.  <a href="#ga2dcc5850da8f410f63fb5c929a0f7e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaebafcf0bf05dade5b95bf6066808f623">pl_VectorSinhD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item in a vector.  <a href="#gaebafcf0bf05dade5b95bf6066808f623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5853e6b3aff90d56b2d433da806d858f">pl_VectorCoshD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item in a vector.  <a href="#ga5853e6b3aff90d56b2d433da806d858f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga250f2e61d743622a1609f85839f9c4bb">pl_VectorTanhD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item in a vector.  <a href="#ga250f2e61d743622a1609f85839f9c4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga540c096f6e4382440007c878047f4f5d">pl_VectorSqrtD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item in a vector.  <a href="#ga540c096f6e4382440007c878047f4f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b06f007387aeffb3ebd2214f5090fb8">pl_VectorLogD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item in a vector.  <a href="#ga3b06f007387aeffb3ebd2214f5090fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a5902d66076b7527b8ca6a674fef22e">pl_VectorLog10D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item in a vector.  <a href="#ga1a5902d66076b7527b8ca6a674fef22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346a791b777f3fb3ce4a8b5ab8dd0133">pl_VectorExpD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item in a vector.  <a href="#ga346a791b777f3fb3ce4a8b5ab8dd0133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac6d6857d70c11dac6815925aa5fbe258">pl_VectorSquaredD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item in a vector.  <a href="#gac6d6857d70c11dac6815925aa5fbe258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac92318b9550618c0eb61f5c6db28b6f0">pl_VectorCubedD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item in a vector.  <a href="#gac92318b9550618c0eb61f5c6db28b6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga50da194cf31d82e931c3d2b3509934b3">pl_VectorCeilD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item in a vector.  <a href="#ga50da194cf31d82e931c3d2b3509934b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0fabcca5e7164c365cecccf20a2ad394">pl_VectorFloorD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item in a vector.  <a href="#ga0fabcca5e7164c365cecccf20a2ad394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaeb35318b9e872a8d4d86d9c795d368b2">pl_VectorFracD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item in a vector.  <a href="#gaeb35318b9e872a8d4d86d9c795d368b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga35254ed489bf9f5825bac6d353d80eac">pl_VectorSignD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item in a vector.  <a href="#ga35254ed489bf9f5825bac6d353d80eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga08b1418b75b12da60a96a514008a3e2d">pl_VectorM2FD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item in a vector.  <a href="#ga08b1418b75b12da60a96a514008a3e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga781a129439e1bb1dd0295a99085f3a84">pl_VectorF2MD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item in a vector.  <a href="#ga781a129439e1bb1dd0295a99085f3a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae0e337b7b89735618a1855ea91660bd9">pl_VectorA2dBD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item in a vector.  <a href="#gae0e337b7b89735618a1855ea91660bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7bb9f2cc273aaefa164d83f970e30380">pl_VectordB2AD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item in a vector.  <a href="#ga7bb9f2cc273aaefa164d83f970e30380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaba41fd68b23cb9bdd1cefb6c4b71c7a4">pl_VectorD2RD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item in a vector.  <a href="#gaba41fd68b23cb9bdd1cefb6c4b71c7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa22058ab0b84dd204cd0818f7eee4e71">pl_VectorR2DD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item in a vector.  <a href="#gaa22058ab0b84dd204cd0818f7eee4e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1c81935d93b40e48a4986fc20c9e34b">pl_VectorDistortD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item in a vector.  <a href="#gae1c81935d93b40e48a4986fc20c9e34b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabfeb5cce886741713f4db15d8e45530a">pl_VectorZapD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item in a vector.  <a href="#gabfeb5cce886741713f4db15d8e45530a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga12ef092e0c8e669d7762e69d0559e3a2">pl_VectorAddD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item in two input vectors.  <a href="#ga12ef092e0c8e669d7762e69d0559e3a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae41675932ccb373a167cd2c83e3df768">pl_VectorAddD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="#gae41675932ccb373a167cd2c83e3df768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5a1316615dc2031b02b71424f44d657f">pl_VectorAddD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="#ga5a1316615dc2031b02b71424f44d657f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa1ad270a88e18f6e9c8a51c450c3e41f">pl_VectorSubD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item in two input vectors.  <a href="#gaa1ad270a88e18f6e9c8a51c450c3e41f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a28dc464696905e52db911b3f97566e">pl_VectorSubD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="#ga1a28dc464696905e52db911b3f97566e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab8ea462ef620ebc5dd512f0df2224508">pl_VectorSubD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="#gab8ea462ef620ebc5dd512f0df2224508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga49295bf725772df3865b0fe99be4552e">pl_VectorMulD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item in two input vectors.  <a href="#ga49295bf725772df3865b0fe99be4552e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1bc824231e441539c1ee7df8b50e0391">pl_VectorMulD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="#ga1bc824231e441539c1ee7df8b50e0391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf5e80360d5aae32ecddfba037c215af8">pl_VectorMulD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="#gaf5e80360d5aae32ecddfba037c215af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1fa89f9180cd6811ec7a0eb94605b996">pl_VectorDivD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item in two input vectors.  <a href="#ga1fa89f9180cd6811ec7a0eb94605b996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa19c40021b63a0d14db1eddd9d0a037e">pl_VectorDivD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="#gaa19c40021b63a0d14db1eddd9d0a037e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a">pl_VectorDivD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3267ac92b409d85e0f1195214d19bcf1">pl_VectorMinD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item in two input vectors.  <a href="#ga3267ac92b409d85e0f1195214d19bcf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga750a9c78d6f4857c73ab1ee9cdbd65ad">pl_VectorMinD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="#ga750a9c78d6f4857c73ab1ee9cdbd65ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09f665f6b1bddb3bd7669410e10b3c02">pl_VectorMinD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="#ga09f665f6b1bddb3bd7669410e10b3c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab73fa94aad3f3a9ea9b4281fa2a45637">pl_VectorMaxD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item in two input vectors.  <a href="#gab73fa94aad3f3a9ea9b4281fa2a45637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdcc887ab924c442c0496cd98cb8bf08">pl_VectorMaxD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="#gafdcc887ab924c442c0496cd98cb8bf08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad687be0c0ca10457b0d9ea29d3e737c2">pl_VectorMaxD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="#gad687be0c0ca10457b0d9ea29d3e737c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3373906398e94de141273acb0d6390c9">pl_VectorPowD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item in two input vectors.  <a href="#ga3373906398e94de141273acb0d6390c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b253f22b62b7117f6af0c31abfd6c07">pl_VectorPowD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="#ga4b253f22b62b7117f6af0c31abfd6c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9296c3251eb6571e43019400f83c765c">pl_VectorPowD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="#ga9296c3251eb6571e43019400f83c765c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa6557cbdeb7309d19bb44c69a8b68ac5">pl_VectorIsEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item in two input vectors.  <a href="#gaa6557cbdeb7309d19bb44c69a8b68ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6b41819ebe1d49fbf7fcea593eea1585">pl_VectorIsEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="#ga6b41819ebe1d49fbf7fcea593eea1585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaced300febadf01a9bb061b2eb55b4c82">pl_VectorIsEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="#gaced300febadf01a9bb061b2eb55b4c82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4fb086ed252f0f5f8504088cf286ed35">pl_VectorIsNotEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item in two input vectors.  <a href="#ga4fb086ed252f0f5f8504088cf286ed35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga427f715543dfb78fa061b1da9ae2f34c">pl_VectorIsNotEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="#ga427f715543dfb78fa061b1da9ae2f34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacc43628c757ac7fbf663ecf1d09aa5a7">pl_VectorIsNotEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="#gacc43628c757ac7fbf663ecf1d09aa5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga742971fee5ae052c2cb95a9955cf7542">pl_VectorIsGreaterThanD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item in two input vectors.  <a href="#ga742971fee5ae052c2cb95a9955cf7542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5fb9c4d06a6d72de5ce40804ff346460">pl_VectorIsGreaterThanD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="#ga5fb9c4d06a6d72de5ce40804ff346460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75e868cbab5a492e1daebf106fe89d64">pl_VectorIsGreaterThanD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="#ga75e868cbab5a492e1daebf106fe89d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5db5ae33ecc38702db1987d7f58003d">pl_VectorIsGreaterThanOrEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item in two input vectors.  <a href="#gad5db5ae33ecc38702db1987d7f58003d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09d06ce6f60c7093743530f7340d0db3">pl_VectorIsGreaterThanOrEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#ga09d06ce6f60c7093743530f7340d0db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf1b670f32504cfee3765b6f7aec16a60">pl_VectorIsGreaterThanOrEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#gaf1b670f32504cfee3765b6f7aec16a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga991f8dd0bbc5c9dfca56eb70e2139dfe">pl_VectorIsLessThanD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item in two input vectors.  <a href="#ga991f8dd0bbc5c9dfca56eb70e2139dfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7eb97b849367dd8a0b92c4e4cdffe983">pl_VectorIsLessThanD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="#ga7eb97b849367dd8a0b92c4e4cdffe983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3f91ec7596d951ef68b47e277ef6c5ba">pl_VectorIsLessThanD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="#ga3f91ec7596d951ef68b47e277ef6c5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75601e89fa96c2711c9c1d762bd26633">pl_VectorIsLessThanOrEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item in two input vectors.  <a href="#ga75601e89fa96c2711c9c1d762bd26633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae14f26d0d6c23b301370264f5d2f5820">pl_VectorIsLessThanOrEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#gae14f26d0d6c23b301370264f5d2f5820"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga883e9677cffce2e7a385c048c0cf6051">pl_VectorIsLessThanOrEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#ga883e9677cffce2e7a385c048c0cf6051"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga400b8712d0ef2f7222022e3030ab65d5">pl_VectorHypotD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item in two input vectors.  <a href="#ga400b8712d0ef2f7222022e3030ab65d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadefa93b1fb00f994acaf717eb876f05b">pl_VectorHypotD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="#gadefa93b1fb00f994acaf717eb876f05b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4beba0c36335d94c6c76b9a16aaee33f">pl_VectorHypotD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="#ga4beba0c36335d94c6c76b9a16aaee33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga89afb2f55dfc5f5a749799d78aa27693">pl_VectorAtan2D_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item in two input vectors.  <a href="#ga89afb2f55dfc5f5a749799d78aa27693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9ae9c8c64cfe988951cbc4b51b81abf">pl_VectorAtan2D_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="#gae9ae9c8c64cfe988951cbc4b51b81abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadac799a76f6ffc595d2b0771279a48a4">pl_VectorAtan2D_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="#gadac799a76f6ffc595d2b0771279a48a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4bb7bd02652c307ae3f496df0354e8a3">pl_VectorSumSqrD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item in two input vectors.  <a href="#ga4bb7bd02652c307ae3f496df0354e8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga79278b4c9dbf253e5179556919e9b35b">pl_VectorSumSqrD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="#ga79278b4c9dbf253e5179556919e9b35b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadc42b9865fb1e2b4f33ec9da262b2092">pl_VectorSumSqrD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="#gadc42b9865fb1e2b4f33ec9da262b2092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaac8f1f8d6c6d929b667f15dbe053831c">pl_VectorDifSqrD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item in two input vectors.  <a href="#gaac8f1f8d6c6d929b667f15dbe053831c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga46775562a5d0bbd8d670bd7e95284783">pl_VectorDifSqrD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="#ga46775562a5d0bbd8d670bd7e95284783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9d40bd884f8f805edebd3c59ca883a38">pl_VectorDifSqrD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="#ga9d40bd884f8f805edebd3c59ca883a38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga788004c04a717f469b0f1998d4f62067">pl_VectorSqrSumD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item in two input vectors.  <a href="#ga788004c04a717f469b0f1998d4f62067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac9a2a0223d3af7c542c0fa570ce00a17">pl_VectorSqrSumD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="#gac9a2a0223d3af7c542c0fa570ce00a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f56150d804d6952997e90fb803958e4">pl_VectorSqrSumD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="#ga5f56150d804d6952997e90fb803958e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4e737d98b7ad71c71432248a39c2ce16">pl_VectorSqrDifD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item in two input vectors.  <a href="#ga4e737d98b7ad71c71432248a39c2ce16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f6940ac9a86f57efe4bce7400d9234b">pl_VectorSqrDifD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="#ga6f6940ac9a86f57efe4bce7400d9234b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2001054b1fcbeee5191c265bcbaeea2c">pl_VectorSqrDifD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="#ga2001054b1fcbeee5191c265bcbaeea2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5778badb734f9dc6fab15eadd6e31bc7">pl_VectorAbsDifD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item in two input vectors.  <a href="#ga5778badb734f9dc6fab15eadd6e31bc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7625f658d95e5bfaa275bcb24560575">pl_VectorAbsDifD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="#gaf7625f658d95e5bfaa275bcb24560575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fcc23c11a1a0ef8790d60c4be0ce4fd">pl_VectorAbsDifD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="#ga7fcc23c11a1a0ef8790d60c4be0ce4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga57d7f27f996ba4e74be09197791e404d">pl_VectorThreshD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item in two input vectors.  <a href="#ga57d7f27f996ba4e74be09197791e404d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga87f14ff8770a1f823a4157bc40e1e5d6">pl_VectorThreshD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="#ga87f14ff8770a1f823a4157bc40e1e5d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ddd02df030d53aa2e7ef50e24d6aa84">pl_VectorThreshD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="#ga0ddd02df030d53aa2e7ef50e24d6aa84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4f1ffab901ada34b727346e72b700627">pl_VectorMulAddD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *io, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *mul, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *add, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga4f1ffab901ada34b727346e72b700627"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadaaf12325ee661c80ccc2c3a227ddf5d">pl_VectorLookupD_NnN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *table, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> n, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *index, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gadaaf12325ee661c80ccc2c3a227ddf5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacbc71dd2eca4c999c95c102a9c73cc93">pl_VectorConvertF2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gacbc71dd2eca4c999c95c102a9c73cc93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab24285a50f2a54306afd123b26565712">pl_VectorConvertD2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gab24285a50f2a54306afd123b26565712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5cc444c966b81277ed6ee74d9c886739">pl_VectorConvertC2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga5cc444c966b81277ed6ee74d9c886739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5eaf68cc4df2f0c8fad4539b56a18d51">pl_VectorConvertI2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga5eaf68cc4df2f0c8fad4539b56a18d51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b51b5328580cc5ddf4521f4703c5b55">pl_VectorConvertS2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga3b51b5328580cc5ddf4521f4703c5b55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafbd6fd167171c338f68603c0702f163e">pl_VectorConvertL2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gafbd6fd167171c338f68603c0702f163e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4e285c9f6dcaa89e390afa72c6a6b09b">pl_VectorConvertF2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga4e285c9f6dcaa89e390afa72c6a6b09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9f42da972277e2deb1bf0dcf69db01e8">pl_VectorConvertD2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga9f42da972277e2deb1bf0dcf69db01e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedc6a191f061ddada0e208e42f8f838d">pl_VectorConvertC2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gaedc6a191f061ddada0e208e42f8f838d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaced113e4c43b1e2215f05dbdd8b12acf">pl_VectorConvertI2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gaced113e4c43b1e2215f05dbdd8b12acf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0d3db035bc4c110b3e12a119f6160282">pl_VectorConvertS2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga0d3db035bc4c110b3e12a119f6160282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gababc20fcad2f2a506e40821426a23477">pl_VectorConvertL2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gababc20fcad2f2a506e40821426a23477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga942c4382f9ae4bd6978b49f53c43a03c">pl_VectorConvertF2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga942c4382f9ae4bd6978b49f53c43a03c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga80f5fee7b516ceaaa0b261589d3ee87c">pl_VectorConvertD2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga80f5fee7b516ceaaa0b261589d3ee87c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9ee67f05d621c58833ae61bedf7393e">pl_VectorConvertC2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gad9ee67f05d621c58833ae61bedf7393e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab931e55a5e5c2dc325262ddce0b6c900">pl_VectorConvertI2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gab931e55a5e5c2dc325262ddce0b6c900"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5ff4edc54c8076017f196becd1dd3138">pl_VectorConvertS2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga5ff4edc54c8076017f196becd1dd3138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga59ebc7d932991c002cba1f42758477ca">pl_VectorConvertL2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga59ebc7d932991c002cba1f42758477ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga466e308e8944174cd5f8202a1bcc5baa">pl_VectorConvertF2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga466e308e8944174cd5f8202a1bcc5baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09cd4d35ff54eddd0c90639e00307112">pl_VectorConvertD2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga09cd4d35ff54eddd0c90639e00307112"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga69f7eb876585caae9455b5e328774831">pl_VectorConvertC2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga69f7eb876585caae9455b5e328774831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafcda88f35a46b22d02cbc9a107121573">pl_VectorConvertI2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gafcda88f35a46b22d02cbc9a107121573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae3b94b589f0cb52834f70a44afb3658a">pl_VectorConvertS2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gae3b94b589f0cb52834f70a44afb3658a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa13285fa1d5084041fe8c964a544c1b2">pl_VectorConvertL2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gaa13285fa1d5084041fe8c964a544c1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga64328cc0671095e95ce6980ab94713db">pl_VectorConvertF2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga64328cc0671095e95ce6980ab94713db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf8d79e8f5006f3a67310223f4aa94d13">pl_VectorConvertD2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gaf8d79e8f5006f3a67310223f4aa94d13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gade5aa6494a873eb2f9387846caf271f8">pl_VectorConvertC2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gade5aa6494a873eb2f9387846caf271f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gade71481d4db8844ba37b7eb0ca2a18aa">pl_VectorConvertI2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gade71481d4db8844ba37b7eb0ca2a18aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabc6677e90f170c8309699d4e2ea5a4ac">pl_VectorConvertS2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gabc6677e90f170c8309699d4e2ea5a4ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabb50f2151ee649452a81e9aa985e4756">pl_VectorConvertL2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gabb50f2151ee649452a81e9aa985e4756"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaec26c24ad8939fe96a95aed17fefebf5">pl_VectorConvertF2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gaec26c24ad8939fe96a95aed17fefebf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2b10e4b7de6bc78ce1e0ba5f5a6b8552">pl_VectorConvertD2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga2b10e4b7de6bc78ce1e0ba5f5a6b8552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga95770db3f02219ab53d8cf0ae65dae49">pl_VectorConvertC2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga95770db3f02219ab53d8cf0ae65dae49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2c3df1cbf15e2ce9476b2ce45b807e50">pl_VectorConvertI2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga2c3df1cbf15e2ce9476b2ce45b807e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4aa5ede069e1c9a8a6fc9c954fdc82dc">pl_VectorConvertS2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#ga4aa5ede069e1c9a8a6fc9c954fdc82dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac52c925e70f7b708c5439692c8d27c22">pl_VectorConvertL2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="#gac52c925e70f7b708c5439692c8d27c22"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Vector processing functions. </p>
<p>These process vectors (arrays) of data applying common maths functions to the inputs. The default is to use the scalar processing functions (implmented with a loop in C) but many of these operations can be performed with faster, optimised libraries on some platforms (e.g., vDSP on Mac OS X and iOS).</p>
<p>The naming convention is to prefix all functions with 'pl_Vector'. This is followed by the name of the operation which is commonly the name of an equivalent scalar function. Finally the name is suffixed with a code to identify the type of vectors and/or scalar values passed to the function. The code starts with the number of items in the output vector and is followed by codes for the sizes of the other input vectors. For example, all the unary operators are suffixed '_NN' so show the input and output vectors are the same size 'N' (which is the N argument passed the the function). Some binary operators are suffixed '_NNN', '_NN1' or '_N1N'. The first is where there are two input vectors and the output vector that are all the same size. '_NN1' has an input vector with the same size as the output and a scalar value '1' (i.e., a scalar) as the other operand. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae0e337b7b89735618a1855ea91660bd9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorA2dBD_NN" ref="gae0e337b7b89735618a1855ea91660bd9" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorA2dBD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d6a453af826e1347bbe6801068431e4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorA2dBF_NN" ref="ga6d6a453af826e1347bbe6801068431e4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorA2dBF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec21dab0c087e0b170745b2e3efd207b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsD_NN" ref="gaec21dab0c087e0b170745b2e3efd207b" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fcc23c11a1a0ef8790d60c4be0ce4fd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_N1N" ref="ga7fcc23c11a1a0ef8790d60c4be0ce4fd" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7625f658d95e5bfaa275bcb24560575"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_NN1" ref="gaf7625f658d95e5bfaa275bcb24560575" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5778badb734f9dc6fab15eadd6e31bc7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_NNN" ref="ga5778badb734f9dc6fab15eadd6e31bc7" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a66577c30fc72bd6eff2271f9c10b16"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_N1N" ref="ga3a66577c30fc72bd6eff2271f9c10b16" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c8da37fdfd80aebd9d1743a0da9b497"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_NN1" ref="ga1c8da37fdfd80aebd9d1743a0da9b497" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9d78883696faed1ffc7b1ed6cbb4bc8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_NNN" ref="gaa9d78883696faed1ffc7b1ed6cbb4bc8" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0da76047e2f5935ce69ec1b4084959b7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsF_NN" ref="ga0da76047e2f5935ce69ec1b4084959b7" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacac99df0db7dad5461861849601a0dc8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAcosD_NN" ref="gacac99df0db7dad5461861849601a0dc8" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAcosD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b0876ed78d4675a40aec91015020543"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAcosF_NN" ref="ga4b0876ed78d4675a40aec91015020543" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAcosF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a1316615dc2031b02b71424f44d657f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_N1N" ref="ga5a1316615dc2031b02b71424f44d657f" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae41675932ccb373a167cd2c83e3df768"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_NN1" ref="gae41675932ccb373a167cd2c83e3df768" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12ef092e0c8e669d7762e69d0559e3a2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_NNN" ref="ga12ef092e0c8e669d7762e69d0559e3a2" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96c458ac80a73ae97d9836e7cdff6653"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_N1N" ref="ga96c458ac80a73ae97d9836e7cdff6653" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53fdeba08d131bafeee9e2217b79f77a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_NN1" ref="ga53fdeba08d131bafeee9e2217b79f77a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3874b7ec8eb9d6daa7e57928ac093a9c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_NNN" ref="ga3874b7ec8eb9d6daa7e57928ac093a9c" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedae3e19d90c4a4cb5212edadcd76f76"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAsinD_NN" ref="gaedae3e19d90c4a4cb5212edadcd76f76" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAsinD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40b4fd224d5c1df552bd36fd79e14d46"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAsinF_NN" ref="ga40b4fd224d5c1df552bd36fd79e14d46" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAsinF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadac799a76f6ffc595d2b0771279a48a4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_N1N" ref="gadac799a76f6ffc595d2b0771279a48a4" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9ae9c8c64cfe988951cbc4b51b81abf"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_NN1" ref="gae9ae9c8c64cfe988951cbc4b51b81abf" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89afb2f55dfc5f5a749799d78aa27693"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_NNN" ref="ga89afb2f55dfc5f5a749799d78aa27693" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1570febbc25f8b9a3ef7ac8cc7af07ae"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_N1N" ref="ga1570febbc25f8b9a3ef7ac8cc7af07ae" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaece9a054e73c28bd180580b0cd016018"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_NN1" ref="gaece9a054e73c28bd180580b0cd016018" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44812f3688888b573be8c9db069b936a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_NNN" ref="ga44812f3688888b573be8c9db069b936a" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dcc5850da8f410f63fb5c929a0f7e76"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtanD_NN" ref="ga2dcc5850da8f410f63fb5c929a0f7e76" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtanD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c392fc9382aa520c8d73f30ce097361"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtanF_NN" ref="ga1c392fc9382aa520c8d73f30ce097361" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtanF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50da194cf31d82e931c3d2b3509934b3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCeilD_NN" ref="ga50da194cf31d82e931c3d2b3509934b3" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCeilD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga624ee54e6e8bab7bd8f81997c07b7242"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCeilF_NN" ref="ga624ee54e6e8bab7bd8f81997c07b7242" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCeilF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa347eccfa116a68b56f8f5eee79e5707"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearD_N" ref="gaa347eccfa116a68b56f8f5eee79e5707" args="(PlankD *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearD_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="ga56913dd2881acd870e0bf0b81761f29a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearF_N" ref="ga56913dd2881acd870e0bf0b81761f29a" args="(PlankF *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearF_N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="gad9ee67f05d621c58833ae61bedf7393e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2C_NN" ref="gad9ee67f05d621c58833ae61bedf7393e" args="(PlankC *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gaedc6a191f061ddada0e208e42f8f838d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2D_NN" ref="gaedc6a191f061ddada0e208e42f8f838d" args="(PlankD *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga5cc444c966b81277ed6ee74d9c886739"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2F_NN" ref="ga5cc444c966b81277ed6ee74d9c886739" args="(PlankF *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga69f7eb876585caae9455b5e328774831"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2I_NN" ref="ga69f7eb876585caae9455b5e328774831" args="(PlankI *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga95770db3f02219ab53d8cf0ae65dae49"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2L_NN" ref="ga95770db3f02219ab53d8cf0ae65dae49" args="(PlankL *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gade5aa6494a873eb2f9387846caf271f8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertC2S_NN" ref="gade5aa6494a873eb2f9387846caf271f8" args="(PlankS *result, const PlankC *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertC2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga80f5fee7b516ceaaa0b261589d3ee87c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2C_NN" ref="ga80f5fee7b516ceaaa0b261589d3ee87c" args="(PlankC *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga9f42da972277e2deb1bf0dcf69db01e8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2D_NN" ref="ga9f42da972277e2deb1bf0dcf69db01e8" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gab24285a50f2a54306afd123b26565712"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2F_NN" ref="gab24285a50f2a54306afd123b26565712" args="(PlankF *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga09cd4d35ff54eddd0c90639e00307112"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2I_NN" ref="ga09cd4d35ff54eddd0c90639e00307112" args="(PlankI *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga2b10e4b7de6bc78ce1e0ba5f5a6b8552"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2L_NN" ref="ga2b10e4b7de6bc78ce1e0ba5f5a6b8552" args="(PlankL *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gaf8d79e8f5006f3a67310223f4aa94d13"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertD2S_NN" ref="gaf8d79e8f5006f3a67310223f4aa94d13" args="(PlankS *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertD2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga942c4382f9ae4bd6978b49f53c43a03c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2C_NN" ref="ga942c4382f9ae4bd6978b49f53c43a03c" args="(PlankC *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga4e285c9f6dcaa89e390afa72c6a6b09b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2D_NN" ref="ga4e285c9f6dcaa89e390afa72c6a6b09b" args="(PlankD *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gacbc71dd2eca4c999c95c102a9c73cc93"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2F_NN" ref="gacbc71dd2eca4c999c95c102a9c73cc93" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga466e308e8944174cd5f8202a1bcc5baa"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2I_NN" ref="ga466e308e8944174cd5f8202a1bcc5baa" args="(PlankI *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gaec26c24ad8939fe96a95aed17fefebf5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2L_NN" ref="gaec26c24ad8939fe96a95aed17fefebf5" args="(PlankL *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga64328cc0671095e95ce6980ab94713db"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertF2S_NN" ref="ga64328cc0671095e95ce6980ab94713db" args="(PlankS *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertF2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gab931e55a5e5c2dc325262ddce0b6c900"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2C_NN" ref="gab931e55a5e5c2dc325262ddce0b6c900" args="(PlankC *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gaced113e4c43b1e2215f05dbdd8b12acf"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2D_NN" ref="gaced113e4c43b1e2215f05dbdd8b12acf" args="(PlankD *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga5eaf68cc4df2f0c8fad4539b56a18d51"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2F_NN" ref="ga5eaf68cc4df2f0c8fad4539b56a18d51" args="(PlankF *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gafcda88f35a46b22d02cbc9a107121573"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2I_NN" ref="gafcda88f35a46b22d02cbc9a107121573" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga2c3df1cbf15e2ce9476b2ce45b807e50"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2L_NN" ref="ga2c3df1cbf15e2ce9476b2ce45b807e50" args="(PlankL *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gade71481d4db8844ba37b7eb0ca2a18aa"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertI2S_NN" ref="gade71481d4db8844ba37b7eb0ca2a18aa" args="(PlankS *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertI2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga59ebc7d932991c002cba1f42758477ca"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2C_NN" ref="ga59ebc7d932991c002cba1f42758477ca" args="(PlankC *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gababc20fcad2f2a506e40821426a23477"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2D_NN" ref="gababc20fcad2f2a506e40821426a23477" args="(PlankD *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gafbd6fd167171c338f68603c0702f163e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2F_NN" ref="gafbd6fd167171c338f68603c0702f163e" args="(PlankF *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gaa13285fa1d5084041fe8c964a544c1b2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2I_NN" ref="gaa13285fa1d5084041fe8c964a544c1b2" args="(PlankI *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gac52c925e70f7b708c5439692c8d27c22"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2L_NN" ref="gac52c925e70f7b708c5439692c8d27c22" args="(PlankL *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gabb50f2151ee649452a81e9aa985e4756"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertL2S_NN" ref="gabb50f2151ee649452a81e9aa985e4756" args="(PlankS *result, const PlankL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertL2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga5ff4edc54c8076017f196becd1dd3138"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2C_NN" ref="ga5ff4edc54c8076017f196becd1dd3138" args="(PlankC *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2C_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga0d3db035bc4c110b3e12a119f6160282"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2D_NN" ref="ga0d3db035bc4c110b3e12a119f6160282" args="(PlankD *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga3b51b5328580cc5ddf4521f4703c5b55"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2F_NN" ref="ga3b51b5328580cc5ddf4521f4703c5b55" args="(PlankF *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gae3b94b589f0cb52834f70a44afb3658a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2I_NN" ref="gae3b94b589f0cb52834f70a44afb3658a" args="(PlankI *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2I_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga4aa5ede069e1c9a8a6fc9c954fdc82dc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2L_NN" ref="ga4aa5ede069e1c9a8a6fc9c954fdc82dc" args="(PlankL *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2L_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="gabc6677e90f170c8309699d4e2ea5a4ac"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorConvertS2S_NN" ref="gabc6677e90f170c8309699d4e2ea5a4ac" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorConvertS2S_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a vector of one data type to another. </p>

</div>
</div>
<a class="anchor" id="ga5eb1030590f71b5165e3f72b6bd656e5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCosD_NN" ref="ga5eb1030590f71b5165e3f72b6bd656e5" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCosD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dc9e1a1005c50962f50b218bdd359f7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCosF_NN" ref="ga2dc9e1a1005c50962f50b218bdd359f7" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCosF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5853e6b3aff90d56b2d433da806d858f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCoshD_NN" ref="ga5853e6b3aff90d56b2d433da806d858f" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCoshD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7fca130c7b57d8f99ba52546a3d401f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCoshF_NN" ref="gae7fca130c7b57d8f99ba52546a3d401f" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCoshF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac92318b9550618c0eb61f5c6db28b6f0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedD_NN" ref="gac92318b9550618c0eb61f5c6db28b6f0" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14c2dd307d97ebea1a2b0a79a4f18f3f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedF_NN" ref="ga14c2dd307d97ebea1a2b0a79a4f18f3f" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaba41fd68b23cb9bdd1cefb6c4b71c7a4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorD2RD_NN" ref="gaba41fd68b23cb9bdd1cefb6c4b71c7a4" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorD2RD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4ffbe59182ba1514ccd8969ed780394"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorD2RF_NN" ref="gac4ffbe59182ba1514ccd8969ed780394" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorD2RF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bb9f2cc273aaefa164d83f970e30380"></a><!-- doxytag: member="plank_Vectors.h::pl_VectordB2AD_NN" ref="ga7bb9f2cc273aaefa164d83f970e30380" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectordB2AD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf55e4f2965d3427a503f26e3e3d22a40"></a><!-- doxytag: member="plank_Vectors.h::pl_VectordB2AF_NN" ref="gaf55e4f2965d3427a503f26e3e3d22a40" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectordB2AF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d40bd884f8f805edebd3c59ca883a38"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_N1N" ref="ga9d40bd884f8f805edebd3c59ca883a38" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46775562a5d0bbd8d670bd7e95284783"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_NN1" ref="ga46775562a5d0bbd8d670bd7e95284783" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac8f1f8d6c6d929b667f15dbe053831c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_NNN" ref="gaac8f1f8d6c6d929b667f15dbe053831c" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c6f0bc2d31739420492413ade319f84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_N1N" ref="ga8c6f0bc2d31739420492413ade319f84" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab11b4161a9b842caf8431aa6e578f81"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_NN1" ref="gaab11b4161a9b842caf8431aa6e578f81" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecd22cb5b339a05a83a47ce9a5eb303d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_NNN" ref="gaecd22cb5b339a05a83a47ce9a5eb303d" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1c81935d93b40e48a4986fc20c9e34b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDistortD_NN" ref="gae1c81935d93b40e48a4986fc20c9e34b" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDistortD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1abd9fad50bb7512458ef32c19399f3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDistortF_NN" ref="gab1abd9fad50bb7512458ef32c19399f3" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDistortF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98a3a9eeb92bfa82aa1d7f6d12fbd89a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_N1N" ref="ga98a3a9eeb92bfa82aa1d7f6d12fbd89a" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa19c40021b63a0d14db1eddd9d0a037e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_NN1" ref="gaa19c40021b63a0d14db1eddd9d0a037e" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fa89f9180cd6811ec7a0eb94605b996"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_NNN" ref="ga1fa89f9180cd6811ec7a0eb94605b996" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fb4b91f3c0068e6b0805195a7899c34"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_N1N" ref="ga7fb4b91f3c0068e6b0805195a7899c34" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga647b8c4642bc5c02b4b4ad7fca5434eb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_NN1" ref="ga647b8c4642bc5c02b4b4ad7fca5434eb" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6db0d03c2bb9e5a663ac3e1d4d3d76a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_NNN" ref="gae6db0d03c2bb9e5a663ac3e1d4d3d76a" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga346a791b777f3fb3ce4a8b5ab8dd0133"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorExpD_NN" ref="ga346a791b777f3fb3ce4a8b5ab8dd0133" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorExpD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2832cd0f9496ce0c593be00454cc1d56"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorExpF_NN" ref="ga2832cd0f9496ce0c593be00454cc1d56" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorExpF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga781a129439e1bb1dd0295a99085f3a84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorF2MD_NN" ref="ga781a129439e1bb1dd0295a99085f3a84" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorF2MD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga346ccfb5366b8795fb98c20817553baf"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorF2MF_NN" ref="ga346ccfb5366b8795fb98c20817553baf" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorF2MF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d51b6cf9010ce1fa63b9762249261a0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillD_N1" ref="ga3d51b6cf9010ce1fa63b9762249261a0" args="(PlankD *result, PlankD value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillD_N1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="gaf264cdbe70928e87484c7ef7c7e770da"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillF_N1" ref="gaf264cdbe70928e87484c7ef7c7e770da" args="(PlankF *result, PlankF value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillF_N1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="ga0fabcca5e7164c365cecccf20a2ad394"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFloorD_NN" ref="ga0fabcca5e7164c365cecccf20a2ad394" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFloorD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53d443eaba00cc8255d4d1dd7dc3de79"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFloorF_NN" ref="ga53d443eaba00cc8255d4d1dd7dc3de79" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFloorF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb35318b9e872a8d4d86d9c795d368b2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFracD_NN" ref="gaeb35318b9e872a8d4d86d9c795d368b2" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFracD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga772400768495fd4fd693256ad3c48f33"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFracF_NN" ref="ga772400768495fd4fd693256ad3c48f33" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFracF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4beba0c36335d94c6c76b9a16aaee33f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_N1N" ref="ga4beba0c36335d94c6c76b9a16aaee33f" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadefa93b1fb00f994acaf717eb876f05b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_NN1" ref="gadefa93b1fb00f994acaf717eb876f05b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga400b8712d0ef2f7222022e3030ab65d5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_NNN" ref="ga400b8712d0ef2f7222022e3030ab65d5" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0893c32e31d72a7e91badc4abf62b3b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_N1N" ref="gaf0893c32e31d72a7e91badc4abf62b3b" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga939e06569593c806d533ea61e4b98327"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_NN1" ref="ga939e06569593c806d533ea61e4b98327" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabff48d9f05d09c6fc3024f2095a91630"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_NNN" ref="gabff48d9f05d09c6fc3024f2095a91630" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaced300febadf01a9bb061b2eb55b4c82"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_N1N" ref="gaced300febadf01a9bb061b2eb55b4c82" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b41819ebe1d49fbf7fcea593eea1585"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_NN1" ref="ga6b41819ebe1d49fbf7fcea593eea1585" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6557cbdeb7309d19bb44c69a8b68ac5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_NNN" ref="gaa6557cbdeb7309d19bb44c69a8b68ac5" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedb79426fa90a29103fce022679f32f4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_N1N" ref="gaedb79426fa90a29103fce022679f32f4" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf88f51bb6a26c2d0a68e994d863711c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_NN1" ref="gacf88f51bb6a26c2d0a68e994d863711c" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5cbc606bff150d3be2e698aac7dc5ce4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_NNN" ref="ga5cbc606bff150d3be2e698aac7dc5ce4" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75e868cbab5a492e1daebf106fe89d64"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_N1N" ref="ga75e868cbab5a492e1daebf106fe89d64" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fb9c4d06a6d72de5ce40804ff346460"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_NN1" ref="ga5fb9c4d06a6d72de5ce40804ff346460" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga742971fee5ae052c2cb95a9955cf7542"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_NNN" ref="ga742971fee5ae052c2cb95a9955cf7542" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ff4eb184fe6458d583af93f5f5d72a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_N1N" ref="ga7ff4eb184fe6458d583af93f5f5d72a3" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3298d662a1a1002f1a911cf89576f12e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_NN1" ref="ga3298d662a1a1002f1a911cf89576f12e" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6030e695b7b354d7c668506b6dd8777e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_NNN" ref="ga6030e695b7b354d7c668506b6dd8777e" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1b670f32504cfee3765b6f7aec16a60"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_N1N" ref="gaf1b670f32504cfee3765b6f7aec16a60" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09d06ce6f60c7093743530f7340d0db3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_NN1" ref="ga09d06ce6f60c7093743530f7340d0db3" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5db5ae33ecc38702db1987d7f58003d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_NNN" ref="gad5db5ae33ecc38702db1987d7f58003d" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9563d0b877e5656f9e68dbe1f172b1c2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_N1N" ref="ga9563d0b877e5656f9e68dbe1f172b1c2" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c70aa006400c76931250bdcccf52e37"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_NN1" ref="ga5c70aa006400c76931250bdcccf52e37" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34dbb414e4e85a5dc21cab04efb36e17"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_NNN" ref="ga34dbb414e4e85a5dc21cab04efb36e17" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f91ec7596d951ef68b47e277ef6c5ba"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_N1N" ref="ga3f91ec7596d951ef68b47e277ef6c5ba" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7eb97b849367dd8a0b92c4e4cdffe983"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_NN1" ref="ga7eb97b849367dd8a0b92c4e4cdffe983" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga991f8dd0bbc5c9dfca56eb70e2139dfe"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_NNN" ref="ga991f8dd0bbc5c9dfca56eb70e2139dfe" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98ef2362c8ee3b97169746404863b0bb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_N1N" ref="ga98ef2362c8ee3b97169746404863b0bb" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada27b912481be2974f2df10287c24cca"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_NN1" ref="gada27b912481be2974f2df10287c24cca" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc1473081b72235572bbcb4180f85532"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_NNN" ref="gafc1473081b72235572bbcb4180f85532" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga883e9677cffce2e7a385c048c0cf6051"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_N1N" ref="ga883e9677cffce2e7a385c048c0cf6051" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae14f26d0d6c23b301370264f5d2f5820"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_NN1" ref="gae14f26d0d6c23b301370264f5d2f5820" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75601e89fa96c2711c9c1d762bd26633"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_NNN" ref="ga75601e89fa96c2711c9c1d762bd26633" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9b4e616e12b4510ed11658d46985b6d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_N1N" ref="gaa9b4e616e12b4510ed11658d46985b6d" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f64176207c3d68ae22cddb34d496266"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_NN1" ref="ga5f64176207c3d68ae22cddb34d496266" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae336bfe2cf955934a4cee32d66b4817e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_NNN" ref="gae336bfe2cf955934a4cee32d66b4817e" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc43628c757ac7fbf663ecf1d09aa5a7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_N1N" ref="gacc43628c757ac7fbf663ecf1d09aa5a7" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga427f715543dfb78fa061b1da9ae2f34c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_NN1" ref="ga427f715543dfb78fa061b1da9ae2f34c" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4fb086ed252f0f5f8504088cf286ed35"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_NNN" ref="ga4fb086ed252f0f5f8504088cf286ed35" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56a9fe4ef33f7d81a29e7aab0a1592c0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_N1N" ref="ga56a9fe4ef33f7d81a29e7aab0a1592c0" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga774c6a0e634df1f397516a6a805a4d6d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_NN1" ref="ga774c6a0e634df1f397516a6a805a4d6d" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9a46a8c1db7476211bdd6b44fb19d49"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_NNN" ref="gae9a46a8c1db7476211bdd6b44fb19d49" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81e869fd2297a6c57b5e3a312fc33b74"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineD_N11" ref="ga81e869fd2297a6c57b5e3a312fc33b74" args="(PlankD *result, PlankD a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineD_N11 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga5af8b83ed87be0faee019340b9cc07a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineF_N11" ref="ga5af8b83ed87be0faee019340b9cc07a3" args="(PlankF *result, PlankF a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineF_N11 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga1a5902d66076b7527b8ca6a674fef22e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog10D_NN" ref="ga1a5902d66076b7527b8ca6a674fef22e" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog10D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5680198a0c9c769ad052a505769d8e65"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog10F_NN" ref="ga5680198a0c9c769ad052a505769d8e65" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog10F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f77253685ccd08349ad129a0bc09a23"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog2D_NN" ref="ga2f77253685ccd08349ad129a0bc09a23" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog2D_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f8cf6b2f7fa17fb800ff0e1d5a2e167"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog2F_NN" ref="ga6f8cf6b2f7fa17fb800ff0e1d5a2e167" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog2F_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b06f007387aeffb3ebd2214f5090fb8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLogD_NN" ref="ga3b06f007387aeffb3ebd2214f5090fb8" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLogD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6154ea39d75e68b9e9d5330cb3625eec"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLogF_NN" ref="ga6154ea39d75e68b9e9d5330cb3625eec" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLogF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadaaf12325ee661c80ccc2c3a227ddf5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupD_NnN" ref="gadaaf12325ee661c80ccc2c3a227ddf5d" args="(PlankD *result, PlankD *table, PlankUL n, PlankD *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupD_NnN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaddee28f3d1f630066c181c8a6ac97aea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupF_NnN" ref="gaddee28f3d1f630066c181c8a6ac97aea" args="(PlankF *result, PlankF *table, PlankUL n, PlankF *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupF_NnN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08b1418b75b12da60a96a514008a3e2d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorM2FD_NN" ref="ga08b1418b75b12da60a96a514008a3e2d" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorM2FD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga434579ecb8b69a86b3c1b5e19640d3e9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorM2FF_NN" ref="ga434579ecb8b69a86b3c1b5e19640d3e9" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorM2FF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad687be0c0ca10457b0d9ea29d3e737c2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_N1N" ref="gad687be0c0ca10457b0d9ea29d3e737c2" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafdcc887ab924c442c0496cd98cb8bf08"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_NN1" ref="gafdcc887ab924c442c0496cd98cb8bf08" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab73fa94aad3f3a9ea9b4281fa2a45637"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_NNN" ref="gab73fa94aad3f3a9ea9b4281fa2a45637" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaabafa18c8dd0ec2c12e11b6f42cc2493"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_N1N" ref="gaabafa18c8dd0ec2c12e11b6f42cc2493" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e548c19fcaaa84dc28e05af2b4cd88a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_NN1" ref="ga2e548c19fcaaa84dc28e05af2b4cd88a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ee95f778cdfcd034e902fb81f7c885"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_NNN" ref="gad8ee95f778cdfcd034e902fb81f7c885" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09f665f6b1bddb3bd7669410e10b3c02"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_N1N" ref="ga09f665f6b1bddb3bd7669410e10b3c02" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga750a9c78d6f4857c73ab1ee9cdbd65ad"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_NN1" ref="ga750a9c78d6f4857c73ab1ee9cdbd65ad" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3267ac92b409d85e0f1195214d19bcf1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_NNN" ref="ga3267ac92b409d85e0f1195214d19bcf1" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8dd296051688e3035e6d0f7dff95c2ab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_N1N" ref="ga8dd296051688e3035e6d0f7dff95c2ab" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3a514ff8c829f3f0c34cc3cb8532fa9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_NN1" ref="gaa3a514ff8c829f3f0c34cc3cb8532fa9" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa31eb103c9cb1b7af8ec1d68940fc816"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_NNN" ref="gaa31eb103c9cb1b7af8ec1d68940fc816" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92916e1daf6e82d9404d525e42389b45"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveD_NN" ref="ga92916e1daf6e82d9404d525e42389b45" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6afd6f38943e06da5514a63e90c0faf9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveF_NN" ref="ga6afd6f38943e06da5514a63e90c0faf9" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f1ffab901ada34b727346e72b700627"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NNN" ref="ga4f1ffab901ada34b727346e72b700627" args="(PlankD *io, const PlankD *mul, const PlankD *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io * mul + add $" src="form_14.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9877065544b3718d8d187d5f50cdf24"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NNN" ref="gad9877065544b3718d8d187d5f50cdf24" args="(PlankF *io, const PlankF *mul, const PlankF *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io * mul + add $" src="form_14.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5e80360d5aae32ecddfba037c215af8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_N1N" ref="gaf5e80360d5aae32ecddfba037c215af8" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1bc824231e441539c1ee7df8b50e0391"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_NN1" ref="ga1bc824231e441539c1ee7df8b50e0391" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49295bf725772df3865b0fe99be4552e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_NNN" ref="ga49295bf725772df3865b0fe99be4552e" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga044d16cfcf2eda7978a038ca4a156144"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_N1N" ref="ga044d16cfcf2eda7978a038ca4a156144" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d02adf1b7e3387b882aee06bf794bab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_NN1" ref="ga4d02adf1b7e3387b882aee06bf794bab" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09b89f66bb8148bc4d7f3ade8f12ab6b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_NNN" ref="ga09b89f66bb8148bc4d7f3ade8f12ab6b" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad49e011e4ca3f76de0b8ec5c1d6d81e6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegD_NN" ref="gad49e011e4ca3f76de0b8ec5c1d6d81e6" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e8bc51e352f9e56102e8a6f8e591369"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegF_NN" ref="ga3e8bc51e352f9e56102e8a6f8e591369" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9296c3251eb6571e43019400f83c765c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_N1N" ref="ga9296c3251eb6571e43019400f83c765c" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b253f22b62b7117f6af0c31abfd6c07"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_NN1" ref="ga4b253f22b62b7117f6af0c31abfd6c07" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3373906398e94de141273acb0d6390c9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_NNN" ref="ga3373906398e94de141273acb0d6390c9" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96c1025337d92429c8734e175143f1f7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_N1N" ref="ga96c1025337d92429c8734e175143f1f7" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga483ff2d8bea2cdeec487db5efffa3d3a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_NN1" ref="ga483ff2d8bea2cdeec487db5efffa3d3a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf3b8ea80497eeec187a20e7e2848ed7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_NNN" ref="gadf3b8ea80497eeec187a20e7e2848ed7" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa22058ab0b84dd204cd0818f7eee4e71"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorR2DD_NN" ref="gaa22058ab0b84dd204cd0818f7eee4e71" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorR2DD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafdc0d266ab2c818ebf03503c1f1d0044"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorR2DF_NN" ref="gafdc0d266ab2c818ebf03503c1f1d0044" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorR2DF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac60fec7cc8a88e48270833135205ec12"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampD_N11" ref="gac60fec7cc8a88e48270833135205ec12" args="(PlankD *result, PlankD a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampD_N11 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga6083cf8cd3b19b6617c85b81dac22355"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampF_N11" ref="ga6083cf8cd3b19b6617c85b81dac22355" args="(PlankF *result, PlankF a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampF_N11 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga88f1c17c13d19ff647a659e21164ec91"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorReciprocalD_NN" ref="ga88f1c17c13d19ff647a659e21164ec91" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorReciprocalD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf552c917a97a8370eb14d70fa7fdbcd4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorReciprocalF_NN" ref="gaf552c917a97a8370eb14d70fa7fdbcd4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorReciprocalF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35254ed489bf9f5825bac6d353d80eac"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignD_NN" ref="ga35254ed489bf9f5825bac6d353d80eac" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga017d16bd185ae3cf9069e06cc9c2cf88"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignF_NN" ref="ga017d16bd185ae3cf9069e06cc9c2cf88" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab78a731a99877c501f2531b263ed0ff7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinD_NN" ref="gab78a731a99877c501f2531b263ed0ff7" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8317e0ece295c3fe4c6ddcd0c9291b73"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinF_NN" ref="ga8317e0ece295c3fe4c6ddcd0c9291b73" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebafcf0bf05dade5b95bf6066808f623"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinhD_NN" ref="gaebafcf0bf05dade5b95bf6066808f623" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinhD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d025408ed6a1435023aa7837cbbce26"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinhF_NN" ref="ga1d025408ed6a1435023aa7837cbbce26" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinhF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2001054b1fcbeee5191c265bcbaeea2c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_N1N" ref="ga2001054b1fcbeee5191c265bcbaeea2c" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f6940ac9a86f57efe4bce7400d9234b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_NN1" ref="ga6f6940ac9a86f57efe4bce7400d9234b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e737d98b7ad71c71432248a39c2ce16"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_NNN" ref="ga4e737d98b7ad71c71432248a39c2ce16" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga381554ead66ca6856122b66b1e9bf063"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_N1N" ref="ga381554ead66ca6856122b66b1e9bf063" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2229b5869509b5f0947e8927262f23b0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_NN1" ref="ga2229b5869509b5f0947e8927262f23b0" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae247f0ca7d07614d80fb70fd4f3b20ab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_NNN" ref="gae247f0ca7d07614d80fb70fd4f3b20ab" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f56150d804d6952997e90fb803958e4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_N1N" ref="ga5f56150d804d6952997e90fb803958e4" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9a2a0223d3af7c542c0fa570ce00a17"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_NN1" ref="gac9a2a0223d3af7c542c0fa570ce00a17" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga788004c04a717f469b0f1998d4f62067"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_NNN" ref="ga788004c04a717f469b0f1998d4f62067" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3568d95bc0f3df06126f00db48d52385"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_N1N" ref="ga3568d95bc0f3df06126f00db48d52385" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0cc252e1e632dd35bbb13d318f6bf51b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_NN1" ref="ga0cc252e1e632dd35bbb13d318f6bf51b" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa44f0e93a59157dc2ed7a1a320606de3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_NNN" ref="gaa44f0e93a59157dc2ed7a1a320606de3" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga540c096f6e4382440007c878047f4f5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrtD_NN" ref="ga540c096f6e4382440007c878047f4f5d" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrtD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac5eb6a022dcc12e47bb871209d94fa5b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrtF_NN" ref="gac5eb6a022dcc12e47bb871209d94fa5b" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrtF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6d6857d70c11dac6815925aa5fbe258"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredD_NN" ref="gac6d6857d70c11dac6815925aa5fbe258" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga138489a0a09ca5131c997c9bf2785020"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredF_NN" ref="ga138489a0a09ca5131c997c9bf2785020" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8ea462ef620ebc5dd512f0df2224508"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_N1N" ref="gab8ea462ef620ebc5dd512f0df2224508" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a28dc464696905e52db911b3f97566e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_NN1" ref="ga1a28dc464696905e52db911b3f97566e" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1ad270a88e18f6e9c8a51c450c3e41f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_NNN" ref="gaa1ad270a88e18f6e9c8a51c450c3e41f" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad545716dacb61f997567075c3a4a6720"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_N1N" ref="gad545716dacb61f997567075c3a4a6720" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8935b522deb4e2baf1885c78ef3c5a2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_NN1" ref="gad8935b522deb4e2baf1885c78ef3c5a2" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e7dc8aa04be89440e1440b3125cdffc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_NNN" ref="ga9e7dc8aa04be89440e1440b3125cdffc" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc42b9865fb1e2b4f33ec9da262b2092"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_N1N" ref="gadc42b9865fb1e2b4f33ec9da262b2092" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79278b4c9dbf253e5179556919e9b35b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_NN1" ref="ga79278b4c9dbf253e5179556919e9b35b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bb7bd02652c307ae3f496df0354e8a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_NNN" ref="ga4bb7bd02652c307ae3f496df0354e8a3" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5484d71a34bd278e75b8cecf45e7263"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_N1N" ref="gad5484d71a34bd278e75b8cecf45e7263" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafaba968683dddc1cb6ee402811875181"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_NN1" ref="gafaba968683dddc1cb6ee402811875181" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52cc262cb6455a1ccb4bb7d6a3b78467"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_NNN" ref="ga52cc262cb6455a1ccb4bb7d6a3b78467" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga135af6226d8b96e81abaaba6f9cd0b06"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanD_NN" ref="ga135af6226d8b96e81abaaba6f9cd0b06" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ff3f0a747f340ef59eb12ff9f5fa9ce"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanF_NN" ref="ga0ff3f0a747f340ef59eb12ff9f5fa9ce" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga250f2e61d743622a1609f85839f9c4bb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanhD_NN" ref="ga250f2e61d743622a1609f85839f9c4bb" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanhD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8184fcb4e00b71d0e152a6cd441e611"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanhF_NN" ref="gac8184fcb4e00b71d0e152a6cd441e611" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanhF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ddd02df030d53aa2e7ef50e24d6aa84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_N1N" ref="ga0ddd02df030d53aa2e7ef50e24d6aa84" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87f14ff8770a1f823a4157bc40e1e5d6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_NN1" ref="ga87f14ff8770a1f823a4157bc40e1e5d6" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57d7f27f996ba4e74be09197791e404d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_NNN" ref="ga57d7f27f996ba4e74be09197791e404d" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9bc9357afdaecf35a48a2819a1673ec5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_N1N" ref="ga9bc9357afdaecf35a48a2819a1673ec5" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_N1N </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae27592fcf9a6e2511f691e2b840340a9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_NN1" ref="gae27592fcf9a6e2511f691e2b840340a9" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_NN1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3161963fd5d2e9453250a93f01226f5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_NNN" ref="ga3161963fd5d2e9453250a93f01226f5d" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_NNN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfeb5cce886741713f4db15d8e45530a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorZapD_NN" ref="gabfeb5cce886741713f4db15d8e45530a" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorZapD_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bd51dca6361c74850caf92244eefbf4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorZapF_NN" ref="ga6bd51dca6361c74850caf92244eefbf4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorZapF_NN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 26 2012 21:36:42 for pl-nk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
