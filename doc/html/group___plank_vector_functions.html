<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pl-nk: Plank vector functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk&#160;<span id="projectnumber">v0.4.5</span></div>
   <div id="projectbrief">Plonk|Plink|Plank are a set of cross-platform C/C++ frameworks for audio software development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Plank vector functions</div>  </div>
<div class="ingroups"><a class="el" href="group___plank_functions.html">Plank functions</a></div></div>
<div class="contents">

<p>Vector processing functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf264cdbe70928e87484c7ef7c7e770da">pl_VectorFillF_N1</a> (PlankF *result, PlankF value, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#gaf264cdbe70928e87484c7ef7c7e770da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56913dd2881acd870e0bf0b81761f29a">pl_VectorClearF_N</a> (PlankF *result, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#ga56913dd2881acd870e0bf0b81761f29a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6083cf8cd3b19b6617c85b81dac22355">pl_VectorRampF_N11</a> (PlankF *result, PlankF a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#ga6083cf8cd3b19b6617c85b81dac22355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5af8b83ed87be0faee019340b9cc07a3">pl_VectorLineF_N11</a> (PlankF *result, PlankF a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga5af8b83ed87be0faee019340b9cc07a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6afd6f38943e06da5514a63e90c0faf9">pl_VectorMoveF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item in a vector.  <a href="#ga6afd6f38943e06da5514a63e90c0faf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab729d40e2054d2fb7181f18a608d160c">pl_VectorIncF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_IncF() to each item in a vector.  <a href="#gab729d40e2054d2fb7181f18a608d160c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga40879eea9b0e289225507473f339427e">pl_VectorDecF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_DecF() to each item in a vector.  <a href="#ga40879eea9b0e289225507473f339427e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3e8bc51e352f9e56102e8a6f8e591369">pl_VectorNegF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item in a vector.  <a href="#ga3e8bc51e352f9e56102e8a6f8e591369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0da76047e2f5935ce69ec1b4084959b7">pl_VectorAbsF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item in a vector.  <a href="#ga0da76047e2f5935ce69ec1b4084959b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga138489a0a09ca5131c997c9bf2785020">pl_VectorSquaredF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item in a vector.  <a href="#ga138489a0a09ca5131c997c9bf2785020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga14c2dd307d97ebea1a2b0a79a4f18f3f">pl_VectorCubedF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item in a vector.  <a href="#ga14c2dd307d97ebea1a2b0a79a4f18f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga017d16bd185ae3cf9069e06cc9c2cf88">pl_VectorSignF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item in a vector.  <a href="#ga017d16bd185ae3cf9069e06cc9c2cf88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3874b7ec8eb9d6daa7e57928ac093a9c">pl_VectorAddF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item in two input vectors.  <a href="#ga3874b7ec8eb9d6daa7e57928ac093a9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53fdeba08d131bafeee9e2217b79f77a">pl_VectorAddF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="#ga53fdeba08d131bafeee9e2217b79f77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c458ac80a73ae97d9836e7cdff6653">pl_VectorAddF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="#ga96c458ac80a73ae97d9836e7cdff6653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9e7dc8aa04be89440e1440b3125cdffc">pl_VectorSubF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item in two input vectors.  <a href="#ga9e7dc8aa04be89440e1440b3125cdffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8935b522deb4e2baf1885c78ef3c5a2">pl_VectorSubF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="#gad8935b522deb4e2baf1885c78ef3c5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad545716dacb61f997567075c3a4a6720">pl_VectorSubF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="#gad545716dacb61f997567075c3a4a6720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09b89f66bb8148bc4d7f3ade8f12ab6b">pl_VectorMulF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item in two input vectors.  <a href="#ga09b89f66bb8148bc4d7f3ade8f12ab6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4d02adf1b7e3387b882aee06bf794bab">pl_VectorMulF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="#ga4d02adf1b7e3387b882aee06bf794bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga044d16cfcf2eda7978a038ca4a156144">pl_VectorMulF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="#ga044d16cfcf2eda7978a038ca4a156144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae6db0d03c2bb9e5a663ac3e1d4d3d76a">pl_VectorDivF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item in two input vectors.  <a href="#gae6db0d03c2bb9e5a663ac3e1d4d3d76a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga647b8c4642bc5c02b4b4ad7fca5434eb">pl_VectorDivF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="#ga647b8c4642bc5c02b4b4ad7fca5434eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fb4b91f3c0068e6b0805195a7899c34">pl_VectorDivF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="#ga7fb4b91f3c0068e6b0805195a7899c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga579144bf7c19e2c3076ace200ffdf6c4">pl_VectorModF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to each item in two input vectors.  <a href="#ga579144bf7c19e2c3076ace200ffdf6c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad14414a6a6bfdce2cfa4b12194fac85b">pl_VectorModF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to an input vector and a scalar value.  <a href="#gad14414a6a6bfdce2cfa4b12194fac85b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga621b50c48f2e6d362bd2b43496e98dff">pl_VectorModF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to an input vector and a scalar value.  <a href="#ga621b50c48f2e6d362bd2b43496e98dff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa31eb103c9cb1b7af8ec1d68940fc816">pl_VectorMinF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item in two input vectors.  <a href="#gaa31eb103c9cb1b7af8ec1d68940fc816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa3a514ff8c829f3f0c34cc3cb8532fa9">pl_VectorMinF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="#gaa3a514ff8c829f3f0c34cc3cb8532fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8dd296051688e3035e6d0f7dff95c2ab">pl_VectorMinF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="#ga8dd296051688e3035e6d0f7dff95c2ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8ee95f778cdfcd034e902fb81f7c885">pl_VectorMaxF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item in two input vectors.  <a href="#gad8ee95f778cdfcd034e902fb81f7c885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2e548c19fcaaa84dc28e05af2b4cd88a">pl_VectorMaxF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="#ga2e548c19fcaaa84dc28e05af2b4cd88a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaabafa18c8dd0ec2c12e11b6f42cc2493">pl_VectorMaxF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="#gaabafa18c8dd0ec2c12e11b6f42cc2493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5cbc606bff150d3be2e698aac7dc5ce4">pl_VectorIsEqualToF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item in two input vectors.  <a href="#ga5cbc606bff150d3be2e698aac7dc5ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacf88f51bb6a26c2d0a68e994d863711c">pl_VectorIsEqualToF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="#gacf88f51bb6a26c2d0a68e994d863711c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedb79426fa90a29103fce022679f32f4">pl_VectorIsEqualToF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="#gaedb79426fa90a29103fce022679f32f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9a46a8c1db7476211bdd6b44fb19d49">pl_VectorIsNotEqualToF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item in two input vectors.  <a href="#gae9a46a8c1db7476211bdd6b44fb19d49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga774c6a0e634df1f397516a6a805a4d6d">pl_VectorIsNotEqualToF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="#ga774c6a0e634df1f397516a6a805a4d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56a9fe4ef33f7d81a29e7aab0a1592c0">pl_VectorIsNotEqualToF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="#ga56a9fe4ef33f7d81a29e7aab0a1592c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6030e695b7b354d7c668506b6dd8777e">pl_VectorIsGreaterThanF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item in two input vectors.  <a href="#ga6030e695b7b354d7c668506b6dd8777e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3298d662a1a1002f1a911cf89576f12e">pl_VectorIsGreaterThanF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="#ga3298d662a1a1002f1a911cf89576f12e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7ff4eb184fe6458d583af93f5f5d72a3">pl_VectorIsGreaterThanF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="#ga7ff4eb184fe6458d583af93f5f5d72a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga34dbb414e4e85a5dc21cab04efb36e17">pl_VectorIsGreaterThanOrEqualToF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item in two input vectors.  <a href="#ga34dbb414e4e85a5dc21cab04efb36e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5c70aa006400c76931250bdcccf52e37">pl_VectorIsGreaterThanOrEqualToF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga5c70aa006400c76931250bdcccf52e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9563d0b877e5656f9e68dbe1f172b1c2">pl_VectorIsGreaterThanOrEqualToF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga9563d0b877e5656f9e68dbe1f172b1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafc1473081b72235572bbcb4180f85532">pl_VectorIsLessThanF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item in two input vectors.  <a href="#gafc1473081b72235572bbcb4180f85532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gada27b912481be2974f2df10287c24cca">pl_VectorIsLessThanF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="#gada27b912481be2974f2df10287c24cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98ef2362c8ee3b97169746404863b0bb">pl_VectorIsLessThanF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="#ga98ef2362c8ee3b97169746404863b0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae336bfe2cf955934a4cee32d66b4817e">pl_VectorIsLessThanOrEqualToF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item in two input vectors.  <a href="#gae336bfe2cf955934a4cee32d66b4817e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f64176207c3d68ae22cddb34d496266">pl_VectorIsLessThanOrEqualToF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#ga5f64176207c3d68ae22cddb34d496266"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9b4e616e12b4510ed11658d46985b6d">pl_VectorIsLessThanOrEqualToF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="#gaa9b4e616e12b4510ed11658d46985b6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga52cc262cb6455a1ccb4bb7d6a3b78467">pl_VectorSumSqrF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item in two input vectors.  <a href="#ga52cc262cb6455a1ccb4bb7d6a3b78467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafaba968683dddc1cb6ee402811875181">pl_VectorSumSqrF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="#gafaba968683dddc1cb6ee402811875181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5484d71a34bd278e75b8cecf45e7263">pl_VectorSumSqrF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="#gad5484d71a34bd278e75b8cecf45e7263"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaecd22cb5b339a05a83a47ce9a5eb303d">pl_VectorDifSqrF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item in two input vectors.  <a href="#gaecd22cb5b339a05a83a47ce9a5eb303d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab11b4161a9b842caf8431aa6e578f81">pl_VectorDifSqrF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="#gaab11b4161a9b842caf8431aa6e578f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8c6f0bc2d31739420492413ade319f84">pl_VectorDifSqrF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="#ga8c6f0bc2d31739420492413ade319f84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa44f0e93a59157dc2ed7a1a320606de3">pl_VectorSqrSumF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item in two input vectors.  <a href="#gaa44f0e93a59157dc2ed7a1a320606de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0cc252e1e632dd35bbb13d318f6bf51b">pl_VectorSqrSumF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="#ga0cc252e1e632dd35bbb13d318f6bf51b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3568d95bc0f3df06126f00db48d52385">pl_VectorSqrSumF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="#ga3568d95bc0f3df06126f00db48d52385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae247f0ca7d07614d80fb70fd4f3b20ab">pl_VectorSqrDifF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item in two input vectors.  <a href="#gae247f0ca7d07614d80fb70fd4f3b20ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2229b5869509b5f0947e8927262f23b0">pl_VectorSqrDifF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="#ga2229b5869509b5f0947e8927262f23b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga381554ead66ca6856122b66b1e9bf063">pl_VectorSqrDifF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="#ga381554ead66ca6856122b66b1e9bf063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9d78883696faed1ffc7b1ed6cbb4bc8">pl_VectorAbsDifF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item in two input vectors.  <a href="#gaa9d78883696faed1ffc7b1ed6cbb4bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c8da37fdfd80aebd9d1743a0da9b497">pl_VectorAbsDifF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="#ga1c8da37fdfd80aebd9d1743a0da9b497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3a66577c30fc72bd6eff2271f9c10b16">pl_VectorAbsDifF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="#ga3a66577c30fc72bd6eff2271f9c10b16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3161963fd5d2e9453250a93f01226f5d">pl_VectorThreshF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item in two input vectors.  <a href="#ga3161963fd5d2e9453250a93f01226f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae27592fcf9a6e2511f691e2b840340a9">pl_VectorThreshF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="#gae27592fcf9a6e2511f691e2b840340a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9bc9357afdaecf35a48a2819a1673ec5">pl_VectorThreshF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="#ga9bc9357afdaecf35a48a2819a1673ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga440a2f45ad5a555ed44a4e227a132a2a">pl_VectorMulAddF_NNNN</a> (PlankF *result, const PlankF *input, const PlankF *mul, const PlankF *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga440a2f45ad5a555ed44a4e227a132a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9877065544b3718d8d187d5f50cdf24">pl_VectorMulAddF_NNN</a> (PlankF *io, const PlankF *mul, const PlankF *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gad9877065544b3718d8d187d5f50cdf24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf5c97c3f119c8f60b3ddde9eac596e38">pl_VectorMulAddF_NNN1</a> (PlankF *result, const PlankF *input, const PlankF *mul, PlankF add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gaf5c97c3f119c8f60b3ddde9eac596e38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2e5e2f38c733b4356204d138b71f5848">pl_VectorMulAddF_NN11</a> (PlankF *result, const PlankF *input, PlankF mul, PlankF add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga2e5e2f38c733b4356204d138b71f5848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga08e933eccaf66c8adb57e9841657a6fb">pl_VectorMulAddF_NN1N</a> (PlankF *result, const PlankF *input, PlankF mul, const PlankF *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga08e933eccaf66c8adb57e9841657a6fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaddee28f3d1f630066c181c8a6ac97aea">pl_VectorLookupF_NnN</a> (PlankF *result, PlankF *table, PlankUL n, PlankF *index, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gaddee28f3d1f630066c181c8a6ac97aea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167">pl_VectorLog2F_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item in a vector.  <a href="#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf552c917a97a8370eb14d70fa7fdbcd4">pl_VectorReciprocalF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item in a vector.  <a href="#gaf552c917a97a8370eb14d70fa7fdbcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8317e0ece295c3fe4c6ddcd0c9291b73">pl_VectorSinF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item in a vector.  <a href="#ga8317e0ece295c3fe4c6ddcd0c9291b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dc9e1a1005c50962f50b218bdd359f7">pl_VectorCosF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item in a vector.  <a href="#ga2dc9e1a1005c50962f50b218bdd359f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ff3f0a747f340ef59eb12ff9f5fa9ce">pl_VectorTanF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item in a vector.  <a href="#ga0ff3f0a747f340ef59eb12ff9f5fa9ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga40b4fd224d5c1df552bd36fd79e14d46">pl_VectorAsinF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item in a vector.  <a href="#ga40b4fd224d5c1df552bd36fd79e14d46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b0876ed78d4675a40aec91015020543">pl_VectorAcosF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item in a vector.  <a href="#ga4b0876ed78d4675a40aec91015020543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c392fc9382aa520c8d73f30ce097361">pl_VectorAtanF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item in a vector.  <a href="#ga1c392fc9382aa520c8d73f30ce097361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1d025408ed6a1435023aa7837cbbce26">pl_VectorSinhF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item in a vector.  <a href="#ga1d025408ed6a1435023aa7837cbbce26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae7fca130c7b57d8f99ba52546a3d401f">pl_VectorCoshF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item in a vector.  <a href="#gae7fca130c7b57d8f99ba52546a3d401f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac8184fcb4e00b71d0e152a6cd441e611">pl_VectorTanhF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item in a vector.  <a href="#gac8184fcb4e00b71d0e152a6cd441e611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac5eb6a022dcc12e47bb871209d94fa5b">pl_VectorSqrtF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item in a vector.  <a href="#gac5eb6a022dcc12e47bb871209d94fa5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6154ea39d75e68b9e9d5330cb3625eec">pl_VectorLogF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item in a vector.  <a href="#ga6154ea39d75e68b9e9d5330cb3625eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5680198a0c9c769ad052a505769d8e65">pl_VectorLog10F_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item in a vector.  <a href="#ga5680198a0c9c769ad052a505769d8e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2832cd0f9496ce0c593be00454cc1d56">pl_VectorExpF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item in a vector.  <a href="#ga2832cd0f9496ce0c593be00454cc1d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga624ee54e6e8bab7bd8f81997c07b7242">pl_VectorCeilF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item in a vector.  <a href="#ga624ee54e6e8bab7bd8f81997c07b7242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53d443eaba00cc8255d4d1dd7dc3de79">pl_VectorFloorF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item in a vector.  <a href="#ga53d443eaba00cc8255d4d1dd7dc3de79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga772400768495fd4fd693256ad3c48f33">pl_VectorFracF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item in a vector.  <a href="#ga772400768495fd4fd693256ad3c48f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga434579ecb8b69a86b3c1b5e19640d3e9">pl_VectorM2FF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item in a vector.  <a href="#ga434579ecb8b69a86b3c1b5e19640d3e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346ccfb5366b8795fb98c20817553baf">pl_VectorF2MF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item in a vector.  <a href="#ga346ccfb5366b8795fb98c20817553baf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6d6a453af826e1347bbe6801068431e4">pl_VectorA2dBF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item in a vector.  <a href="#ga6d6a453af826e1347bbe6801068431e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf55e4f2965d3427a503f26e3e3d22a40">pl_VectordB2AF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item in a vector.  <a href="#gaf55e4f2965d3427a503f26e3e3d22a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac4ffbe59182ba1514ccd8969ed780394">pl_VectorD2RF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item in a vector.  <a href="#gac4ffbe59182ba1514ccd8969ed780394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdc0d266ab2c818ebf03503c1f1d0044">pl_VectorR2DF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item in a vector.  <a href="#gafdc0d266ab2c818ebf03503c1f1d0044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab1abd9fad50bb7512458ef32c19399f3">pl_VectorDistortF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item in a vector.  <a href="#gab1abd9fad50bb7512458ef32c19399f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6bd51dca6361c74850caf92244eefbf4">pl_VectorZapF_NN</a> (PlankF *result, const PlankF *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item in a vector.  <a href="#ga6bd51dca6361c74850caf92244eefbf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadf3b8ea80497eeec187a20e7e2848ed7">pl_VectorPowF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item in two input vectors.  <a href="#gadf3b8ea80497eeec187a20e7e2848ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga483ff2d8bea2cdeec487db5efffa3d3a">pl_VectorPowF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="#ga483ff2d8bea2cdeec487db5efffa3d3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c1025337d92429c8734e175143f1f7">pl_VectorPowF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="#ga96c1025337d92429c8734e175143f1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabff48d9f05d09c6fc3024f2095a91630">pl_VectorHypotF_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item in two input vectors.  <a href="#gabff48d9f05d09c6fc3024f2095a91630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga939e06569593c806d533ea61e4b98327">pl_VectorHypotF_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="#ga939e06569593c806d533ea61e4b98327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf0893c32e31d72a7e91badc4abf62b3b">pl_VectorHypotF_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="#gaf0893c32e31d72a7e91badc4abf62b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga44812f3688888b573be8c9db069b936a">pl_VectorAtan2F_NNN</a> (PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item in two input vectors.  <a href="#ga44812f3688888b573be8c9db069b936a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaece9a054e73c28bd180580b0cd016018">pl_VectorAtan2F_NN1</a> (PlankF *result, const PlankF *a, PlankF b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="#gaece9a054e73c28bd180580b0cd016018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1570febbc25f8b9a3ef7ac8cc7af07ae">pl_VectorAtan2F_N1N</a> (PlankF *result, PlankF a, const PlankF *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="#ga1570febbc25f8b9a3ef7ac8cc7af07ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3d51b6cf9010ce1fa63b9762249261a0">pl_VectorFillD_N1</a> (PlankD *result, PlankD value, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#ga3d51b6cf9010ce1fa63b9762249261a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa347eccfa116a68b56f8f5eee79e5707">pl_VectorClearD_N</a> (PlankD *result, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#gaa347eccfa116a68b56f8f5eee79e5707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac60fec7cc8a88e48270833135205ec12">pl_VectorRampD_N11</a> (PlankD *result, PlankD a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#gac60fec7cc8a88e48270833135205ec12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga81e869fd2297a6c57b5e3a312fc33b74">pl_VectorLineD_N11</a> (PlankD *result, PlankD a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga81e869fd2297a6c57b5e3a312fc33b74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga92916e1daf6e82d9404d525e42389b45">pl_VectorMoveD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item in a vector.  <a href="#ga92916e1daf6e82d9404d525e42389b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1670474c385d41d06a26038f799c0fa">pl_VectorIncD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_IncD() to each item in a vector.  <a href="#gae1670474c385d41d06a26038f799c0fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga90167dde80a4ec5921626be554be8f1b">pl_VectorDecD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_DecD() to each item in a vector.  <a href="#ga90167dde80a4ec5921626be554be8f1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad49e011e4ca3f76de0b8ec5c1d6d81e6">pl_VectorNegD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item in a vector.  <a href="#gad49e011e4ca3f76de0b8ec5c1d6d81e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaec21dab0c087e0b170745b2e3efd207b">pl_VectorAbsD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item in a vector.  <a href="#gaec21dab0c087e0b170745b2e3efd207b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac6d6857d70c11dac6815925aa5fbe258">pl_VectorSquaredD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item in a vector.  <a href="#gac6d6857d70c11dac6815925aa5fbe258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac92318b9550618c0eb61f5c6db28b6f0">pl_VectorCubedD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item in a vector.  <a href="#gac92318b9550618c0eb61f5c6db28b6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga35254ed489bf9f5825bac6d353d80eac">pl_VectorSignD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item in a vector.  <a href="#ga35254ed489bf9f5825bac6d353d80eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga12ef092e0c8e669d7762e69d0559e3a2">pl_VectorAddD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item in two input vectors.  <a href="#ga12ef092e0c8e669d7762e69d0559e3a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae41675932ccb373a167cd2c83e3df768">pl_VectorAddD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="#gae41675932ccb373a167cd2c83e3df768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5a1316615dc2031b02b71424f44d657f">pl_VectorAddD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="#ga5a1316615dc2031b02b71424f44d657f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa1ad270a88e18f6e9c8a51c450c3e41f">pl_VectorSubD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item in two input vectors.  <a href="#gaa1ad270a88e18f6e9c8a51c450c3e41f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a28dc464696905e52db911b3f97566e">pl_VectorSubD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="#ga1a28dc464696905e52db911b3f97566e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab8ea462ef620ebc5dd512f0df2224508">pl_VectorSubD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="#gab8ea462ef620ebc5dd512f0df2224508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga49295bf725772df3865b0fe99be4552e">pl_VectorMulD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item in two input vectors.  <a href="#ga49295bf725772df3865b0fe99be4552e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1bc824231e441539c1ee7df8b50e0391">pl_VectorMulD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="#ga1bc824231e441539c1ee7df8b50e0391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf5e80360d5aae32ecddfba037c215af8">pl_VectorMulD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="#gaf5e80360d5aae32ecddfba037c215af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1fa89f9180cd6811ec7a0eb94605b996">pl_VectorDivD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item in two input vectors.  <a href="#ga1fa89f9180cd6811ec7a0eb94605b996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa19c40021b63a0d14db1eddd9d0a037e">pl_VectorDivD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="#gaa19c40021b63a0d14db1eddd9d0a037e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a">pl_VectorDivD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gace2aecd293f599cf3e56551bf714bf9d">pl_VectorModD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to each item in two input vectors.  <a href="#gace2aecd293f599cf3e56551bf714bf9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad14a5010bd1ffa6a68aafee2545b5c79">pl_VectorModD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to an input vector and a scalar value.  <a href="#gad14a5010bd1ffa6a68aafee2545b5c79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga63b81cfbb45a3881e871ef96d37628a4">pl_VectorModD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to an input vector and a scalar value.  <a href="#ga63b81cfbb45a3881e871ef96d37628a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3267ac92b409d85e0f1195214d19bcf1">pl_VectorMinD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item in two input vectors.  <a href="#ga3267ac92b409d85e0f1195214d19bcf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga750a9c78d6f4857c73ab1ee9cdbd65ad">pl_VectorMinD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="#ga750a9c78d6f4857c73ab1ee9cdbd65ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09f665f6b1bddb3bd7669410e10b3c02">pl_VectorMinD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="#ga09f665f6b1bddb3bd7669410e10b3c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab73fa94aad3f3a9ea9b4281fa2a45637">pl_VectorMaxD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item in two input vectors.  <a href="#gab73fa94aad3f3a9ea9b4281fa2a45637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdcc887ab924c442c0496cd98cb8bf08">pl_VectorMaxD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="#gafdcc887ab924c442c0496cd98cb8bf08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad687be0c0ca10457b0d9ea29d3e737c2">pl_VectorMaxD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="#gad687be0c0ca10457b0d9ea29d3e737c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa6557cbdeb7309d19bb44c69a8b68ac5">pl_VectorIsEqualToD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item in two input vectors.  <a href="#gaa6557cbdeb7309d19bb44c69a8b68ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6b41819ebe1d49fbf7fcea593eea1585">pl_VectorIsEqualToD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="#ga6b41819ebe1d49fbf7fcea593eea1585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaced300febadf01a9bb061b2eb55b4c82">pl_VectorIsEqualToD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="#gaced300febadf01a9bb061b2eb55b4c82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4fb086ed252f0f5f8504088cf286ed35">pl_VectorIsNotEqualToD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item in two input vectors.  <a href="#ga4fb086ed252f0f5f8504088cf286ed35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga427f715543dfb78fa061b1da9ae2f34c">pl_VectorIsNotEqualToD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="#ga427f715543dfb78fa061b1da9ae2f34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacc43628c757ac7fbf663ecf1d09aa5a7">pl_VectorIsNotEqualToD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="#gacc43628c757ac7fbf663ecf1d09aa5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga742971fee5ae052c2cb95a9955cf7542">pl_VectorIsGreaterThanD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item in two input vectors.  <a href="#ga742971fee5ae052c2cb95a9955cf7542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5fb9c4d06a6d72de5ce40804ff346460">pl_VectorIsGreaterThanD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="#ga5fb9c4d06a6d72de5ce40804ff346460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75e868cbab5a492e1daebf106fe89d64">pl_VectorIsGreaterThanD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="#ga75e868cbab5a492e1daebf106fe89d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5db5ae33ecc38702db1987d7f58003d">pl_VectorIsGreaterThanOrEqualToD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item in two input vectors.  <a href="#gad5db5ae33ecc38702db1987d7f58003d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09d06ce6f60c7093743530f7340d0db3">pl_VectorIsGreaterThanOrEqualToD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#ga09d06ce6f60c7093743530f7340d0db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf1b670f32504cfee3765b6f7aec16a60">pl_VectorIsGreaterThanOrEqualToD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#gaf1b670f32504cfee3765b6f7aec16a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga991f8dd0bbc5c9dfca56eb70e2139dfe">pl_VectorIsLessThanD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item in two input vectors.  <a href="#ga991f8dd0bbc5c9dfca56eb70e2139dfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7eb97b849367dd8a0b92c4e4cdffe983">pl_VectorIsLessThanD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="#ga7eb97b849367dd8a0b92c4e4cdffe983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3f91ec7596d951ef68b47e277ef6c5ba">pl_VectorIsLessThanD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="#ga3f91ec7596d951ef68b47e277ef6c5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75601e89fa96c2711c9c1d762bd26633">pl_VectorIsLessThanOrEqualToD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item in two input vectors.  <a href="#ga75601e89fa96c2711c9c1d762bd26633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae14f26d0d6c23b301370264f5d2f5820">pl_VectorIsLessThanOrEqualToD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#gae14f26d0d6c23b301370264f5d2f5820"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga883e9677cffce2e7a385c048c0cf6051">pl_VectorIsLessThanOrEqualToD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="#ga883e9677cffce2e7a385c048c0cf6051"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4bb7bd02652c307ae3f496df0354e8a3">pl_VectorSumSqrD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item in two input vectors.  <a href="#ga4bb7bd02652c307ae3f496df0354e8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga79278b4c9dbf253e5179556919e9b35b">pl_VectorSumSqrD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="#ga79278b4c9dbf253e5179556919e9b35b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadc42b9865fb1e2b4f33ec9da262b2092">pl_VectorSumSqrD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="#gadc42b9865fb1e2b4f33ec9da262b2092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaac8f1f8d6c6d929b667f15dbe053831c">pl_VectorDifSqrD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item in two input vectors.  <a href="#gaac8f1f8d6c6d929b667f15dbe053831c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga46775562a5d0bbd8d670bd7e95284783">pl_VectorDifSqrD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="#ga46775562a5d0bbd8d670bd7e95284783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9d40bd884f8f805edebd3c59ca883a38">pl_VectorDifSqrD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="#ga9d40bd884f8f805edebd3c59ca883a38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga788004c04a717f469b0f1998d4f62067">pl_VectorSqrSumD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item in two input vectors.  <a href="#ga788004c04a717f469b0f1998d4f62067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac9a2a0223d3af7c542c0fa570ce00a17">pl_VectorSqrSumD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="#gac9a2a0223d3af7c542c0fa570ce00a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f56150d804d6952997e90fb803958e4">pl_VectorSqrSumD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="#ga5f56150d804d6952997e90fb803958e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4e737d98b7ad71c71432248a39c2ce16">pl_VectorSqrDifD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item in two input vectors.  <a href="#ga4e737d98b7ad71c71432248a39c2ce16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f6940ac9a86f57efe4bce7400d9234b">pl_VectorSqrDifD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="#ga6f6940ac9a86f57efe4bce7400d9234b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2001054b1fcbeee5191c265bcbaeea2c">pl_VectorSqrDifD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="#ga2001054b1fcbeee5191c265bcbaeea2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5778badb734f9dc6fab15eadd6e31bc7">pl_VectorAbsDifD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item in two input vectors.  <a href="#ga5778badb734f9dc6fab15eadd6e31bc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7625f658d95e5bfaa275bcb24560575">pl_VectorAbsDifD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="#gaf7625f658d95e5bfaa275bcb24560575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fcc23c11a1a0ef8790d60c4be0ce4fd">pl_VectorAbsDifD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="#ga7fcc23c11a1a0ef8790d60c4be0ce4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga57d7f27f996ba4e74be09197791e404d">pl_VectorThreshD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item in two input vectors.  <a href="#ga57d7f27f996ba4e74be09197791e404d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga87f14ff8770a1f823a4157bc40e1e5d6">pl_VectorThreshD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="#ga87f14ff8770a1f823a4157bc40e1e5d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ddd02df030d53aa2e7ef50e24d6aa84">pl_VectorThreshD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="#ga0ddd02df030d53aa2e7ef50e24d6aa84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga14330dd55c25b72733f3ca804e440593">pl_VectorMulAddD_NNNN</a> (PlankD *result, const PlankD *input, const PlankD *mul, const PlankD *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga14330dd55c25b72733f3ca804e440593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4f1ffab901ada34b727346e72b700627">pl_VectorMulAddD_NNN</a> (PlankD *io, const PlankD *mul, const PlankD *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga4f1ffab901ada34b727346e72b700627"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac7ad2ae5fd9ec33bf7bbb4f1efaa4f5a">pl_VectorMulAddD_NNN1</a> (PlankD *result, const PlankD *input, const PlankD *mul, PlankD add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gac7ad2ae5fd9ec33bf7bbb4f1efaa4f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2c953ed08f1a81c89806bdd6f8cf36c3">pl_VectorMulAddD_NN11</a> (PlankD *result, const PlankD *input, PlankD mul, PlankD add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga2c953ed08f1a81c89806bdd6f8cf36c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab19f04fdfabafac14d7d57c621efa008">pl_VectorMulAddD_NN1N</a> (PlankD *result, const PlankD *input, PlankD mul, const PlankD *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gab19f04fdfabafac14d7d57c621efa008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadaaf12325ee661c80ccc2c3a227ddf5d">pl_VectorLookupD_NnN</a> (PlankD *result, PlankD *table, PlankUL n, PlankD *index, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gadaaf12325ee661c80ccc2c3a227ddf5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2f77253685ccd08349ad129a0bc09a23">pl_VectorLog2D_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item in a vector.  <a href="#ga2f77253685ccd08349ad129a0bc09a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga88f1c17c13d19ff647a659e21164ec91">pl_VectorReciprocalD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item in a vector.  <a href="#ga88f1c17c13d19ff647a659e21164ec91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab78a731a99877c501f2531b263ed0ff7">pl_VectorSinD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item in a vector.  <a href="#gab78a731a99877c501f2531b263ed0ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5eb1030590f71b5165e3f72b6bd656e5">pl_VectorCosD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item in a vector.  <a href="#ga5eb1030590f71b5165e3f72b6bd656e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga135af6226d8b96e81abaaba6f9cd0b06">pl_VectorTanD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item in a vector.  <a href="#ga135af6226d8b96e81abaaba6f9cd0b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedae3e19d90c4a4cb5212edadcd76f76">pl_VectorAsinD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item in a vector.  <a href="#gaedae3e19d90c4a4cb5212edadcd76f76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacac99df0db7dad5461861849601a0dc8">pl_VectorAcosD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item in a vector.  <a href="#gacac99df0db7dad5461861849601a0dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dcc5850da8f410f63fb5c929a0f7e76">pl_VectorAtanD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item in a vector.  <a href="#ga2dcc5850da8f410f63fb5c929a0f7e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaebafcf0bf05dade5b95bf6066808f623">pl_VectorSinhD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item in a vector.  <a href="#gaebafcf0bf05dade5b95bf6066808f623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5853e6b3aff90d56b2d433da806d858f">pl_VectorCoshD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item in a vector.  <a href="#ga5853e6b3aff90d56b2d433da806d858f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga250f2e61d743622a1609f85839f9c4bb">pl_VectorTanhD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item in a vector.  <a href="#ga250f2e61d743622a1609f85839f9c4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga540c096f6e4382440007c878047f4f5d">pl_VectorSqrtD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item in a vector.  <a href="#ga540c096f6e4382440007c878047f4f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b06f007387aeffb3ebd2214f5090fb8">pl_VectorLogD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item in a vector.  <a href="#ga3b06f007387aeffb3ebd2214f5090fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a5902d66076b7527b8ca6a674fef22e">pl_VectorLog10D_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item in a vector.  <a href="#ga1a5902d66076b7527b8ca6a674fef22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346a791b777f3fb3ce4a8b5ab8dd0133">pl_VectorExpD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item in a vector.  <a href="#ga346a791b777f3fb3ce4a8b5ab8dd0133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga50da194cf31d82e931c3d2b3509934b3">pl_VectorCeilD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item in a vector.  <a href="#ga50da194cf31d82e931c3d2b3509934b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0fabcca5e7164c365cecccf20a2ad394">pl_VectorFloorD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item in a vector.  <a href="#ga0fabcca5e7164c365cecccf20a2ad394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaeb35318b9e872a8d4d86d9c795d368b2">pl_VectorFracD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item in a vector.  <a href="#gaeb35318b9e872a8d4d86d9c795d368b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga08b1418b75b12da60a96a514008a3e2d">pl_VectorM2FD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item in a vector.  <a href="#ga08b1418b75b12da60a96a514008a3e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga781a129439e1bb1dd0295a99085f3a84">pl_VectorF2MD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item in a vector.  <a href="#ga781a129439e1bb1dd0295a99085f3a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae0e337b7b89735618a1855ea91660bd9">pl_VectorA2dBD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item in a vector.  <a href="#gae0e337b7b89735618a1855ea91660bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7bb9f2cc273aaefa164d83f970e30380">pl_VectordB2AD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item in a vector.  <a href="#ga7bb9f2cc273aaefa164d83f970e30380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaba41fd68b23cb9bdd1cefb6c4b71c7a4">pl_VectorD2RD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item in a vector.  <a href="#gaba41fd68b23cb9bdd1cefb6c4b71c7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa22058ab0b84dd204cd0818f7eee4e71">pl_VectorR2DD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item in a vector.  <a href="#gaa22058ab0b84dd204cd0818f7eee4e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1c81935d93b40e48a4986fc20c9e34b">pl_VectorDistortD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item in a vector.  <a href="#gae1c81935d93b40e48a4986fc20c9e34b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabfeb5cce886741713f4db15d8e45530a">pl_VectorZapD_NN</a> (PlankD *result, const PlankD *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item in a vector.  <a href="#gabfeb5cce886741713f4db15d8e45530a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3373906398e94de141273acb0d6390c9">pl_VectorPowD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item in two input vectors.  <a href="#ga3373906398e94de141273acb0d6390c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b253f22b62b7117f6af0c31abfd6c07">pl_VectorPowD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="#ga4b253f22b62b7117f6af0c31abfd6c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9296c3251eb6571e43019400f83c765c">pl_VectorPowD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="#ga9296c3251eb6571e43019400f83c765c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga400b8712d0ef2f7222022e3030ab65d5">pl_VectorHypotD_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item in two input vectors.  <a href="#ga400b8712d0ef2f7222022e3030ab65d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadefa93b1fb00f994acaf717eb876f05b">pl_VectorHypotD_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="#gadefa93b1fb00f994acaf717eb876f05b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4beba0c36335d94c6c76b9a16aaee33f">pl_VectorHypotD_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="#ga4beba0c36335d94c6c76b9a16aaee33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga89afb2f55dfc5f5a749799d78aa27693">pl_VectorAtan2D_NNN</a> (PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item in two input vectors.  <a href="#ga89afb2f55dfc5f5a749799d78aa27693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9ae9c8c64cfe988951cbc4b51b81abf">pl_VectorAtan2D_NN1</a> (PlankD *result, const PlankD *a, PlankD b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="#gae9ae9c8c64cfe988951cbc4b51b81abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadac799a76f6ffc595d2b0771279a48a4">pl_VectorAtan2D_N1N</a> (PlankD *result, PlankD a, const PlankD *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="#gadac799a76f6ffc595d2b0771279a48a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6204b4bc6e4f4ff542b53f15c2c7a4a1">pl_VectorFillS_N1</a> (PlankS *result, PlankS value, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#ga6204b4bc6e4f4ff542b53f15c2c7a4a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf9ff12ccf9b8b66551abb12e0d11ec4f">pl_VectorClearS_N</a> (PlankS *result, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#gaf9ff12ccf9b8b66551abb12e0d11ec4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6d653556d9a1ce44e17e7551dd2e5343">pl_VectorRampS_N11</a> (PlankS *result, PlankS a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#ga6d653556d9a1ce44e17e7551dd2e5343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5566bc4aebe7465359cac138ea6f45fd">pl_VectorLineS_N11</a> (PlankS *result, PlankS a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga5566bc4aebe7465359cac138ea6f45fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga00116a2ca2d53876d5c515da4c8c49df">pl_VectorMoveS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_MoveS() to each item in a vector.  <a href="#ga00116a2ca2d53876d5c515da4c8c49df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga743930b4ab02ddcecf4cf1bec9520203">pl_VectorIncS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_IncS() to each item in a vector.  <a href="#ga743930b4ab02ddcecf4cf1bec9520203"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaad38ea1bbf04597e2424451d97188304">pl_VectorDecS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_DecS() to each item in a vector.  <a href="#gaad38ea1bbf04597e2424451d97188304"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac062955a30c1d9c9b76cab1a485b8864">pl_VectorNegS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_NegS() to each item in a vector.  <a href="#gac062955a30c1d9c9b76cab1a485b8864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1e52d14bc1a34c68a948d47df95ec84">pl_VectorAbsS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_AbsS() to each item in a vector.  <a href="#gae1e52d14bc1a34c68a948d47df95ec84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaaad088f3ce9e39ee003b9f8cb4c9ebfb">pl_VectorSquaredS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SquaredS() to each item in a vector.  <a href="#gaaad088f3ce9e39ee003b9f8cb4c9ebfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadc74c7a764866191b0fae31c1451b73f">pl_VectorCubedS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_CubedS() to each item in a vector.  <a href="#gadc74c7a764866191b0fae31c1451b73f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6d7b93f02c29d5ff9792082a646d4736">pl_VectorSignS_NN</a> (PlankS *result, const PlankS *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SignS() to each item in a vector.  <a href="#ga6d7b93f02c29d5ff9792082a646d4736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9786be679f3fd5e9129d92d5e642975">pl_VectorAddS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddS() to each item in two input vectors.  <a href="#gad9786be679f3fd5e9129d92d5e642975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5e3237fd95808bb48b6b79213a34df0e">pl_VectorAddS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddS() to an input vector and a scalar value.  <a href="#ga5e3237fd95808bb48b6b79213a34df0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae42fe911bc599a2df82ffda402470e31">pl_VectorAddS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddS() to an input vector and a scalar value.  <a href="#gae42fe911bc599a2df82ffda402470e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09a15a25c8664cc5fe93d6ba1612389c">pl_VectorSubS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubS() to each item in two input vectors.  <a href="#ga09a15a25c8664cc5fe93d6ba1612389c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga443a68819fc7dd7ed74607f9ed917017">pl_VectorSubS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubS() to an input vector and a scalar value.  <a href="#ga443a68819fc7dd7ed74607f9ed917017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5b5b085ec5b3116b23929d6665a18575">pl_VectorSubS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubS() to an input vector and a scalar value.  <a href="#ga5b5b085ec5b3116b23929d6665a18575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab8fbe29a984ac0c0f14cbc2754fff47">pl_VectorMulS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulS() to each item in two input vectors.  <a href="#gaab8fbe29a984ac0c0f14cbc2754fff47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga824042c1cfc121c193b50054bc07bd41">pl_VectorMulS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulS() to an input vector and a scalar value.  <a href="#ga824042c1cfc121c193b50054bc07bd41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga47cbc0ea3f7025b6db2363260b65c376">pl_VectorMulS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulS() to an input vector and a scalar value.  <a href="#ga47cbc0ea3f7025b6db2363260b65c376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8a8fa16ce64c707eda512adf98ba156">pl_VectorDivS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivS() to each item in two input vectors.  <a href="#gad8a8fa16ce64c707eda512adf98ba156"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae79755efdeaabd5524c1bd211e7241b1">pl_VectorDivS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivS() to an input vector and a scalar value.  <a href="#gae79755efdeaabd5524c1bd211e7241b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga55ac938ce09bf8512bc76261ccd29948">pl_VectorDivS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivS() to an input vector and a scalar value.  <a href="#ga55ac938ce09bf8512bc76261ccd29948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae0f002b56f72128ed5b3c712261aa021">pl_VectorModS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModS() to each item in two input vectors.  <a href="#gae0f002b56f72128ed5b3c712261aa021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga68a73151d459bd844bab8b31f2d51d2d">pl_VectorModS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModS() to an input vector and a scalar value.  <a href="#ga68a73151d459bd844bab8b31f2d51d2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8ffa4533c17c0e627d0ebbea66cff597">pl_VectorModS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModS() to an input vector and a scalar value.  <a href="#ga8ffa4533c17c0e627d0ebbea66cff597"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5010e97ebb5584f80f165df0f311b46e">pl_VectorMinS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinS() to each item in two input vectors.  <a href="#ga5010e97ebb5584f80f165df0f311b46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaae33e469642fc0e60fdcb517c8fae142">pl_VectorMinS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinS() to an input vector and a scalar value.  <a href="#gaae33e469642fc0e60fdcb517c8fae142"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3a38e5ae72a77b438a13eb442fe1ee5e">pl_VectorMinS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinS() to an input vector and a scalar value.  <a href="#ga3a38e5ae72a77b438a13eb442fe1ee5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad339bb52af31adb0689e19a6c8723cd1">pl_VectorMaxS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxS() to each item in two input vectors.  <a href="#gad339bb52af31adb0689e19a6c8723cd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga77e7886046cd4656a0cceb8def0d7787">pl_VectorMaxS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxS() to an input vector and a scalar value.  <a href="#ga77e7886046cd4656a0cceb8def0d7787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga66cd65b6f9e5f70ddecfc7b3eb40f9b0">pl_VectorMaxS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxS() to an input vector and a scalar value.  <a href="#ga66cd65b6f9e5f70ddecfc7b3eb40f9b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5bc51f492d94941c6f1c4313e06c8da1">pl_VectorIsEqualToS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToS() to each item in two input vectors.  <a href="#ga5bc51f492d94941c6f1c4313e06c8da1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8d7f3f26ced00fc20e47e849a3eca607">pl_VectorIsEqualToS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToS() to an input vector and a scalar value.  <a href="#ga8d7f3f26ced00fc20e47e849a3eca607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga877613416df450a45f2c48382b21d750">pl_VectorIsEqualToS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToS() to an input vector and a scalar value.  <a href="#ga877613416df450a45f2c48382b21d750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7e074461824fde3c932fd4ad588937ea">pl_VectorIsNotEqualToS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToS() to each item in two input vectors.  <a href="#ga7e074461824fde3c932fd4ad588937ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac5d7d59b906081c8205d652cf750ade5">pl_VectorIsNotEqualToS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToS() to an input vector and a scalar value.  <a href="#gac5d7d59b906081c8205d652cf750ade5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga65c91b478f8ed90e1eb256c3788e9f0b">pl_VectorIsNotEqualToS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToS() to an input vector and a scalar value.  <a href="#ga65c91b478f8ed90e1eb256c3788e9f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3c1571089e66fad788ede26e8a9a0f97">pl_VectorIsGreaterThanS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanS() to each item in two input vectors.  <a href="#ga3c1571089e66fad788ede26e8a9a0f97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga73dc7a3aa83c3cfb095761e96faf5ee6">pl_VectorIsGreaterThanS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanS() to an input vector and a scalar value.  <a href="#ga73dc7a3aa83c3cfb095761e96faf5ee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae638bb12613f562a45c12c41f9e5db50">pl_VectorIsGreaterThanS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanS() to an input vector and a scalar value.  <a href="#gae638bb12613f562a45c12c41f9e5db50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga170f7ff35e5f45c26e6064d642b31e1a">pl_VectorIsGreaterThanOrEqualToS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToS() to each item in two input vectors.  <a href="#ga170f7ff35e5f45c26e6064d642b31e1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga130276378ce6235bac6832232c4918f4">pl_VectorIsGreaterThanOrEqualToS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToS() to an input vector and a scalar value.  <a href="#ga130276378ce6235bac6832232c4918f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa4939f89237d6a48266fca0ed0530fbc">pl_VectorIsGreaterThanOrEqualToS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToS() to an input vector and a scalar value.  <a href="#gaa4939f89237d6a48266fca0ed0530fbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga86295dbb41c9f8706227160afff8e18a">pl_VectorIsLessThanS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanS() to each item in two input vectors.  <a href="#ga86295dbb41c9f8706227160afff8e18a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga73770af53fc9f3f36072b79a1e1c2092">pl_VectorIsLessThanS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanS() to an input vector and a scalar value.  <a href="#ga73770af53fc9f3f36072b79a1e1c2092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga02226c77b2e38a7b604ab35088fe44fc">pl_VectorIsLessThanS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanS() to an input vector and a scalar value.  <a href="#ga02226c77b2e38a7b604ab35088fe44fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab46c18d16475d7e770109d15a5ac839a">pl_VectorIsLessThanOrEqualToS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToS() to each item in two input vectors.  <a href="#gab46c18d16475d7e770109d15a5ac839a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga335af27f1920b47ca0ff18aff400f6fa">pl_VectorIsLessThanOrEqualToS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToS() to an input vector and a scalar value.  <a href="#ga335af27f1920b47ca0ff18aff400f6fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga129554dbe9192e52946f0c3392100848">pl_VectorIsLessThanOrEqualToS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToS() to an input vector and a scalar value.  <a href="#ga129554dbe9192e52946f0c3392100848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga664b0d780f7c80c58456c23a4b4e929b">pl_VectorSumSqrS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrS() to each item in two input vectors.  <a href="#ga664b0d780f7c80c58456c23a4b4e929b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac2ba59d155faebe6b804d6ec19f2edc7">pl_VectorSumSqrS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrS() to an input vector and a scalar value.  <a href="#gac2ba59d155faebe6b804d6ec19f2edc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga36b8ccb91a525c498337910ed46f4209">pl_VectorSumSqrS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrS() to an input vector and a scalar value.  <a href="#ga36b8ccb91a525c498337910ed46f4209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga975403756ec11f5d943cbe8fe36cf3c6">pl_VectorDifSqrS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrS() to each item in two input vectors.  <a href="#ga975403756ec11f5d943cbe8fe36cf3c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7f331c1c85310658727ca0b11ae4dc1">pl_VectorDifSqrS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrS() to an input vector and a scalar value.  <a href="#gaf7f331c1c85310658727ca0b11ae4dc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae3a4e19ec8abb3bac0e5bb6c887bb646">pl_VectorDifSqrS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrS() to an input vector and a scalar value.  <a href="#gae3a4e19ec8abb3bac0e5bb6c887bb646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga57aa99ce2436f21da79903a4a07dc436">pl_VectorSqrSumS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumS() to each item in two input vectors.  <a href="#ga57aa99ce2436f21da79903a4a07dc436"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga399c7211375ae3834467f251dd5ab488">pl_VectorSqrSumS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumS() to an input vector and a scalar value.  <a href="#ga399c7211375ae3834467f251dd5ab488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0103ff955e2e6c710ca4ad2a250b51ea">pl_VectorSqrSumS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumS() to an input vector and a scalar value.  <a href="#ga0103ff955e2e6c710ca4ad2a250b51ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga747d3bc07b7274114b8c4af9847902d3">pl_VectorSqrDifS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifS() to each item in two input vectors.  <a href="#ga747d3bc07b7274114b8c4af9847902d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9115d3493fece5836583e6c55f91e5f">pl_VectorSqrDifS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifS() to an input vector and a scalar value.  <a href="#gad9115d3493fece5836583e6c55f91e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8525e02a522821beb9cf0aeb472165f3">pl_VectorSqrDifS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifS() to an input vector and a scalar value.  <a href="#ga8525e02a522821beb9cf0aeb472165f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaaabdf55cdbfd0d85aafa52d763b91d91">pl_VectorAbsDifS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifS() to each item in two input vectors.  <a href="#gaaabdf55cdbfd0d85aafa52d763b91d91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga422881deeb36ac85eadaaabeedbf2f4e">pl_VectorAbsDifS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifS() to an input vector and a scalar value.  <a href="#ga422881deeb36ac85eadaaabeedbf2f4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga66b6ca82f4090130fcba7c21dc44730b">pl_VectorAbsDifS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifS() to an input vector and a scalar value.  <a href="#ga66b6ca82f4090130fcba7c21dc44730b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dc4f59cfde13de3c2e3e871e5d0517d">pl_VectorThreshS_NNN</a> (PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshS() to each item in two input vectors.  <a href="#ga2dc4f59cfde13de3c2e3e871e5d0517d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabfe493153f9a7e7d04af461a18368010">pl_VectorThreshS_NN1</a> (PlankS *result, const PlankS *a, PlankS b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshS() to an input vector and a scalar value.  <a href="#gabfe493153f9a7e7d04af461a18368010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad54338b76e8465146cbf3269d8a405d3">pl_VectorThreshS_N1N</a> (PlankS *result, PlankS a, const PlankS *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshS() to an input vector and a scalar value.  <a href="#gad54338b76e8465146cbf3269d8a405d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab60a1ee99ca08001622da70ed098ee1c">pl_VectorMulAddS_NNNN</a> (PlankS *result, const PlankS *input, const PlankS *mul, const PlankS *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gab60a1ee99ca08001622da70ed098ee1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad7642e45155d214535356262de614a08">pl_VectorMulAddS_NNN</a> (PlankS *io, const PlankS *mul, const PlankS *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gad7642e45155d214535356262de614a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0dcb95b6f83778b7159a7896105144a1">pl_VectorMulAddS_NNN1</a> (PlankS *result, const PlankS *input, const PlankS *mul, PlankS add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga0dcb95b6f83778b7159a7896105144a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga15fe29c7893af841caa7a26db4f88f14">pl_VectorMulAddS_NN11</a> (PlankS *result, const PlankS *input, PlankS mul, PlankS add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga15fe29c7893af841caa7a26db4f88f14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacfef4b4020df252bed7ab3b0c2e7eda9">pl_VectorMulAddS_NN1N</a> (PlankS *result, const PlankS *input, PlankS mul, const PlankS *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gacfef4b4020df252bed7ab3b0c2e7eda9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga376c98f4e041eba57e3a8289c5e6d705">pl_VectorLookupS_NnN</a> (PlankS *result, PlankS *table, PlankUL n, PlankS *index, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#ga376c98f4e041eba57e3a8289c5e6d705"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga727178030fcd63f7a1be4dcc451f68bd">pl_VectorFillI_N1</a> (PlankI *result, PlankI value, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#ga727178030fcd63f7a1be4dcc451f68bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1aff6ae666ee2aa04020c2d892d9f39d">pl_VectorClearI_N</a> (PlankI *result, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#ga1aff6ae666ee2aa04020c2d892d9f39d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga42061b10abbe6849bfac21fe6f1ce766">pl_VectorRampI_N11</a> (PlankI *result, PlankI a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#ga42061b10abbe6849bfac21fe6f1ce766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga705d29301461f04ed2372724ad86281d">pl_VectorLineI_N11</a> (PlankI *result, PlankI a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#ga705d29301461f04ed2372724ad86281d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga19a61afeeff8a96a1154b152cc75f68e">pl_VectorMoveI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_MoveI() to each item in a vector.  <a href="#ga19a61afeeff8a96a1154b152cc75f68e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaecf5045346456bfbfc963dd6c062dd41">pl_VectorIncI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_IncI() to each item in a vector.  <a href="#gaecf5045346456bfbfc963dd6c062dd41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga22b35ce5f323602c380b336f89be6081">pl_VectorDecI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_DecI() to each item in a vector.  <a href="#ga22b35ce5f323602c380b336f89be6081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4ebcc3f3b711bebbf8dbcb99defdb676">pl_VectorNegI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_NegI() to each item in a vector.  <a href="#ga4ebcc3f3b711bebbf8dbcb99defdb676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac64c304f1b44b88a8310659940f10331">pl_VectorAbsI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_AbsI() to each item in a vector.  <a href="#gac64c304f1b44b88a8310659940f10331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga841881979086b4c05673571c4f7cd074">pl_VectorSquaredI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SquaredI() to each item in a vector.  <a href="#ga841881979086b4c05673571c4f7cd074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab4882bdad6edc2a9466b146d4aa652e5">pl_VectorCubedI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_CubedI() to each item in a vector.  <a href="#gab4882bdad6edc2a9466b146d4aa652e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga03a44b0015a08f810263508243ad0d4e">pl_VectorSignI_NN</a> (PlankI *result, const PlankI *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SignI() to each item in a vector.  <a href="#ga03a44b0015a08f810263508243ad0d4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa16f0901425e4e0c2eaae46865259846">pl_VectorAddI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddI() to each item in two input vectors.  <a href="#gaa16f0901425e4e0c2eaae46865259846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7c18f01544ca8513ff416f200ba6164c">pl_VectorAddI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddI() to an input vector and a scalar value.  <a href="#ga7c18f01544ca8513ff416f200ba6164c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf8c145d6d4feb7e609e11c4ac858efb7">pl_VectorAddI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddI() to an input vector and a scalar value.  <a href="#gaf8c145d6d4feb7e609e11c4ac858efb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga197e4812fddc0dc3e377b8fd4e3379c3">pl_VectorSubI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubI() to each item in two input vectors.  <a href="#ga197e4812fddc0dc3e377b8fd4e3379c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga43bc0898fea297df059997f3143dee24">pl_VectorSubI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubI() to an input vector and a scalar value.  <a href="#ga43bc0898fea297df059997f3143dee24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4ef0fce8af0dedc828f9168e838c4ef6">pl_VectorSubI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubI() to an input vector and a scalar value.  <a href="#ga4ef0fce8af0dedc828f9168e838c4ef6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga960849b807b6166c4e8976b90e3c8b2e">pl_VectorMulI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulI() to each item in two input vectors.  <a href="#ga960849b807b6166c4e8976b90e3c8b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac136990a6cd21e5c31deeaa1852197e7">pl_VectorMulI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulI() to an input vector and a scalar value.  <a href="#gac136990a6cd21e5c31deeaa1852197e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga51687633d036d694c1114f91921401ea">pl_VectorMulI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulI() to an input vector and a scalar value.  <a href="#ga51687633d036d694c1114f91921401ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga176ad87d2d709beda7997cf183e2b5f6">pl_VectorDivI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivI() to each item in two input vectors.  <a href="#ga176ad87d2d709beda7997cf183e2b5f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1f309dda40d4c58cdf9999fc2821ec5c">pl_VectorDivI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivI() to an input vector and a scalar value.  <a href="#ga1f309dda40d4c58cdf9999fc2821ec5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad642e939f7f405d4aab58c731b7d5e7a">pl_VectorDivI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivI() to an input vector and a scalar value.  <a href="#gad642e939f7f405d4aab58c731b7d5e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga54343015ebbb345e738e5b28f917eaf3">pl_VectorModI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModI() to each item in two input vectors.  <a href="#ga54343015ebbb345e738e5b28f917eaf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga994d471cd7f98bbda4c66492c1e651b2">pl_VectorModI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModI() to an input vector and a scalar value.  <a href="#ga994d471cd7f98bbda4c66492c1e651b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga21b7e290ac5222277869c93e78f000a2">pl_VectorModI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModI() to an input vector and a scalar value.  <a href="#ga21b7e290ac5222277869c93e78f000a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga16971d35d0936a4db500931541d87d21">pl_VectorMinI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinI() to each item in two input vectors.  <a href="#ga16971d35d0936a4db500931541d87d21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5172fcc25519762ad7554e452e4bde5a">pl_VectorMinI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinI() to an input vector and a scalar value.  <a href="#ga5172fcc25519762ad7554e452e4bde5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadf7c1aadac9149ac376d63d127bb0045">pl_VectorMinI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinI() to an input vector and a scalar value.  <a href="#gadf7c1aadac9149ac376d63d127bb0045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaea32edfdbcfc5403897bc33fe329bc97">pl_VectorMaxI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxI() to each item in two input vectors.  <a href="#gaea32edfdbcfc5403897bc33fe329bc97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga862debd0eee430139e5a902f00e30718">pl_VectorMaxI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxI() to an input vector and a scalar value.  <a href="#ga862debd0eee430139e5a902f00e30718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7780e6326d8ad2f84f8498772a948d33">pl_VectorMaxI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxI() to an input vector and a scalar value.  <a href="#ga7780e6326d8ad2f84f8498772a948d33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga12b5f5ed8f5faacb1698b02b0ced8803">pl_VectorIsEqualToI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToI() to each item in two input vectors.  <a href="#ga12b5f5ed8f5faacb1698b02b0ced8803"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga85097a2dde0bb7f2a99f8c8a9db2017d">pl_VectorIsEqualToI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToI() to an input vector and a scalar value.  <a href="#ga85097a2dde0bb7f2a99f8c8a9db2017d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabf54043e6451bc7d8186546bd9a24400">pl_VectorIsEqualToI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToI() to an input vector and a scalar value.  <a href="#gabf54043e6451bc7d8186546bd9a24400"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf03ecaddf9f5540898ea025e0c608191">pl_VectorIsNotEqualToI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToI() to each item in two input vectors.  <a href="#gaf03ecaddf9f5540898ea025e0c608191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8effb02c79b6654af2076feb714b643d">pl_VectorIsNotEqualToI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToI() to an input vector and a scalar value.  <a href="#ga8effb02c79b6654af2076feb714b643d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae87c2ba26f4fd9ed769f73d9c70a604b">pl_VectorIsNotEqualToI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToI() to an input vector and a scalar value.  <a href="#gae87c2ba26f4fd9ed769f73d9c70a604b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b93d6d5fecbb723deb872f42681a986">pl_VectorIsGreaterThanI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanI() to each item in two input vectors.  <a href="#ga3b93d6d5fecbb723deb872f42681a986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga869265fec66535f6495bfca6ff0b4eeb">pl_VectorIsGreaterThanI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanI() to an input vector and a scalar value.  <a href="#ga869265fec66535f6495bfca6ff0b4eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f40eefc4ad028776f5179adc23b781f">pl_VectorIsGreaterThanI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanI() to an input vector and a scalar value.  <a href="#ga6f40eefc4ad028776f5179adc23b781f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabe386fb77c3733df1b72da24d39987ac">pl_VectorIsGreaterThanOrEqualToI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToI() to each item in two input vectors.  <a href="#gabe386fb77c3733df1b72da24d39987ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab37bd644419a8dddf3e8e25ef1622a57">pl_VectorIsGreaterThanOrEqualToI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToI() to an input vector and a scalar value.  <a href="#gab37bd644419a8dddf3e8e25ef1622a57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga88785aac3d4d61bf59e3f5aba4ab1c6b">pl_VectorIsGreaterThanOrEqualToI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToI() to an input vector and a scalar value.  <a href="#ga88785aac3d4d61bf59e3f5aba4ab1c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga504386875fab2214b6520e995b71b3fc">pl_VectorIsLessThanI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanI() to each item in two input vectors.  <a href="#ga504386875fab2214b6520e995b71b3fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaaa6ae8d351738646edd0e6683460ca86">pl_VectorIsLessThanI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanI() to an input vector and a scalar value.  <a href="#gaaa6ae8d351738646edd0e6683460ca86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3633d60d514829d578e49362bb456d33">pl_VectorIsLessThanI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanI() to an input vector and a scalar value.  <a href="#ga3633d60d514829d578e49362bb456d33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1437a8cb597e5278da4821d0084483fe">pl_VectorIsLessThanOrEqualToI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToI() to each item in two input vectors.  <a href="#ga1437a8cb597e5278da4821d0084483fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7248c7f18dc9e0c220408967056150bd">pl_VectorIsLessThanOrEqualToI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToI() to an input vector and a scalar value.  <a href="#ga7248c7f18dc9e0c220408967056150bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga08535f65b8428eb8476773ab6381764e">pl_VectorIsLessThanOrEqualToI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToI() to an input vector and a scalar value.  <a href="#ga08535f65b8428eb8476773ab6381764e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga57263ad8dd6105b4ebf699c72e07a343">pl_VectorSumSqrI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrI() to each item in two input vectors.  <a href="#ga57263ad8dd6105b4ebf699c72e07a343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3df6f830ed2c6262d1b6ac212cd9f070">pl_VectorSumSqrI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrI() to an input vector and a scalar value.  <a href="#ga3df6f830ed2c6262d1b6ac212cd9f070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2d43084d26270d2c6bec67a3a50bc39e">pl_VectorSumSqrI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrI() to an input vector and a scalar value.  <a href="#ga2d43084d26270d2c6bec67a3a50bc39e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga597e0e2f2269e3e58218fb983226aefc">pl_VectorDifSqrI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrI() to each item in two input vectors.  <a href="#ga597e0e2f2269e3e58218fb983226aefc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf2977751af751063b52f61035652ad65">pl_VectorDifSqrI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrI() to an input vector and a scalar value.  <a href="#gaf2977751af751063b52f61035652ad65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga43bb147fc87e3d0b648f38973ad3ec42">pl_VectorDifSqrI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrI() to an input vector and a scalar value.  <a href="#ga43bb147fc87e3d0b648f38973ad3ec42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf171b69a54ed5815ad05b8fbbe1d0e88">pl_VectorSqrSumI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumI() to each item in two input vectors.  <a href="#gaf171b69a54ed5815ad05b8fbbe1d0e88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0c4c875eb7802ab9b8bbfa291f516d91">pl_VectorSqrSumI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumI() to an input vector and a scalar value.  <a href="#ga0c4c875eb7802ab9b8bbfa291f516d91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab7a5d8f72139d1f01490b6b5525e1da">pl_VectorSqrSumI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumI() to an input vector and a scalar value.  <a href="#gaab7a5d8f72139d1f01490b6b5525e1da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf50f17978fb3038f2de90158d52ba22d">pl_VectorSqrDifI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifI() to each item in two input vectors.  <a href="#gaf50f17978fb3038f2de90158d52ba22d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab2ddadabab887ab7242e6e38a1a9e571">pl_VectorSqrDifI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifI() to an input vector and a scalar value.  <a href="#gab2ddadabab887ab7242e6e38a1a9e571"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae801d743f02db4268e9897ba221372b5">pl_VectorSqrDifI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifI() to an input vector and a scalar value.  <a href="#gae801d743f02db4268e9897ba221372b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa745e212cf4396f83b2f018b15b9a370">pl_VectorAbsDifI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifI() to each item in two input vectors.  <a href="#gaa745e212cf4396f83b2f018b15b9a370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gace82d0dd1e6729ebc1afc36fe0ff24e5">pl_VectorAbsDifI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifI() to an input vector and a scalar value.  <a href="#gace82d0dd1e6729ebc1afc36fe0ff24e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae318dbf31f82cd92919cb57ec9094b41">pl_VectorAbsDifI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifI() to an input vector and a scalar value.  <a href="#gae318dbf31f82cd92919cb57ec9094b41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae3434cc8929b73c8e577b15860607c9c">pl_VectorThreshI_NNN</a> (PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshI() to each item in two input vectors.  <a href="#gae3434cc8929b73c8e577b15860607c9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0d56ca707caa7e03c034acd240cb8ef9">pl_VectorThreshI_NN1</a> (PlankI *result, const PlankI *a, PlankI b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshI() to an input vector and a scalar value.  <a href="#ga0d56ca707caa7e03c034acd240cb8ef9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9119d072c56a8dcd37299be9cc0cfcbb">pl_VectorThreshI_N1N</a> (PlankI *result, PlankI a, const PlankI *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshI() to an input vector and a scalar value.  <a href="#ga9119d072c56a8dcd37299be9cc0cfcbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4aaa634f9d9a0c565489c4d87bd0c2d4">pl_VectorMulAddI_NNNN</a> (PlankI *result, const PlankI *input, const PlankI *mul, const PlankI *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga4aaa634f9d9a0c565489c4d87bd0c2d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga03810df23c537596e82c9dc719c7b25c">pl_VectorMulAddI_NNN</a> (PlankI *io, const PlankI *mul, const PlankI *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga03810df23c537596e82c9dc719c7b25c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8adb8adb81422b2aaeb1f3b7b8a7beae">pl_VectorMulAddI_NNN1</a> (PlankI *result, const PlankI *input, const PlankI *mul, PlankI add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga8adb8adb81422b2aaeb1f3b7b8a7beae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacf5b8d44f0f632e92508d099181ba954">pl_VectorMulAddI_NN11</a> (PlankI *result, const PlankI *input, PlankI mul, PlankI add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gacf5b8d44f0f632e92508d099181ba954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac94c1021ef7c7eae685f1dcc5d7cef5a">pl_VectorMulAddI_NN1N</a> (PlankI *result, const PlankI *input, PlankI mul, const PlankI *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gac94c1021ef7c7eae685f1dcc5d7cef5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabb45f8a65457b0a774d4aaf3b01c963f">pl_VectorLookupI_NnN</a> (PlankI *result, PlankI *table, PlankUL n, PlankI *index, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gabb45f8a65457b0a774d4aaf3b01c963f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf84a0db5e5fef5eadf697cf07de13233">pl_VectorFillLL_N1</a> (PlankLL *result, PlankLL value, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="#gaf84a0db5e5fef5eadf697cf07de13233"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa065357156fb3be7d3a8ada376387d9a">pl_VectorClearLL_N</a> (PlankLL *result, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="#gaa065357156fb3be7d3a8ada376387d9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab31c67648781b10b85c3b8aed2979034">pl_VectorRampLL_N11</a> (PlankLL *result, PlankLL a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="#gab31c67648781b10b85c3b8aed2979034"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae2c3c99f8fbee8b93d48f299c87c3b77">pl_VectorLineLL_N11</a> (PlankLL *result, PlankLL a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="#gae2c3c99f8fbee8b93d48f299c87c3b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae919da82c0ae9d389e57e742c0de4591">pl_VectorMoveLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_MoveLL() to each item in a vector.  <a href="#gae919da82c0ae9d389e57e742c0de4591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga13ec881fafbc63ad1c70efdf3950f25d">pl_VectorIncLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_IncLL() to each item in a vector.  <a href="#ga13ec881fafbc63ad1c70efdf3950f25d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf5de631557fcb8888f6af915ed8a6918">pl_VectorDecLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_DecLL() to each item in a vector.  <a href="#gaf5de631557fcb8888f6af915ed8a6918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1fda3af654ab09d3838e9c5bf714c012">pl_VectorNegLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_NegLL() to each item in a vector.  <a href="#ga1fda3af654ab09d3838e9c5bf714c012"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga80fd85d072f3513072d491e0e98edfb8">pl_VectorAbsLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_AbsLL() to each item in a vector.  <a href="#ga80fd85d072f3513072d491e0e98edfb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga21096795df3eb840b95014154dd06075">pl_VectorSquaredLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SquaredLL() to each item in a vector.  <a href="#ga21096795df3eb840b95014154dd06075"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa7290240f91f9973839d794fa1a43af8">pl_VectorCubedLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_CubedLL() to each item in a vector.  <a href="#gaa7290240f91f9973839d794fa1a43af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf3e9d4da884a902b4996935d9f0376fc">pl_VectorSignLL_NN</a> (PlankLL *result, const PlankLL *a, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function pl_SignLL() to each item in a vector.  <a href="#gaf3e9d4da884a902b4996935d9f0376fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1d5279847128c7432cfa6f137cf91c7">pl_VectorAddLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddLL() to each item in two input vectors.  <a href="#gae1d5279847128c7432cfa6f137cf91c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf68c0439b9f602c00d4dfd4cdfc9b50a">pl_VectorAddLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddLL() to an input vector and a scalar value.  <a href="#gaf68c0439b9f602c00d4dfd4cdfc9b50a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3e823307e585dcbb01e2096a0dbf31d0">pl_VectorAddLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AddLL() to an input vector and a scalar value.  <a href="#ga3e823307e585dcbb01e2096a0dbf31d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac0b7da55fd7b38be08e742bf3e3023fe">pl_VectorSubLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubLL() to each item in two input vectors.  <a href="#gac0b7da55fd7b38be08e742bf3e3023fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac56555f924384c51446f610e99ecf59a">pl_VectorSubLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubLL() to an input vector and a scalar value.  <a href="#gac56555f924384c51446f610e99ecf59a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga864ff9f594555108deeb4c93db21df54">pl_VectorSubLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SubLL() to an input vector and a scalar value.  <a href="#ga864ff9f594555108deeb4c93db21df54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0a5eb14af645d390eca7fb821c5e8de7">pl_VectorMulLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulLL() to each item in two input vectors.  <a href="#ga0a5eb14af645d390eca7fb821c5e8de7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga20621a1f0b38d5b2df604193d3543e8c">pl_VectorMulLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulLL() to an input vector and a scalar value.  <a href="#ga20621a1f0b38d5b2df604193d3543e8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab16f182cb89172200a782f63a6d2cbf5">pl_VectorMulLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MulLL() to an input vector and a scalar value.  <a href="#gab16f182cb89172200a782f63a6d2cbf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0167966039a5e7382af51977a938d754">pl_VectorDivLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivLL() to each item in two input vectors.  <a href="#ga0167966039a5e7382af51977a938d754"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadaa1e0e2d9937ca0e8559a94302b49dd">pl_VectorDivLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivLL() to an input vector and a scalar value.  <a href="#gadaa1e0e2d9937ca0e8559a94302b49dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7da06947a2f5c7f9560fdaccbaedeac3">pl_VectorDivLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DivLL() to an input vector and a scalar value.  <a href="#ga7da06947a2f5c7f9560fdaccbaedeac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafe5b172f36f5dcad41b333136374096c">pl_VectorModLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModLL() to each item in two input vectors.  <a href="#gafe5b172f36f5dcad41b333136374096c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9b7221a44434f169a28ba01233187747">pl_VectorModLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModLL() to an input vector and a scalar value.  <a href="#ga9b7221a44434f169a28ba01233187747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf3489d1f12dc47168d411d5327db49b3">pl_VectorModLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ModLL() to an input vector and a scalar value.  <a href="#gaf3489d1f12dc47168d411d5327db49b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09090ecf8370a76224afb6c6d6f100a3">pl_VectorMinLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinLL() to each item in two input vectors.  <a href="#ga09090ecf8370a76224afb6c6d6f100a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga021f6b8f8cba03bfa196ceb0b924b746">pl_VectorMinLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinLL() to an input vector and a scalar value.  <a href="#ga021f6b8f8cba03bfa196ceb0b924b746"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac92176b8931e56802485832a309eef92">pl_VectorMinLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MinLL() to an input vector and a scalar value.  <a href="#gac92176b8931e56802485832a309eef92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac46bf6babbe74e5bdb39d00c4399305a">pl_VectorMaxLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxLL() to each item in two input vectors.  <a href="#gac46bf6babbe74e5bdb39d00c4399305a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0c9af5446cea35b78b61799b52531fbd">pl_VectorMaxLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxLL() to an input vector and a scalar value.  <a href="#ga0c9af5446cea35b78b61799b52531fbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa317765828b6f2ac5513f43199f9e548">pl_VectorMaxLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_MaxLL() to an input vector and a scalar value.  <a href="#gaa317765828b6f2ac5513f43199f9e548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8b38f070771288c84d2abe662a43ed74">pl_VectorIsEqualToLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToLL() to each item in two input vectors.  <a href="#ga8b38f070771288c84d2abe662a43ed74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga261be999c41717bae31ecd4cc204f3fc">pl_VectorIsEqualToLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToLL() to an input vector and a scalar value.  <a href="#ga261be999c41717bae31ecd4cc204f3fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac55ebbe428b1f8a585fa7bbc88346655">pl_VectorIsEqualToLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsEqualToLL() to an input vector and a scalar value.  <a href="#gac55ebbe428b1f8a585fa7bbc88346655"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad7b6a85fe384903679ead8d6b1c372b0">pl_VectorIsNotEqualToLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToLL() to each item in two input vectors.  <a href="#gad7b6a85fe384903679ead8d6b1c372b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga906550c07fdd9897abbd3d9d8e8617c6">pl_VectorIsNotEqualToLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToLL() to an input vector and a scalar value.  <a href="#ga906550c07fdd9897abbd3d9d8e8617c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga48345058d66d98c680c3b11ab55c4701">pl_VectorIsNotEqualToLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsNotEqualToLL() to an input vector and a scalar value.  <a href="#ga48345058d66d98c680c3b11ab55c4701"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab0cf0886fd1c306973af56623196996">pl_VectorIsGreaterThanLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanLL() to each item in two input vectors.  <a href="#gaab0cf0886fd1c306973af56623196996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1ee194bb35cb350379605f79f401593f">pl_VectorIsGreaterThanLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanLL() to an input vector and a scalar value.  <a href="#ga1ee194bb35cb350379605f79f401593f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa7b42f129ab4bf418e7993d979150699">pl_VectorIsGreaterThanLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanLL() to an input vector and a scalar value.  <a href="#gaa7b42f129ab4bf418e7993d979150699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7b2456843dd954b646fe8e0334577f8">pl_VectorIsGreaterThanOrEqualToLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to each item in two input vectors.  <a href="#gaf7b2456843dd954b646fe8e0334577f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga50181d615f41745f708047d4f8ce0b14">pl_VectorIsGreaterThanOrEqualToLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to an input vector and a scalar value.  <a href="#ga50181d615f41745f708047d4f8ce0b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga47ff8793050f5387e8e24320f75ef159">pl_VectorIsGreaterThanOrEqualToLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to an input vector and a scalar value.  <a href="#ga47ff8793050f5387e8e24320f75ef159"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab29d403f88a018cdc6a8ed7fb801ba16">pl_VectorIsLessThanLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanLL() to each item in two input vectors.  <a href="#gab29d403f88a018cdc6a8ed7fb801ba16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b39658fb221c92c5617ce946262de2c">pl_VectorIsLessThanLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanLL() to an input vector and a scalar value.  <a href="#ga3b39658fb221c92c5617ce946262de2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaca5df71805cf447e6b511fa7823ae44b">pl_VectorIsLessThanLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanLL() to an input vector and a scalar value.  <a href="#gaca5df71805cf447e6b511fa7823ae44b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0f29b12f4df2237e9b833c97f04b1981">pl_VectorIsLessThanOrEqualToLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToLL() to each item in two input vectors.  <a href="#ga0f29b12f4df2237e9b833c97f04b1981"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad79b9f3693432646389e1ede8bee2fea">pl_VectorIsLessThanOrEqualToLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToLL() to an input vector and a scalar value.  <a href="#gad79b9f3693432646389e1ede8bee2fea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga988bda519b884018b312990b58c15e93">pl_VectorIsLessThanOrEqualToLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_IsLessThanOrEqualToLL() to an input vector and a scalar value.  <a href="#ga988bda519b884018b312990b58c15e93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf592a2d254c4eb8d213cb74ec8383e6f">pl_VectorSumSqrLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrLL() to each item in two input vectors.  <a href="#gaf592a2d254c4eb8d213cb74ec8383e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf034cde90191003fba90e423458cd4e6">pl_VectorSumSqrLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrLL() to an input vector and a scalar value.  <a href="#gaf034cde90191003fba90e423458cd4e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaaeef7ad1d58726bc9f3f06b276b3fa6f">pl_VectorSumSqrLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SumSqrLL() to an input vector and a scalar value.  <a href="#gaaeef7ad1d58726bc9f3f06b276b3fa6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab8b49243b28fc58e8c248e6082031348">pl_VectorDifSqrLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrLL() to each item in two input vectors.  <a href="#gab8b49243b28fc58e8c248e6082031348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0e084dcf725051417d3377a9cac440cc">pl_VectorDifSqrLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrLL() to an input vector and a scalar value.  <a href="#ga0e084dcf725051417d3377a9cac440cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2e8cc617e97f46514200c452f9d6a8df">pl_VectorDifSqrLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_DifSqrLL() to an input vector and a scalar value.  <a href="#ga2e8cc617e97f46514200c452f9d6a8df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga41012ab6e39483bb96d38e66d0f1a26f">pl_VectorSqrSumLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumLL() to each item in two input vectors.  <a href="#ga41012ab6e39483bb96d38e66d0f1a26f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8322b53212bb0cf9d7ba000bb5c7c93d">pl_VectorSqrSumLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumLL() to an input vector and a scalar value.  <a href="#ga8322b53212bb0cf9d7ba000bb5c7c93d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3708c0ebae86573f054ac6eb7e370143">pl_VectorSqrSumLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrSumLL() to an input vector and a scalar value.  <a href="#ga3708c0ebae86573f054ac6eb7e370143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6da0c2289b6dd4b948019b4f17c2abf1">pl_VectorSqrDifLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifLL() to each item in two input vectors.  <a href="#ga6da0c2289b6dd4b948019b4f17c2abf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga268f7123d51dd3ddae1ed03bb1669dfb">pl_VectorSqrDifLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifLL() to an input vector and a scalar value.  <a href="#ga268f7123d51dd3ddae1ed03bb1669dfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa052fcfbb798651180f1e19bcaedd137">pl_VectorSqrDifLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_SqrDifLL() to an input vector and a scalar value.  <a href="#gaa052fcfbb798651180f1e19bcaedd137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac82c15d6469caebac855c86c0a2468db">pl_VectorAbsDifLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifLL() to each item in two input vectors.  <a href="#gac82c15d6469caebac855c86c0a2468db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab35ab2461f049daa25d495492d00d4ee">pl_VectorAbsDifLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifLL() to an input vector and a scalar value.  <a href="#gab35ab2461f049daa25d495492d00d4ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6408443ea095a5e09ef52f6176fde348">pl_VectorAbsDifLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_AbsDifLL() to an input vector and a scalar value.  <a href="#ga6408443ea095a5e09ef52f6176fde348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaaefcaea6937598439c1e27ff730e3b05">pl_VectorThreshLL_NNN</a> (PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshLL() to each item in two input vectors.  <a href="#gaaefcaea6937598439c1e27ff730e3b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaeddba6d777b29b1a424122c495f48e8f">pl_VectorThreshLL_NN1</a> (PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshLL() to an input vector and a scalar value.  <a href="#gaeddba6d777b29b1a424122c495f48e8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac52ca8882e12cc87a0973ad0f728db7b">pl_VectorThreshLL_N1N</a> (PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function pl_ThreshLL() to an input vector and a scalar value.  <a href="#gac52ca8882e12cc87a0973ad0f728db7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga589741aab3233ccabb9e7072147820a6">pl_VectorMulAddLL_NNNN</a> (PlankLL *result, const PlankLL *input, const PlankLL *mul, const PlankLL *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga589741aab3233ccabb9e7072147820a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaed08064190f52acea2c3a812b925c83c">pl_VectorMulAddLL_NNN</a> (PlankLL *io, const PlankLL *mul, const PlankLL *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gaed08064190f52acea2c3a812b925c83c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae3284e0da05b20dff4f322cce0772771">pl_VectorMulAddLL_NNN1</a> (PlankLL *result, const PlankLL *input, const PlankLL *mul, PlankLL add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gae3284e0da05b20dff4f322cce0772771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0a6c37f8ad3cf89475953b21a9a0a246">pl_VectorMulAddLL_NN11</a> (PlankLL *result, const PlankLL *input, PlankLL mul, PlankLL add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#ga0a6c37f8ad3cf89475953b21a9a0a246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7fe17b73495151acf1ca13ff12a4570">pl_VectorMulAddLL_NN1N</a> (PlankLL *result, const PlankLL *input, PlankLL mul, const PlankLL *add, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="#gaf7fe17b73495151acf1ca13ff12a4570"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab03ed8477a6d6e9cf6583d2695ada1d7">pl_VectorLookupLL_NnN</a> (PlankLL *result, PlankLL *table, PlankUL n, PlankLL *index, PlankUL N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="#gab03ed8477a6d6e9cf6583d2695ada1d7"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Vector processing functions. </p>
<p>These process vectors (arrays) of data applying common maths functions to the inputs. The default is to use the scalar processing functions (implmented with a loop in C) but many of these operations can be performed with faster, optimised libraries on some platforms (e.g., vDSP on Mac OS X and iOS).</p>
<p>The naming convention is to prefix all functions with 'pl_Vector'. This is followed by the name of the operation which is commonly the name of an equivalent scalar function. Finally the name is suffixed with a code to identify the type of vectors and/or scalar values passed to the function. The code starts with the number of items in the output vector and is followed by codes for the sizes of the other input vectors. For example, all the unary operators are suffixed '_NN' so show the input and output vectors are the same size 'N' (which is the N argument passed the the function). Some binary operators are suffixed '_NNN', '_NN1' or '_N1N'. The first is where there are two input vectors and the output vector that are all the same size. '_NN1' has an input vector with the same size as the output and a scalar value '1' (i.e., a scalar) as the other operand. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae0e337b7b89735618a1855ea91660bd9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorA2dBD_NN" ref="gae0e337b7b89735618a1855ea91660bd9" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorA2dBD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d6a453af826e1347bbe6801068431e4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorA2dBF_NN" ref="ga6d6a453af826e1347bbe6801068431e4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorA2dBF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec21dab0c087e0b170745b2e3efd207b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsD_NN" ref="gaec21dab0c087e0b170745b2e3efd207b" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fcc23c11a1a0ef8790d60c4be0ce4fd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_N1N" ref="ga7fcc23c11a1a0ef8790d60c4be0ce4fd" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7625f658d95e5bfaa275bcb24560575"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_NN1" ref="gaf7625f658d95e5bfaa275bcb24560575" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5778badb734f9dc6fab15eadd6e31bc7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifD_NNN" ref="ga5778badb734f9dc6fab15eadd6e31bc7" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a66577c30fc72bd6eff2271f9c10b16"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_N1N" ref="ga3a66577c30fc72bd6eff2271f9c10b16" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c8da37fdfd80aebd9d1743a0da9b497"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_NN1" ref="ga1c8da37fdfd80aebd9d1743a0da9b497" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9d78883696faed1ffc7b1ed6cbb4bc8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifF_NNN" ref="gaa9d78883696faed1ffc7b1ed6cbb4bc8" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae318dbf31f82cd92919cb57ec9094b41"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifI_N1N" ref="gae318dbf31f82cd92919cb57ec9094b41" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AbsDifI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace82d0dd1e6729ebc1afc36fe0ff24e5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifI_NN1" ref="gace82d0dd1e6729ebc1afc36fe0ff24e5" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AbsDifI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa745e212cf4396f83b2f018b15b9a370"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifI_NNN" ref="gaa745e212cf4396f83b2f018b15b9a370" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AbsDifI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6408443ea095a5e09ef52f6176fde348"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifLL_N1N" ref="ga6408443ea095a5e09ef52f6176fde348" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AbsDifLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab35ab2461f049daa25d495492d00d4ee"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifLL_NN1" ref="gab35ab2461f049daa25d495492d00d4ee" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AbsDifLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac82c15d6469caebac855c86c0a2468db"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifLL_NNN" ref="gac82c15d6469caebac855c86c0a2468db" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AbsDifLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66b6ca82f4090130fcba7c21dc44730b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifS_N1N" ref="ga66b6ca82f4090130fcba7c21dc44730b" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AbsDifS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga422881deeb36ac85eadaaabeedbf2f4e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifS_NN1" ref="ga422881deeb36ac85eadaaabeedbf2f4e" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AbsDifS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaabdf55cdbfd0d85aafa52d763b91d91"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsDifS_NNN" ref="gaaabdf55cdbfd0d85aafa52d763b91d91" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsDifS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AbsDifS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AbsDifS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0da76047e2f5935ce69ec1b4084959b7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsF_NN" ref="ga0da76047e2f5935ce69ec1b4084959b7" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac64c304f1b44b88a8310659940f10331"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsI_NN" ref="gac64c304f1b44b88a8310659940f10331" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_AbsI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_AbsI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80fd85d072f3513072d491e0e98edfb8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsLL_NN" ref="ga80fd85d072f3513072d491e0e98edfb8" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_AbsLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_AbsLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1e52d14bc1a34c68a948d47df95ec84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAbsS_NN" ref="gae1e52d14bc1a34c68a948d47df95ec84" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAbsS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_AbsS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_AbsS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacac99df0db7dad5461861849601a0dc8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAcosD_NN" ref="gacac99df0db7dad5461861849601a0dc8" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAcosD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b0876ed78d4675a40aec91015020543"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAcosF_NN" ref="ga4b0876ed78d4675a40aec91015020543" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAcosF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a1316615dc2031b02b71424f44d657f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_N1N" ref="ga5a1316615dc2031b02b71424f44d657f" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae41675932ccb373a167cd2c83e3df768"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_NN1" ref="gae41675932ccb373a167cd2c83e3df768" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12ef092e0c8e669d7762e69d0559e3a2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddD_NNN" ref="ga12ef092e0c8e669d7762e69d0559e3a2" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96c458ac80a73ae97d9836e7cdff6653"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_N1N" ref="ga96c458ac80a73ae97d9836e7cdff6653" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53fdeba08d131bafeee9e2217b79f77a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_NN1" ref="ga53fdeba08d131bafeee9e2217b79f77a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3874b7ec8eb9d6daa7e57928ac093a9c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddF_NNN" ref="ga3874b7ec8eb9d6daa7e57928ac093a9c" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8c145d6d4feb7e609e11c4ac858efb7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddI_N1N" ref="gaf8c145d6d4feb7e609e11c4ac858efb7" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AddI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c18f01544ca8513ff416f200ba6164c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddI_NN1" ref="ga7c18f01544ca8513ff416f200ba6164c" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AddI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa16f0901425e4e0c2eaae46865259846"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddI_NNN" ref="gaa16f0901425e4e0c2eaae46865259846" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AddI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e823307e585dcbb01e2096a0dbf31d0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddLL_N1N" ref="ga3e823307e585dcbb01e2096a0dbf31d0" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AddLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf68c0439b9f602c00d4dfd4cdfc9b50a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddLL_NN1" ref="gaf68c0439b9f602c00d4dfd4cdfc9b50a" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AddLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1d5279847128c7432cfa6f137cf91c7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddLL_NNN" ref="gae1d5279847128c7432cfa6f137cf91c7" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AddLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae42fe911bc599a2df82ffda402470e31"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddS_N1N" ref="gae42fe911bc599a2df82ffda402470e31" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_AddS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e3237fd95808bb48b6b79213a34df0e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddS_NN1" ref="ga5e3237fd95808bb48b6b79213a34df0e" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_AddS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9786be679f3fd5e9129d92d5e642975"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAddS_NNN" ref="gad9786be679f3fd5e9129d92d5e642975" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAddS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_AddS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_AddS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedae3e19d90c4a4cb5212edadcd76f76"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAsinD_NN" ref="gaedae3e19d90c4a4cb5212edadcd76f76" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAsinD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40b4fd224d5c1df552bd36fd79e14d46"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAsinF_NN" ref="ga40b4fd224d5c1df552bd36fd79e14d46" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAsinF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadac799a76f6ffc595d2b0771279a48a4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_N1N" ref="gadac799a76f6ffc595d2b0771279a48a4" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9ae9c8c64cfe988951cbc4b51b81abf"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_NN1" ref="gae9ae9c8c64cfe988951cbc4b51b81abf" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89afb2f55dfc5f5a749799d78aa27693"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2D_NNN" ref="ga89afb2f55dfc5f5a749799d78aa27693" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2D_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1570febbc25f8b9a3ef7ac8cc7af07ae"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_N1N" ref="ga1570febbc25f8b9a3ef7ac8cc7af07ae" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaece9a054e73c28bd180580b0cd016018"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_NN1" ref="gaece9a054e73c28bd180580b0cd016018" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44812f3688888b573be8c9db069b936a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtan2F_NNN" ref="ga44812f3688888b573be8c9db069b936a" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtan2F_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dcc5850da8f410f63fb5c929a0f7e76"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtanD_NN" ref="ga2dcc5850da8f410f63fb5c929a0f7e76" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtanD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c392fc9382aa520c8d73f30ce097361"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorAtanF_NN" ref="ga1c392fc9382aa520c8d73f30ce097361" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorAtanF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50da194cf31d82e931c3d2b3509934b3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCeilD_NN" ref="ga50da194cf31d82e931c3d2b3509934b3" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCeilD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga624ee54e6e8bab7bd8f81997c07b7242"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCeilF_NN" ref="ga624ee54e6e8bab7bd8f81997c07b7242" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCeilF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa347eccfa116a68b56f8f5eee79e5707"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearD_N" ref="gaa347eccfa116a68b56f8f5eee79e5707" args="(PlankD *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearD_N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="ga56913dd2881acd870e0bf0b81761f29a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearF_N" ref="ga56913dd2881acd870e0bf0b81761f29a" args="(PlankF *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearF_N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="ga1aff6ae666ee2aa04020c2d892d9f39d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearI_N" ref="ga1aff6ae666ee2aa04020c2d892d9f39d" args="(PlankI *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearI_N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="gaa065357156fb3be7d3a8ada376387d9a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearLL_N" ref="gaa065357156fb3be7d3a8ada376387d9a" args="(PlankLL *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearLL_N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="gaf9ff12ccf9b8b66551abb12e0d11ec4f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorClearS_N" ref="gaf9ff12ccf9b8b66551abb12e0d11ec4f" args="(PlankS *result, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorClearS_N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with zeros. </p>

</div>
</div>
<a class="anchor" id="ga5eb1030590f71b5165e3f72b6bd656e5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCosD_NN" ref="ga5eb1030590f71b5165e3f72b6bd656e5" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCosD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dc9e1a1005c50962f50b218bdd359f7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCosF_NN" ref="ga2dc9e1a1005c50962f50b218bdd359f7" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCosF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5853e6b3aff90d56b2d433da806d858f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCoshD_NN" ref="ga5853e6b3aff90d56b2d433da806d858f" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCoshD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7fca130c7b57d8f99ba52546a3d401f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCoshF_NN" ref="gae7fca130c7b57d8f99ba52546a3d401f" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCoshF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac92318b9550618c0eb61f5c6db28b6f0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedD_NN" ref="gac92318b9550618c0eb61f5c6db28b6f0" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14c2dd307d97ebea1a2b0a79a4f18f3f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedF_NN" ref="ga14c2dd307d97ebea1a2b0a79a4f18f3f" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4882bdad6edc2a9466b146d4aa652e5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedI_NN" ref="gab4882bdad6edc2a9466b146d4aa652e5" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_CubedI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_CubedI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7290240f91f9973839d794fa1a43af8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedLL_NN" ref="gaa7290240f91f9973839d794fa1a43af8" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_CubedLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_CubedLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc74c7a764866191b0fae31c1451b73f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorCubedS_NN" ref="gadc74c7a764866191b0fae31c1451b73f" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorCubedS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_CubedS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_CubedS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaba41fd68b23cb9bdd1cefb6c4b71c7a4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorD2RD_NN" ref="gaba41fd68b23cb9bdd1cefb6c4b71c7a4" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorD2RD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4ffbe59182ba1514ccd8969ed780394"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorD2RF_NN" ref="gac4ffbe59182ba1514ccd8969ed780394" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorD2RF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bb9f2cc273aaefa164d83f970e30380"></a><!-- doxytag: member="plank_Vectors.h::pl_VectordB2AD_NN" ref="ga7bb9f2cc273aaefa164d83f970e30380" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectordB2AD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf55e4f2965d3427a503f26e3e3d22a40"></a><!-- doxytag: member="plank_Vectors.h::pl_VectordB2AF_NN" ref="gaf55e4f2965d3427a503f26e3e3d22a40" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectordB2AF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90167dde80a4ec5921626be554be8f1b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDecD_NN" ref="ga90167dde80a4ec5921626be554be8f1b" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDecD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_DecD() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_DecD() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40879eea9b0e289225507473f339427e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDecF_NN" ref="ga40879eea9b0e289225507473f339427e" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDecF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_DecF() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_DecF() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22b35ce5f323602c380b336f89be6081"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDecI_NN" ref="ga22b35ce5f323602c380b336f89be6081" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDecI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_DecI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_DecI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5de631557fcb8888f6af915ed8a6918"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDecLL_NN" ref="gaf5de631557fcb8888f6af915ed8a6918" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDecLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_DecLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_DecLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad38ea1bbf04597e2424451d97188304"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDecS_NN" ref="gaad38ea1bbf04597e2424451d97188304" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDecS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_DecS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_DecS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d40bd884f8f805edebd3c59ca883a38"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_N1N" ref="ga9d40bd884f8f805edebd3c59ca883a38" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46775562a5d0bbd8d670bd7e95284783"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_NN1" ref="ga46775562a5d0bbd8d670bd7e95284783" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac8f1f8d6c6d929b667f15dbe053831c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrD_NNN" ref="gaac8f1f8d6c6d929b667f15dbe053831c" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c6f0bc2d31739420492413ade319f84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_N1N" ref="ga8c6f0bc2d31739420492413ade319f84" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab11b4161a9b842caf8431aa6e578f81"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_NN1" ref="gaab11b4161a9b842caf8431aa6e578f81" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecd22cb5b339a05a83a47ce9a5eb303d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrF_NNN" ref="gaecd22cb5b339a05a83a47ce9a5eb303d" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43bb147fc87e3d0b648f38973ad3ec42"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrI_N1N" ref="ga43bb147fc87e3d0b648f38973ad3ec42" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DifSqrI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2977751af751063b52f61035652ad65"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrI_NN1" ref="gaf2977751af751063b52f61035652ad65" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DifSqrI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga597e0e2f2269e3e58218fb983226aefc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrI_NNN" ref="ga597e0e2f2269e3e58218fb983226aefc" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DifSqrI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e8cc617e97f46514200c452f9d6a8df"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrLL_N1N" ref="ga2e8cc617e97f46514200c452f9d6a8df" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DifSqrLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e084dcf725051417d3377a9cac440cc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrLL_NN1" ref="ga0e084dcf725051417d3377a9cac440cc" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DifSqrLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8b49243b28fc58e8c248e6082031348"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrLL_NNN" ref="gab8b49243b28fc58e8c248e6082031348" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DifSqrLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3a4e19ec8abb3bac0e5bb6c887bb646"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrS_N1N" ref="gae3a4e19ec8abb3bac0e5bb6c887bb646" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DifSqrS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7f331c1c85310658727ca0b11ae4dc1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrS_NN1" ref="gaf7f331c1c85310658727ca0b11ae4dc1" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DifSqrS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga975403756ec11f5d943cbe8fe36cf3c6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDifSqrS_NNN" ref="ga975403756ec11f5d943cbe8fe36cf3c6" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDifSqrS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DifSqrS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DifSqrS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1c81935d93b40e48a4986fc20c9e34b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDistortD_NN" ref="gae1c81935d93b40e48a4986fc20c9e34b" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDistortD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1abd9fad50bb7512458ef32c19399f3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDistortF_NN" ref="gab1abd9fad50bb7512458ef32c19399f3" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDistortF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98a3a9eeb92bfa82aa1d7f6d12fbd89a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_N1N" ref="ga98a3a9eeb92bfa82aa1d7f6d12fbd89a" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa19c40021b63a0d14db1eddd9d0a037e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_NN1" ref="gaa19c40021b63a0d14db1eddd9d0a037e" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fa89f9180cd6811ec7a0eb94605b996"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivD_NNN" ref="ga1fa89f9180cd6811ec7a0eb94605b996" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fb4b91f3c0068e6b0805195a7899c34"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_N1N" ref="ga7fb4b91f3c0068e6b0805195a7899c34" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga647b8c4642bc5c02b4b4ad7fca5434eb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_NN1" ref="ga647b8c4642bc5c02b4b4ad7fca5434eb" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6db0d03c2bb9e5a663ac3e1d4d3d76a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivF_NNN" ref="gae6db0d03c2bb9e5a663ac3e1d4d3d76a" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad642e939f7f405d4aab58c731b7d5e7a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivI_N1N" ref="gad642e939f7f405d4aab58c731b7d5e7a" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DivI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f309dda40d4c58cdf9999fc2821ec5c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivI_NN1" ref="ga1f309dda40d4c58cdf9999fc2821ec5c" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DivI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga176ad87d2d709beda7997cf183e2b5f6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivI_NNN" ref="ga176ad87d2d709beda7997cf183e2b5f6" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DivI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7da06947a2f5c7f9560fdaccbaedeac3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivLL_N1N" ref="ga7da06947a2f5c7f9560fdaccbaedeac3" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DivLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadaa1e0e2d9937ca0e8559a94302b49dd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivLL_NN1" ref="gadaa1e0e2d9937ca0e8559a94302b49dd" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DivLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0167966039a5e7382af51977a938d754"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivLL_NNN" ref="ga0167966039a5e7382af51977a938d754" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DivLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55ac938ce09bf8512bc76261ccd29948"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivS_N1N" ref="ga55ac938ce09bf8512bc76261ccd29948" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_DivS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae79755efdeaabd5524c1bd211e7241b1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivS_NN1" ref="gae79755efdeaabd5524c1bd211e7241b1" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_DivS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8a8fa16ce64c707eda512adf98ba156"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorDivS_NNN" ref="gad8a8fa16ce64c707eda512adf98ba156" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorDivS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_DivS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_DivS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga346a791b777f3fb3ce4a8b5ab8dd0133"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorExpD_NN" ref="ga346a791b777f3fb3ce4a8b5ab8dd0133" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorExpD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2832cd0f9496ce0c593be00454cc1d56"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorExpF_NN" ref="ga2832cd0f9496ce0c593be00454cc1d56" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorExpF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga781a129439e1bb1dd0295a99085f3a84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorF2MD_NN" ref="ga781a129439e1bb1dd0295a99085f3a84" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorF2MD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga346ccfb5366b8795fb98c20817553baf"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorF2MF_NN" ref="ga346ccfb5366b8795fb98c20817553baf" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorF2MF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d51b6cf9010ce1fa63b9762249261a0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillD_N1" ref="ga3d51b6cf9010ce1fa63b9762249261a0" args="(PlankD *result, PlankD value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillD_N1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="gaf264cdbe70928e87484c7ef7c7e770da"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillF_N1" ref="gaf264cdbe70928e87484c7ef7c7e770da" args="(PlankF *result, PlankF value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillF_N1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="ga727178030fcd63f7a1be4dcc451f68bd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillI_N1" ref="ga727178030fcd63f7a1be4dcc451f68bd" args="(PlankI *result, PlankI value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillI_N1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="gaf84a0db5e5fef5eadf697cf07de13233"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillLL_N1" ref="gaf84a0db5e5fef5eadf697cf07de13233" args="(PlankLL *result, PlankLL value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillLL_N1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="ga6204b4bc6e4f4ff542b53f15c2c7a4a1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFillS_N1" ref="ga6204b4bc6e4f4ff542b53f15c2c7a4a1" args="(PlankS *result, PlankS value, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFillS_N1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a constant. </p>

</div>
</div>
<a class="anchor" id="ga0fabcca5e7164c365cecccf20a2ad394"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFloorD_NN" ref="ga0fabcca5e7164c365cecccf20a2ad394" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFloorD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga53d443eaba00cc8255d4d1dd7dc3de79"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFloorF_NN" ref="ga53d443eaba00cc8255d4d1dd7dc3de79" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFloorF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb35318b9e872a8d4d86d9c795d368b2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFracD_NN" ref="gaeb35318b9e872a8d4d86d9c795d368b2" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFracD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga772400768495fd4fd693256ad3c48f33"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorFracF_NN" ref="ga772400768495fd4fd693256ad3c48f33" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorFracF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4beba0c36335d94c6c76b9a16aaee33f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_N1N" ref="ga4beba0c36335d94c6c76b9a16aaee33f" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadefa93b1fb00f994acaf717eb876f05b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_NN1" ref="gadefa93b1fb00f994acaf717eb876f05b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga400b8712d0ef2f7222022e3030ab65d5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotD_NNN" ref="ga400b8712d0ef2f7222022e3030ab65d5" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0893c32e31d72a7e91badc4abf62b3b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_N1N" ref="gaf0893c32e31d72a7e91badc4abf62b3b" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga939e06569593c806d533ea61e4b98327"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_NN1" ref="ga939e06569593c806d533ea61e4b98327" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabff48d9f05d09c6fc3024f2095a91630"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorHypotF_NNN" ref="gabff48d9f05d09c6fc3024f2095a91630" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorHypotF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1670474c385d41d06a26038f799c0fa"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIncD_NN" ref="gae1670474c385d41d06a26038f799c0fa" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIncD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_IncD() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_IncD() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab729d40e2054d2fb7181f18a608d160c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIncF_NN" ref="gab729d40e2054d2fb7181f18a608d160c" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIncF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_IncF() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_IncF() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecf5045346456bfbfc963dd6c062dd41"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIncI_NN" ref="gaecf5045346456bfbfc963dd6c062dd41" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIncI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_IncI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_IncI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13ec881fafbc63ad1c70efdf3950f25d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIncLL_NN" ref="ga13ec881fafbc63ad1c70efdf3950f25d" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIncLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_IncLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_IncLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga743930b4ab02ddcecf4cf1bec9520203"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIncS_NN" ref="ga743930b4ab02ddcecf4cf1bec9520203" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIncS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_IncS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_IncS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaced300febadf01a9bb061b2eb55b4c82"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_N1N" ref="gaced300febadf01a9bb061b2eb55b4c82" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b41819ebe1d49fbf7fcea593eea1585"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_NN1" ref="ga6b41819ebe1d49fbf7fcea593eea1585" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6557cbdeb7309d19bb44c69a8b68ac5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToD_NNN" ref="gaa6557cbdeb7309d19bb44c69a8b68ac5" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedb79426fa90a29103fce022679f32f4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_N1N" ref="gaedb79426fa90a29103fce022679f32f4" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf88f51bb6a26c2d0a68e994d863711c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_NN1" ref="gacf88f51bb6a26c2d0a68e994d863711c" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5cbc606bff150d3be2e698aac7dc5ce4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToF_NNN" ref="ga5cbc606bff150d3be2e698aac7dc5ce4" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf54043e6451bc7d8186546bd9a24400"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToI_N1N" ref="gabf54043e6451bc7d8186546bd9a24400" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsEqualToI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga85097a2dde0bb7f2a99f8c8a9db2017d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToI_NN1" ref="ga85097a2dde0bb7f2a99f8c8a9db2017d" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsEqualToI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12b5f5ed8f5faacb1698b02b0ced8803"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToI_NNN" ref="ga12b5f5ed8f5faacb1698b02b0ced8803" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsEqualToI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac55ebbe428b1f8a585fa7bbc88346655"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToLL_N1N" ref="gac55ebbe428b1f8a585fa7bbc88346655" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsEqualToLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga261be999c41717bae31ecd4cc204f3fc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToLL_NN1" ref="ga261be999c41717bae31ecd4cc204f3fc" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsEqualToLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b38f070771288c84d2abe662a43ed74"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToLL_NNN" ref="ga8b38f070771288c84d2abe662a43ed74" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsEqualToLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga877613416df450a45f2c48382b21d750"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToS_N1N" ref="ga877613416df450a45f2c48382b21d750" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsEqualToS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d7f3f26ced00fc20e47e849a3eca607"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToS_NN1" ref="ga8d7f3f26ced00fc20e47e849a3eca607" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsEqualToS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5bc51f492d94941c6f1c4313e06c8da1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsEqualToS_NNN" ref="ga5bc51f492d94941c6f1c4313e06c8da1" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsEqualToS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsEqualToS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsEqualToS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75e868cbab5a492e1daebf106fe89d64"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_N1N" ref="ga75e868cbab5a492e1daebf106fe89d64" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fb9c4d06a6d72de5ce40804ff346460"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_NN1" ref="ga5fb9c4d06a6d72de5ce40804ff346460" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga742971fee5ae052c2cb95a9955cf7542"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanD_NNN" ref="ga742971fee5ae052c2cb95a9955cf7542" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ff4eb184fe6458d583af93f5f5d72a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_N1N" ref="ga7ff4eb184fe6458d583af93f5f5d72a3" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3298d662a1a1002f1a911cf89576f12e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_NN1" ref="ga3298d662a1a1002f1a911cf89576f12e" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6030e695b7b354d7c668506b6dd8777e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanF_NNN" ref="ga6030e695b7b354d7c668506b6dd8777e" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f40eefc4ad028776f5179adc23b781f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanI_N1N" ref="ga6f40eefc4ad028776f5179adc23b781f" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga869265fec66535f6495bfca6ff0b4eeb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanI_NN1" ref="ga869265fec66535f6495bfca6ff0b4eeb" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b93d6d5fecbb723deb872f42681a986"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanI_NNN" ref="ga3b93d6d5fecbb723deb872f42681a986" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7b42f129ab4bf418e7993d979150699"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanLL_N1N" ref="gaa7b42f129ab4bf418e7993d979150699" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ee194bb35cb350379605f79f401593f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanLL_NN1" ref="ga1ee194bb35cb350379605f79f401593f" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab0cf0886fd1c306973af56623196996"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanLL_NNN" ref="gaab0cf0886fd1c306973af56623196996" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1b670f32504cfee3765b6f7aec16a60"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_N1N" ref="gaf1b670f32504cfee3765b6f7aec16a60" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09d06ce6f60c7093743530f7340d0db3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_NN1" ref="ga09d06ce6f60c7093743530f7340d0db3" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5db5ae33ecc38702db1987d7f58003d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToD_NNN" ref="gad5db5ae33ecc38702db1987d7f58003d" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9563d0b877e5656f9e68dbe1f172b1c2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_N1N" ref="ga9563d0b877e5656f9e68dbe1f172b1c2" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c70aa006400c76931250bdcccf52e37"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_NN1" ref="ga5c70aa006400c76931250bdcccf52e37" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34dbb414e4e85a5dc21cab04efb36e17"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToF_NNN" ref="ga34dbb414e4e85a5dc21cab04efb36e17" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga88785aac3d4d61bf59e3f5aba4ab1c6b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToI_N1N" ref="ga88785aac3d4d61bf59e3f5aba4ab1c6b" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanOrEqualToI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab37bd644419a8dddf3e8e25ef1622a57"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToI_NN1" ref="gab37bd644419a8dddf3e8e25ef1622a57" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanOrEqualToI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe386fb77c3733df1b72da24d39987ac"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToI_NNN" ref="gabe386fb77c3733df1b72da24d39987ac" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanOrEqualToI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga47ff8793050f5387e8e24320f75ef159"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToLL_N1N" ref="ga47ff8793050f5387e8e24320f75ef159" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanOrEqualToLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50181d615f41745f708047d4f8ce0b14"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToLL_NN1" ref="ga50181d615f41745f708047d4f8ce0b14" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanOrEqualToLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7b2456843dd954b646fe8e0334577f8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToLL_NNN" ref="gaf7b2456843dd954b646fe8e0334577f8" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanOrEqualToLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4939f89237d6a48266fca0ed0530fbc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToS_N1N" ref="gaa4939f89237d6a48266fca0ed0530fbc" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanOrEqualToS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga130276378ce6235bac6832232c4918f4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToS_NN1" ref="ga130276378ce6235bac6832232c4918f4" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanOrEqualToS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga170f7ff35e5f45c26e6064d642b31e1a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanOrEqualToS_NNN" ref="ga170f7ff35e5f45c26e6064d642b31e1a" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanOrEqualToS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanOrEqualToS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanOrEqualToS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae638bb12613f562a45c12c41f9e5db50"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanS_N1N" ref="gae638bb12613f562a45c12c41f9e5db50" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsGreaterThanS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73dc7a3aa83c3cfb095761e96faf5ee6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanS_NN1" ref="ga73dc7a3aa83c3cfb095761e96faf5ee6" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsGreaterThanS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c1571089e66fad788ede26e8a9a0f97"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsGreaterThanS_NNN" ref="ga3c1571089e66fad788ede26e8a9a0f97" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsGreaterThanS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsGreaterThanS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsGreaterThanS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f91ec7596d951ef68b47e277ef6c5ba"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_N1N" ref="ga3f91ec7596d951ef68b47e277ef6c5ba" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7eb97b849367dd8a0b92c4e4cdffe983"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_NN1" ref="ga7eb97b849367dd8a0b92c4e4cdffe983" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga991f8dd0bbc5c9dfca56eb70e2139dfe"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanD_NNN" ref="ga991f8dd0bbc5c9dfca56eb70e2139dfe" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98ef2362c8ee3b97169746404863b0bb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_N1N" ref="ga98ef2362c8ee3b97169746404863b0bb" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada27b912481be2974f2df10287c24cca"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_NN1" ref="gada27b912481be2974f2df10287c24cca" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc1473081b72235572bbcb4180f85532"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanF_NNN" ref="gafc1473081b72235572bbcb4180f85532" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3633d60d514829d578e49362bb456d33"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanI_N1N" ref="ga3633d60d514829d578e49362bb456d33" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa6ae8d351738646edd0e6683460ca86"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanI_NN1" ref="gaaa6ae8d351738646edd0e6683460ca86" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga504386875fab2214b6520e995b71b3fc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanI_NNN" ref="ga504386875fab2214b6520e995b71b3fc" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca5df71805cf447e6b511fa7823ae44b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanLL_N1N" ref="gaca5df71805cf447e6b511fa7823ae44b" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b39658fb221c92c5617ce946262de2c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanLL_NN1" ref="ga3b39658fb221c92c5617ce946262de2c" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab29d403f88a018cdc6a8ed7fb801ba16"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanLL_NNN" ref="gab29d403f88a018cdc6a8ed7fb801ba16" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga883e9677cffce2e7a385c048c0cf6051"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_N1N" ref="ga883e9677cffce2e7a385c048c0cf6051" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae14f26d0d6c23b301370264f5d2f5820"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_NN1" ref="gae14f26d0d6c23b301370264f5d2f5820" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75601e89fa96c2711c9c1d762bd26633"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToD_NNN" ref="ga75601e89fa96c2711c9c1d762bd26633" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9b4e616e12b4510ed11658d46985b6d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_N1N" ref="gaa9b4e616e12b4510ed11658d46985b6d" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f64176207c3d68ae22cddb34d496266"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_NN1" ref="ga5f64176207c3d68ae22cddb34d496266" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae336bfe2cf955934a4cee32d66b4817e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToF_NNN" ref="gae336bfe2cf955934a4cee32d66b4817e" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08535f65b8428eb8476773ab6381764e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToI_N1N" ref="ga08535f65b8428eb8476773ab6381764e" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanOrEqualToI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7248c7f18dc9e0c220408967056150bd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToI_NN1" ref="ga7248c7f18dc9e0c220408967056150bd" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanOrEqualToI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1437a8cb597e5278da4821d0084483fe"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToI_NNN" ref="ga1437a8cb597e5278da4821d0084483fe" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanOrEqualToI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga988bda519b884018b312990b58c15e93"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToLL_N1N" ref="ga988bda519b884018b312990b58c15e93" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanOrEqualToLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad79b9f3693432646389e1ede8bee2fea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToLL_NN1" ref="gad79b9f3693432646389e1ede8bee2fea" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanOrEqualToLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f29b12f4df2237e9b833c97f04b1981"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToLL_NNN" ref="ga0f29b12f4df2237e9b833c97f04b1981" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanOrEqualToLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga129554dbe9192e52946f0c3392100848"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToS_N1N" ref="ga129554dbe9192e52946f0c3392100848" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanOrEqualToS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga335af27f1920b47ca0ff18aff400f6fa"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToS_NN1" ref="ga335af27f1920b47ca0ff18aff400f6fa" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanOrEqualToS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab46c18d16475d7e770109d15a5ac839a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanOrEqualToS_NNN" ref="gab46c18d16475d7e770109d15a5ac839a" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanOrEqualToS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanOrEqualToS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanOrEqualToS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02226c77b2e38a7b604ab35088fe44fc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanS_N1N" ref="ga02226c77b2e38a7b604ab35088fe44fc" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsLessThanS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73770af53fc9f3f36072b79a1e1c2092"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanS_NN1" ref="ga73770af53fc9f3f36072b79a1e1c2092" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsLessThanS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86295dbb41c9f8706227160afff8e18a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsLessThanS_NNN" ref="ga86295dbb41c9f8706227160afff8e18a" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsLessThanS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsLessThanS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsLessThanS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc43628c757ac7fbf663ecf1d09aa5a7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_N1N" ref="gacc43628c757ac7fbf663ecf1d09aa5a7" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga427f715543dfb78fa061b1da9ae2f34c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_NN1" ref="ga427f715543dfb78fa061b1da9ae2f34c" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4fb086ed252f0f5f8504088cf286ed35"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToD_NNN" ref="ga4fb086ed252f0f5f8504088cf286ed35" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56a9fe4ef33f7d81a29e7aab0a1592c0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_N1N" ref="ga56a9fe4ef33f7d81a29e7aab0a1592c0" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga774c6a0e634df1f397516a6a805a4d6d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_NN1" ref="ga774c6a0e634df1f397516a6a805a4d6d" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9a46a8c1db7476211bdd6b44fb19d49"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToF_NNN" ref="gae9a46a8c1db7476211bdd6b44fb19d49" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae87c2ba26f4fd9ed769f73d9c70a604b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToI_N1N" ref="gae87c2ba26f4fd9ed769f73d9c70a604b" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsNotEqualToI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8effb02c79b6654af2076feb714b643d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToI_NN1" ref="ga8effb02c79b6654af2076feb714b643d" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsNotEqualToI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf03ecaddf9f5540898ea025e0c608191"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToI_NNN" ref="gaf03ecaddf9f5540898ea025e0c608191" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsNotEqualToI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga48345058d66d98c680c3b11ab55c4701"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToLL_N1N" ref="ga48345058d66d98c680c3b11ab55c4701" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsNotEqualToLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga906550c07fdd9897abbd3d9d8e8617c6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToLL_NN1" ref="ga906550c07fdd9897abbd3d9d8e8617c6" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsNotEqualToLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7b6a85fe384903679ead8d6b1c372b0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToLL_NNN" ref="gad7b6a85fe384903679ead8d6b1c372b0" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsNotEqualToLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65c91b478f8ed90e1eb256c3788e9f0b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToS_N1N" ref="ga65c91b478f8ed90e1eb256c3788e9f0b" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_IsNotEqualToS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac5d7d59b906081c8205d652cf750ade5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToS_NN1" ref="gac5d7d59b906081c8205d652cf750ade5" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_IsNotEqualToS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e074461824fde3c932fd4ad588937ea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorIsNotEqualToS_NNN" ref="ga7e074461824fde3c932fd4ad588937ea" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorIsNotEqualToS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_IsNotEqualToS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_IsNotEqualToS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81e869fd2297a6c57b5e3a312fc33b74"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineD_N11" ref="ga81e869fd2297a6c57b5e3a312fc33b74" args="(PlankD *result, PlankD a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineD_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga5af8b83ed87be0faee019340b9cc07a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineF_N11" ref="ga5af8b83ed87be0faee019340b9cc07a3" args="(PlankF *result, PlankF a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineF_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga705d29301461f04ed2372724ad86281d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineI_N11" ref="ga705d29301461f04ed2372724ad86281d" args="(PlankI *result, PlankI a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineI_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="gae2c3c99f8fbee8b93d48f299c87c3b77"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineLL_N11" ref="gae2c3c99f8fbee8b93d48f299c87c3b77" args="(PlankLL *result, PlankLL a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineLL_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga5566bc4aebe7465359cac138ea6f45fd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLineS_N11" ref="ga5566bc4aebe7465359cac138ea6f45fd" args="(PlankS *result, PlankS a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLineS_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a line. </p>
<p>The vector will start at value <em>a</em> and end at <em>b</em>. </p>

</div>
</div>
<a class="anchor" id="ga1a5902d66076b7527b8ca6a674fef22e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog10D_NN" ref="ga1a5902d66076b7527b8ca6a674fef22e" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog10D_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5680198a0c9c769ad052a505769d8e65"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog10F_NN" ref="ga5680198a0c9c769ad052a505769d8e65" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog10F_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f77253685ccd08349ad129a0bc09a23"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog2D_NN" ref="ga2f77253685ccd08349ad129a0bc09a23" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog2D_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f8cf6b2f7fa17fb800ff0e1d5a2e167"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLog2F_NN" ref="ga6f8cf6b2f7fa17fb800ff0e1d5a2e167" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLog2F_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b06f007387aeffb3ebd2214f5090fb8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLogD_NN" ref="ga3b06f007387aeffb3ebd2214f5090fb8" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLogD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6154ea39d75e68b9e9d5330cb3625eec"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLogF_NN" ref="ga6154ea39d75e68b9e9d5330cb3625eec" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLogF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadaaf12325ee661c80ccc2c3a227ddf5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupD_NnN" ref="gadaaf12325ee661c80ccc2c3a227ddf5d" args="(PlankD *result, PlankD *table, PlankUL n, PlankD *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupD_NnN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaddee28f3d1f630066c181c8a6ac97aea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupF_NnN" ref="gaddee28f3d1f630066c181c8a6ac97aea" args="(PlankF *result, PlankF *table, PlankUL n, PlankF *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupF_NnN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb45f8a65457b0a774d4aaf3b01c963f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupI_NnN" ref="gabb45f8a65457b0a774d4aaf3b01c963f" args="(PlankI *result, PlankI *table, PlankUL n, PlankI *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupI_NnN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab03ed8477a6d6e9cf6583d2695ada1d7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupLL_NnN" ref="gab03ed8477a6d6e9cf6583d2695ada1d7" args="(PlankLL *result, PlankLL *table, PlankUL n, PlankLL *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupLL_NnN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga376c98f4e041eba57e3a8289c5e6d705"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorLookupS_NnN" ref="ga376c98f4e041eba57e3a8289c5e6d705" args="(PlankS *result, PlankS *table, PlankUL n, PlankS *index, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorLookupS_NnN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a vector by using another vector as the indices into a lookup table. </p>
<p>Fractional indices are used to interpolate between value in the lookup table. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vectir </td></tr>
    <tr><td class="paramname">table</td><td>A look up table. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the lookup table. </td></tr>
    <tr><td class="paramname">index</td><td>A vector containing the indices. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the output and index vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08b1418b75b12da60a96a514008a3e2d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorM2FD_NN" ref="ga08b1418b75b12da60a96a514008a3e2d" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorM2FD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga434579ecb8b69a86b3c1b5e19640d3e9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorM2FF_NN" ref="ga434579ecb8b69a86b3c1b5e19640d3e9" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorM2FF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad687be0c0ca10457b0d9ea29d3e737c2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_N1N" ref="gad687be0c0ca10457b0d9ea29d3e737c2" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafdcc887ab924c442c0496cd98cb8bf08"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_NN1" ref="gafdcc887ab924c442c0496cd98cb8bf08" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab73fa94aad3f3a9ea9b4281fa2a45637"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxD_NNN" ref="gab73fa94aad3f3a9ea9b4281fa2a45637" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaabafa18c8dd0ec2c12e11b6f42cc2493"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_N1N" ref="gaabafa18c8dd0ec2c12e11b6f42cc2493" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e548c19fcaaa84dc28e05af2b4cd88a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_NN1" ref="ga2e548c19fcaaa84dc28e05af2b4cd88a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ee95f778cdfcd034e902fb81f7c885"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxF_NNN" ref="gad8ee95f778cdfcd034e902fb81f7c885" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7780e6326d8ad2f84f8498772a948d33"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxI_N1N" ref="ga7780e6326d8ad2f84f8498772a948d33" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MaxI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga862debd0eee430139e5a902f00e30718"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxI_NN1" ref="ga862debd0eee430139e5a902f00e30718" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MaxI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea32edfdbcfc5403897bc33fe329bc97"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxI_NNN" ref="gaea32edfdbcfc5403897bc33fe329bc97" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MaxI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa317765828b6f2ac5513f43199f9e548"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxLL_N1N" ref="gaa317765828b6f2ac5513f43199f9e548" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MaxLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c9af5446cea35b78b61799b52531fbd"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxLL_NN1" ref="ga0c9af5446cea35b78b61799b52531fbd" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MaxLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac46bf6babbe74e5bdb39d00c4399305a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxLL_NNN" ref="gac46bf6babbe74e5bdb39d00c4399305a" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MaxLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66cd65b6f9e5f70ddecfc7b3eb40f9b0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxS_N1N" ref="ga66cd65b6f9e5f70ddecfc7b3eb40f9b0" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MaxS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77e7886046cd4656a0cceb8def0d7787"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxS_NN1" ref="ga77e7886046cd4656a0cceb8def0d7787" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MaxS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad339bb52af31adb0689e19a6c8723cd1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMaxS_NNN" ref="gad339bb52af31adb0689e19a6c8723cd1" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMaxS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MaxS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MaxS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09f665f6b1bddb3bd7669410e10b3c02"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_N1N" ref="ga09f665f6b1bddb3bd7669410e10b3c02" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga750a9c78d6f4857c73ab1ee9cdbd65ad"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_NN1" ref="ga750a9c78d6f4857c73ab1ee9cdbd65ad" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3267ac92b409d85e0f1195214d19bcf1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinD_NNN" ref="ga3267ac92b409d85e0f1195214d19bcf1" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8dd296051688e3035e6d0f7dff95c2ab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_N1N" ref="ga8dd296051688e3035e6d0f7dff95c2ab" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3a514ff8c829f3f0c34cc3cb8532fa9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_NN1" ref="gaa3a514ff8c829f3f0c34cc3cb8532fa9" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa31eb103c9cb1b7af8ec1d68940fc816"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinF_NNN" ref="gaa31eb103c9cb1b7af8ec1d68940fc816" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf7c1aadac9149ac376d63d127bb0045"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinI_N1N" ref="gadf7c1aadac9149ac376d63d127bb0045" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MinI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5172fcc25519762ad7554e452e4bde5a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinI_NN1" ref="ga5172fcc25519762ad7554e452e4bde5a" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MinI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga16971d35d0936a4db500931541d87d21"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinI_NNN" ref="ga16971d35d0936a4db500931541d87d21" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MinI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac92176b8931e56802485832a309eef92"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinLL_N1N" ref="gac92176b8931e56802485832a309eef92" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MinLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga021f6b8f8cba03bfa196ceb0b924b746"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinLL_NN1" ref="ga021f6b8f8cba03bfa196ceb0b924b746" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MinLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09090ecf8370a76224afb6c6d6f100a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinLL_NNN" ref="ga09090ecf8370a76224afb6c6d6f100a3" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MinLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a38e5ae72a77b438a13eb442fe1ee5e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinS_N1N" ref="ga3a38e5ae72a77b438a13eb442fe1ee5e" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MinS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae33e469642fc0e60fdcb517c8fae142"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinS_NN1" ref="gaae33e469642fc0e60fdcb517c8fae142" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MinS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5010e97ebb5584f80f165df0f311b46e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMinS_NNN" ref="ga5010e97ebb5584f80f165df0f311b46e" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMinS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MinS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MinS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63b81cfbb45a3881e871ef96d37628a4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModD_N1N" ref="ga63b81cfbb45a3881e871ef96d37628a4" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad14a5010bd1ffa6a68aafee2545b5c79"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModD_NN1" ref="gad14a5010bd1ffa6a68aafee2545b5c79" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace2aecd293f599cf3e56551bf714bf9d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModD_NNN" ref="gace2aecd293f599cf3e56551bf714bf9d" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6378931d67f09df9021038a3be54d538" title="Returns .">pl_ModD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga621b50c48f2e6d362bd2b43496e98dff"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModF_N1N" ref="ga621b50c48f2e6d362bd2b43496e98dff" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad14414a6a6bfdce2cfa4b12194fac85b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModF_NN1" ref="gad14414a6a6bfdce2cfa4b12194fac85b" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga579144bf7c19e2c3076ace200ffdf6c4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModF_NNN" ref="ga579144bf7c19e2c3076ace200ffdf6c4" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaeafd3ee471f776684b02b44acb6cfbb8" title="Returns .">pl_ModF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga21b7e290ac5222277869c93e78f000a2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModI_N1N" ref="ga21b7e290ac5222277869c93e78f000a2" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ModI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga994d471cd7f98bbda4c66492c1e651b2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModI_NN1" ref="ga994d471cd7f98bbda4c66492c1e651b2" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ModI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54343015ebbb345e738e5b28f917eaf3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModI_NNN" ref="ga54343015ebbb345e738e5b28f917eaf3" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ModI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3489d1f12dc47168d411d5327db49b3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModLL_N1N" ref="gaf3489d1f12dc47168d411d5327db49b3" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ModLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b7221a44434f169a28ba01233187747"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModLL_NN1" ref="ga9b7221a44434f169a28ba01233187747" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ModLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe5b172f36f5dcad41b333136374096c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModLL_NNN" ref="gafe5b172f36f5dcad41b333136374096c" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ModLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ffa4533c17c0e627d0ebbea66cff597"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModS_N1N" ref="ga8ffa4533c17c0e627d0ebbea66cff597" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ModS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68a73151d459bd844bab8b31f2d51d2d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModS_NN1" ref="ga68a73151d459bd844bab8b31f2d51d2d" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ModS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0f002b56f72128ed5b3c712261aa021"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorModS_NNN" ref="gae0f002b56f72128ed5b3c712261aa021" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorModS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ModS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ModS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92916e1daf6e82d9404d525e42389b45"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveD_NN" ref="ga92916e1daf6e82d9404d525e42389b45" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6afd6f38943e06da5514a63e90c0faf9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveF_NN" ref="ga6afd6f38943e06da5514a63e90c0faf9" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19a61afeeff8a96a1154b152cc75f68e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveI_NN" ref="ga19a61afeeff8a96a1154b152cc75f68e" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_MoveI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_MoveI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae919da82c0ae9d389e57e742c0de4591"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveLL_NN" ref="gae919da82c0ae9d389e57e742c0de4591" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_MoveLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_MoveLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00116a2ca2d53876d5c515da4c8c49df"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMoveS_NN" ref="ga00116a2ca2d53876d5c515da4c8c49df" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMoveS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_MoveS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_MoveS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c953ed08f1a81c89806bdd6f8cf36c3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NN11" ref="ga2c953ed08f1a81c89806bdd6f8cf36c3" args="(PlankD *result, const PlankD *input, PlankD mul, PlankD add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NN11 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab19f04fdfabafac14d7d57c621efa008"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NN1N" ref="gab19f04fdfabafac14d7d57c621efa008" args="(PlankD *result, const PlankD *input, PlankD mul, const PlankD *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NN1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f1ffab901ada34b727346e72b700627"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NNN" ref="ga4f1ffab901ada34b727346e72b700627" args="(PlankD *io, const PlankD *mul, const PlankD *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io \times mul + add $" src="form_21.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7ad2ae5fd9ec33bf7bbb4f1efaa4f5a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NNN1" ref="gac7ad2ae5fd9ec33bf7bbb4f1efaa4f5a" args="(PlankD *result, const PlankD *input, const PlankD *mul, PlankD add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NNN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14330dd55c25b72733f3ca804e440593"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddD_NNNN" ref="ga14330dd55c25b72733f3ca804e440593" args="(PlankD *result, const PlankD *input, const PlankD *mul, const PlankD *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddD_NNNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result = input \times mul + add $" src="form_20.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector. </td></tr>
    <tr><td class="paramname">input</td><td>The input vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e5e2f38c733b4356204d138b71f5848"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NN11" ref="ga2e5e2f38c733b4356204d138b71f5848" args="(PlankF *result, const PlankF *input, PlankF mul, PlankF add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NN11 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08e933eccaf66c8adb57e9841657a6fb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NN1N" ref="ga08e933eccaf66c8adb57e9841657a6fb" args="(PlankF *result, const PlankF *input, PlankF mul, const PlankF *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NN1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9877065544b3718d8d187d5f50cdf24"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NNN" ref="gad9877065544b3718d8d187d5f50cdf24" args="(PlankF *io, const PlankF *mul, const PlankF *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io \times mul + add $" src="form_21.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5c97c3f119c8f60b3ddde9eac596e38"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NNN1" ref="gaf5c97c3f119c8f60b3ddde9eac596e38" args="(PlankF *result, const PlankF *input, const PlankF *mul, PlankF add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NNN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga440a2f45ad5a555ed44a4e227a132a2a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddF_NNNN" ref="ga440a2f45ad5a555ed44a4e227a132a2a" args="(PlankF *result, const PlankF *input, const PlankF *mul, const PlankF *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddF_NNNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result = input \times mul + add $" src="form_20.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector. </td></tr>
    <tr><td class="paramname">input</td><td>The input vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf5b8d44f0f632e92508d099181ba954"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddI_NN11" ref="gacf5b8d44f0f632e92508d099181ba954" args="(PlankI *result, const PlankI *input, PlankI mul, PlankI add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddI_NN11 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac94c1021ef7c7eae685f1dcc5d7cef5a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddI_NN1N" ref="gac94c1021ef7c7eae685f1dcc5d7cef5a" args="(PlankI *result, const PlankI *input, PlankI mul, const PlankI *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddI_NN1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03810df23c537596e82c9dc719c7b25c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddI_NNN" ref="ga03810df23c537596e82c9dc719c7b25c" args="(PlankI *io, const PlankI *mul, const PlankI *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io \times mul + add $" src="form_21.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8adb8adb81422b2aaeb1f3b7b8a7beae"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddI_NNN1" ref="ga8adb8adb81422b2aaeb1f3b7b8a7beae" args="(PlankI *result, const PlankI *input, const PlankI *mul, PlankI add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddI_NNN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4aaa634f9d9a0c565489c4d87bd0c2d4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddI_NNNN" ref="ga4aaa634f9d9a0c565489c4d87bd0c2d4" args="(PlankI *result, const PlankI *input, const PlankI *mul, const PlankI *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddI_NNNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result = input \times mul + add $" src="form_20.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector. </td></tr>
    <tr><td class="paramname">input</td><td>The input vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a6c37f8ad3cf89475953b21a9a0a246"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddLL_NN11" ref="ga0a6c37f8ad3cf89475953b21a9a0a246" args="(PlankLL *result, const PlankLL *input, PlankLL mul, PlankLL add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddLL_NN11 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7fe17b73495151acf1ca13ff12a4570"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddLL_NN1N" ref="gaf7fe17b73495151acf1ca13ff12a4570" args="(PlankLL *result, const PlankLL *input, PlankLL mul, const PlankLL *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddLL_NN1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed08064190f52acea2c3a812b925c83c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddLL_NNN" ref="gaed08064190f52acea2c3a812b925c83c" args="(PlankLL *io, const PlankLL *mul, const PlankLL *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io \times mul + add $" src="form_21.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3284e0da05b20dff4f322cce0772771"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddLL_NNN1" ref="gae3284e0da05b20dff4f322cce0772771" args="(PlankLL *result, const PlankLL *input, const PlankLL *mul, PlankLL add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddLL_NNN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga589741aab3233ccabb9e7072147820a6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddLL_NNNN" ref="ga589741aab3233ccabb9e7072147820a6" args="(PlankLL *result, const PlankLL *input, const PlankLL *mul, const PlankLL *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddLL_NNNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result = input \times mul + add $" src="form_20.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector. </td></tr>
    <tr><td class="paramname">input</td><td>The input vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15fe29c7893af841caa7a26db4f88f14"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddS_NN11" ref="ga15fe29c7893af841caa7a26db4f88f14" args="(PlankS *result, const PlankS *input, PlankS mul, PlankS add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddS_NN11 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfef4b4020df252bed7ab3b0c2e7eda9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddS_NN1N" ref="gacfef4b4020df252bed7ab3b0c2e7eda9" args="(PlankS *result, const PlankS *input, PlankS mul, const PlankS *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddS_NN1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A scalar to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7642e45155d214535356262de614a08"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddS_NNN" ref="gad7642e45155d214535356262de614a08" args="(PlankS *io, const PlankS *mul, const PlankS *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ io = io \times mul + add $" src="form_21.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0dcb95b6f83778b7159a7896105144a1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddS_NNN1" ref="ga0dcb95b6f83778b7159a7896105144a1" args="(PlankS *result, const PlankS *input, const PlankS *mul, PlankS add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddS_NNN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result= input \times mul + add $" src="form_22.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>The input and output vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A scalar to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab60a1ee99ca08001622da70ed098ee1c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulAddS_NNNN" ref="gab60a1ee99ca08001622da70ed098ee1c" args="(PlankS *result, const PlankS *input, const PlankS *mul, const PlankS *add, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulAddS_NNNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the multiply and add operator to a set of vectors. </p>
<p><img class="formulaInl" alt="$ result = input \times mul + add $" src="form_20.png"/> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector. </td></tr>
    <tr><td class="paramname">input</td><td>The input vector. </td></tr>
    <tr><td class="paramname">mul</td><td>A vector containing the value to multiply the input by. </td></tr>
    <tr><td class="paramname">add</td><td>A vector containing the value to add after the multiply. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5e80360d5aae32ecddfba037c215af8"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_N1N" ref="gaf5e80360d5aae32ecddfba037c215af8" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1bc824231e441539c1ee7df8b50e0391"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_NN1" ref="ga1bc824231e441539c1ee7df8b50e0391" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49295bf725772df3865b0fe99be4552e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulD_NNN" ref="ga49295bf725772df3865b0fe99be4552e" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga044d16cfcf2eda7978a038ca4a156144"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_N1N" ref="ga044d16cfcf2eda7978a038ca4a156144" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d02adf1b7e3387b882aee06bf794bab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_NN1" ref="ga4d02adf1b7e3387b882aee06bf794bab" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09b89f66bb8148bc4d7f3ade8f12ab6b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulF_NNN" ref="ga09b89f66bb8148bc4d7f3ade8f12ab6b" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51687633d036d694c1114f91921401ea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulI_N1N" ref="ga51687633d036d694c1114f91921401ea" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MulI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac136990a6cd21e5c31deeaa1852197e7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulI_NN1" ref="gac136990a6cd21e5c31deeaa1852197e7" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MulI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga960849b807b6166c4e8976b90e3c8b2e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulI_NNN" ref="ga960849b807b6166c4e8976b90e3c8b2e" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MulI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab16f182cb89172200a782f63a6d2cbf5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulLL_N1N" ref="gab16f182cb89172200a782f63a6d2cbf5" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MulLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20621a1f0b38d5b2df604193d3543e8c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulLL_NN1" ref="ga20621a1f0b38d5b2df604193d3543e8c" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MulLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a5eb14af645d390eca7fb821c5e8de7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulLL_NNN" ref="ga0a5eb14af645d390eca7fb821c5e8de7" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MulLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga47cbc0ea3f7025b6db2363260b65c376"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulS_N1N" ref="ga47cbc0ea3f7025b6db2363260b65c376" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_MulS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga824042c1cfc121c193b50054bc07bd41"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulS_NN1" ref="ga824042c1cfc121c193b50054bc07bd41" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_MulS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab8fbe29a984ac0c0f14cbc2754fff47"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorMulS_NNN" ref="gaab8fbe29a984ac0c0f14cbc2754fff47" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorMulS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_MulS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_MulS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad49e011e4ca3f76de0b8ec5c1d6d81e6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegD_NN" ref="gad49e011e4ca3f76de0b8ec5c1d6d81e6" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e8bc51e352f9e56102e8a6f8e591369"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegF_NN" ref="ga3e8bc51e352f9e56102e8a6f8e591369" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ebcc3f3b711bebbf8dbcb99defdb676"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegI_NN" ref="ga4ebcc3f3b711bebbf8dbcb99defdb676" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_NegI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_NegI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1fda3af654ab09d3838e9c5bf714c012"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegLL_NN" ref="ga1fda3af654ab09d3838e9c5bf714c012" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_NegLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_NegLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac062955a30c1d9c9b76cab1a485b8864"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorNegS_NN" ref="gac062955a30c1d9c9b76cab1a485b8864" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorNegS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_NegS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_NegS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9296c3251eb6571e43019400f83c765c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_N1N" ref="ga9296c3251eb6571e43019400f83c765c" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b253f22b62b7117f6af0c31abfd6c07"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_NN1" ref="ga4b253f22b62b7117f6af0c31abfd6c07" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3373906398e94de141273acb0d6390c9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowD_NNN" ref="ga3373906398e94de141273acb0d6390c9" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96c1025337d92429c8734e175143f1f7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_N1N" ref="ga96c1025337d92429c8734e175143f1f7" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga483ff2d8bea2cdeec487db5efffa3d3a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_NN1" ref="ga483ff2d8bea2cdeec487db5efffa3d3a" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf3b8ea80497eeec187a20e7e2848ed7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorPowF_NNN" ref="gadf3b8ea80497eeec187a20e7e2848ed7" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorPowF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa22058ab0b84dd204cd0818f7eee4e71"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorR2DD_NN" ref="gaa22058ab0b84dd204cd0818f7eee4e71" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorR2DD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafdc0d266ab2c818ebf03503c1f1d0044"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorR2DF_NN" ref="gafdc0d266ab2c818ebf03503c1f1d0044" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorR2DF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac60fec7cc8a88e48270833135205ec12"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampD_N11" ref="gac60fec7cc8a88e48270833135205ec12" args="(PlankD *result, PlankD a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampD_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga6083cf8cd3b19b6617c85b81dac22355"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampF_N11" ref="ga6083cf8cd3b19b6617c85b81dac22355" args="(PlankF *result, PlankF a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampF_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga42061b10abbe6849bfac21fe6f1ce766"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampI_N11" ref="ga42061b10abbe6849bfac21fe6f1ce766" args="(PlankI *result, PlankI a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampI_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="gab31c67648781b10b85c3b8aed2979034"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampLL_N11" ref="gab31c67648781b10b85c3b8aed2979034" args="(PlankLL *result, PlankLL a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampLL_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga6d653556d9a1ce44e17e7551dd2e5343"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorRampS_N11" ref="ga6d653556d9a1ce44e17e7551dd2e5343" args="(PlankS *result, PlankS a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorRampS_N11 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a vector with a ramp. </p>
<p>The vector will start at value <em>a</em> and increment by <em>b</em> for each item in the vector. </p>

</div>
</div>
<a class="anchor" id="ga88f1c17c13d19ff647a659e21164ec91"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorReciprocalD_NN" ref="ga88f1c17c13d19ff647a659e21164ec91" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorReciprocalD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf552c917a97a8370eb14d70fa7fdbcd4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorReciprocalF_NN" ref="gaf552c917a97a8370eb14d70fa7fdbcd4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorReciprocalF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35254ed489bf9f5825bac6d353d80eac"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignD_NN" ref="ga35254ed489bf9f5825bac6d353d80eac" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga017d16bd185ae3cf9069e06cc9c2cf88"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignF_NN" ref="ga017d16bd185ae3cf9069e06cc9c2cf88" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03a44b0015a08f810263508243ad0d4e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignI_NN" ref="ga03a44b0015a08f810263508243ad0d4e" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SignI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SignI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf3e9d4da884a902b4996935d9f0376fc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignLL_NN" ref="gaf3e9d4da884a902b4996935d9f0376fc" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SignLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SignLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d7b93f02c29d5ff9792082a646d4736"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSignS_NN" ref="ga6d7b93f02c29d5ff9792082a646d4736" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSignS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SignS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SignS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab78a731a99877c501f2531b263ed0ff7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinD_NN" ref="gab78a731a99877c501f2531b263ed0ff7" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8317e0ece295c3fe4c6ddcd0c9291b73"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinF_NN" ref="ga8317e0ece295c3fe4c6ddcd0c9291b73" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebafcf0bf05dade5b95bf6066808f623"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinhD_NN" ref="gaebafcf0bf05dade5b95bf6066808f623" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinhD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d025408ed6a1435023aa7837cbbce26"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSinhF_NN" ref="ga1d025408ed6a1435023aa7837cbbce26" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSinhF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2001054b1fcbeee5191c265bcbaeea2c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_N1N" ref="ga2001054b1fcbeee5191c265bcbaeea2c" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f6940ac9a86f57efe4bce7400d9234b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_NN1" ref="ga6f6940ac9a86f57efe4bce7400d9234b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e737d98b7ad71c71432248a39c2ce16"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifD_NNN" ref="ga4e737d98b7ad71c71432248a39c2ce16" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga381554ead66ca6856122b66b1e9bf063"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_N1N" ref="ga381554ead66ca6856122b66b1e9bf063" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2229b5869509b5f0947e8927262f23b0"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_NN1" ref="ga2229b5869509b5f0947e8927262f23b0" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae247f0ca7d07614d80fb70fd4f3b20ab"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifF_NNN" ref="gae247f0ca7d07614d80fb70fd4f3b20ab" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae801d743f02db4268e9897ba221372b5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifI_N1N" ref="gae801d743f02db4268e9897ba221372b5" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrDifI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2ddadabab887ab7242e6e38a1a9e571"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifI_NN1" ref="gab2ddadabab887ab7242e6e38a1a9e571" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrDifI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf50f17978fb3038f2de90158d52ba22d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifI_NNN" ref="gaf50f17978fb3038f2de90158d52ba22d" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrDifI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa052fcfbb798651180f1e19bcaedd137"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifLL_N1N" ref="gaa052fcfbb798651180f1e19bcaedd137" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrDifLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga268f7123d51dd3ddae1ed03bb1669dfb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifLL_NN1" ref="ga268f7123d51dd3ddae1ed03bb1669dfb" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrDifLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6da0c2289b6dd4b948019b4f17c2abf1"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifLL_NNN" ref="ga6da0c2289b6dd4b948019b4f17c2abf1" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrDifLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8525e02a522821beb9cf0aeb472165f3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifS_N1N" ref="ga8525e02a522821beb9cf0aeb472165f3" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrDifS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9115d3493fece5836583e6c55f91e5f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifS_NN1" ref="gad9115d3493fece5836583e6c55f91e5f" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrDifS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga747d3bc07b7274114b8c4af9847902d3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrDifS_NNN" ref="ga747d3bc07b7274114b8c4af9847902d3" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrDifS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrDifS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrDifS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f56150d804d6952997e90fb803958e4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_N1N" ref="ga5f56150d804d6952997e90fb803958e4" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9a2a0223d3af7c542c0fa570ce00a17"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_NN1" ref="gac9a2a0223d3af7c542c0fa570ce00a17" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga788004c04a717f469b0f1998d4f62067"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumD_NNN" ref="ga788004c04a717f469b0f1998d4f62067" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3568d95bc0f3df06126f00db48d52385"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_N1N" ref="ga3568d95bc0f3df06126f00db48d52385" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0cc252e1e632dd35bbb13d318f6bf51b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_NN1" ref="ga0cc252e1e632dd35bbb13d318f6bf51b" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa44f0e93a59157dc2ed7a1a320606de3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumF_NNN" ref="gaa44f0e93a59157dc2ed7a1a320606de3" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab7a5d8f72139d1f01490b6b5525e1da"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumI_N1N" ref="gaab7a5d8f72139d1f01490b6b5525e1da" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrSumI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c4c875eb7802ab9b8bbfa291f516d91"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumI_NN1" ref="ga0c4c875eb7802ab9b8bbfa291f516d91" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrSumI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf171b69a54ed5815ad05b8fbbe1d0e88"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumI_NNN" ref="gaf171b69a54ed5815ad05b8fbbe1d0e88" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrSumI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3708c0ebae86573f054ac6eb7e370143"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumLL_N1N" ref="ga3708c0ebae86573f054ac6eb7e370143" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrSumLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8322b53212bb0cf9d7ba000bb5c7c93d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumLL_NN1" ref="ga8322b53212bb0cf9d7ba000bb5c7c93d" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrSumLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41012ab6e39483bb96d38e66d0f1a26f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumLL_NNN" ref="ga41012ab6e39483bb96d38e66d0f1a26f" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrSumLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0103ff955e2e6c710ca4ad2a250b51ea"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumS_N1N" ref="ga0103ff955e2e6c710ca4ad2a250b51ea" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SqrSumS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399c7211375ae3834467f251dd5ab488"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumS_NN1" ref="ga399c7211375ae3834467f251dd5ab488" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SqrSumS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57aa99ce2436f21da79903a4a07dc436"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrSumS_NNN" ref="ga57aa99ce2436f21da79903a4a07dc436" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrSumS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SqrSumS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SqrSumS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga540c096f6e4382440007c878047f4f5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrtD_NN" ref="ga540c096f6e4382440007c878047f4f5d" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrtD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac5eb6a022dcc12e47bb871209d94fa5b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSqrtF_NN" ref="gac5eb6a022dcc12e47bb871209d94fa5b" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSqrtF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6d6857d70c11dac6815925aa5fbe258"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredD_NN" ref="gac6d6857d70c11dac6815925aa5fbe258" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga138489a0a09ca5131c997c9bf2785020"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredF_NN" ref="ga138489a0a09ca5131c997c9bf2785020" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga841881979086b4c05673571c4f7cd074"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredI_NN" ref="ga841881979086b4c05673571c4f7cd074" args="(PlankI *result, const PlankI *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredI_NN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SquaredI() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SquaredI() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga21096795df3eb840b95014154dd06075"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredLL_NN" ref="ga21096795df3eb840b95014154dd06075" args="(PlankLL *result, const PlankLL *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredLL_NN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SquaredLL() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SquaredLL() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaad088f3ce9e39ee003b9f8cb4c9ebfb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSquaredS_NN" ref="gaaad088f3ce9e39ee003b9f8cb4c9ebfb" args="(PlankS *result, const PlankS *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSquaredS_NN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function pl_SquaredS() to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function pl_SquaredS() to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8ea462ef620ebc5dd512f0df2224508"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_N1N" ref="gab8ea462ef620ebc5dd512f0df2224508" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a28dc464696905e52db911b3f97566e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_NN1" ref="ga1a28dc464696905e52db911b3f97566e" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1ad270a88e18f6e9c8a51c450c3e41f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubD_NNN" ref="gaa1ad270a88e18f6e9c8a51c450c3e41f" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad545716dacb61f997567075c3a4a6720"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_N1N" ref="gad545716dacb61f997567075c3a4a6720" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8935b522deb4e2baf1885c78ef3c5a2"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_NN1" ref="gad8935b522deb4e2baf1885c78ef3c5a2" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e7dc8aa04be89440e1440b3125cdffc"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubF_NNN" ref="ga9e7dc8aa04be89440e1440b3125cdffc" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ef0fce8af0dedc828f9168e838c4ef6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubI_N1N" ref="ga4ef0fce8af0dedc828f9168e838c4ef6" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SubI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43bc0898fea297df059997f3143dee24"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubI_NN1" ref="ga43bc0898fea297df059997f3143dee24" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SubI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga197e4812fddc0dc3e377b8fd4e3379c3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubI_NNN" ref="ga197e4812fddc0dc3e377b8fd4e3379c3" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SubI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga864ff9f594555108deeb4c93db21df54"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubLL_N1N" ref="ga864ff9f594555108deeb4c93db21df54" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SubLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac56555f924384c51446f610e99ecf59a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubLL_NN1" ref="gac56555f924384c51446f610e99ecf59a" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SubLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0b7da55fd7b38be08e742bf3e3023fe"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubLL_NNN" ref="gac0b7da55fd7b38be08e742bf3e3023fe" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SubLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b5b085ec5b3116b23929d6665a18575"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubS_N1N" ref="ga5b5b085ec5b3116b23929d6665a18575" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SubS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga443a68819fc7dd7ed74607f9ed917017"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubS_NN1" ref="ga443a68819fc7dd7ed74607f9ed917017" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SubS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09a15a25c8664cc5fe93d6ba1612389c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSubS_NNN" ref="ga09a15a25c8664cc5fe93d6ba1612389c" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSubS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SubS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SubS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc42b9865fb1e2b4f33ec9da262b2092"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_N1N" ref="gadc42b9865fb1e2b4f33ec9da262b2092" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79278b4c9dbf253e5179556919e9b35b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_NN1" ref="ga79278b4c9dbf253e5179556919e9b35b" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bb7bd02652c307ae3f496df0354e8a3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrD_NNN" ref="ga4bb7bd02652c307ae3f496df0354e8a3" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5484d71a34bd278e75b8cecf45e7263"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_N1N" ref="gad5484d71a34bd278e75b8cecf45e7263" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafaba968683dddc1cb6ee402811875181"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_NN1" ref="gafaba968683dddc1cb6ee402811875181" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52cc262cb6455a1ccb4bb7d6a3b78467"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrF_NNN" ref="ga52cc262cb6455a1ccb4bb7d6a3b78467" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d43084d26270d2c6bec67a3a50bc39e"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrI_N1N" ref="ga2d43084d26270d2c6bec67a3a50bc39e" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SumSqrI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3df6f830ed2c6262d1b6ac212cd9f070"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrI_NN1" ref="ga3df6f830ed2c6262d1b6ac212cd9f070" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SumSqrI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57263ad8dd6105b4ebf699c72e07a343"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrI_NNN" ref="ga57263ad8dd6105b4ebf699c72e07a343" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SumSqrI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaeef7ad1d58726bc9f3f06b276b3fa6f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrLL_N1N" ref="gaaeef7ad1d58726bc9f3f06b276b3fa6f" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SumSqrLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf034cde90191003fba90e423458cd4e6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrLL_NN1" ref="gaf034cde90191003fba90e423458cd4e6" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SumSqrLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf592a2d254c4eb8d213cb74ec8383e6f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrLL_NNN" ref="gaf592a2d254c4eb8d213cb74ec8383e6f" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SumSqrLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36b8ccb91a525c498337910ed46f4209"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrS_N1N" ref="ga36b8ccb91a525c498337910ed46f4209" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_SumSqrS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac2ba59d155faebe6b804d6ec19f2edc7"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrS_NN1" ref="gac2ba59d155faebe6b804d6ec19f2edc7" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_SumSqrS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga664b0d780f7c80c58456c23a4b4e929b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorSumSqrS_NNN" ref="ga664b0d780f7c80c58456c23a4b4e929b" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorSumSqrS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_SumSqrS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_SumSqrS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga135af6226d8b96e81abaaba6f9cd0b06"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanD_NN" ref="ga135af6226d8b96e81abaaba6f9cd0b06" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ff3f0a747f340ef59eb12ff9f5fa9ce"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanF_NN" ref="ga0ff3f0a747f340ef59eb12ff9f5fa9ce" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga250f2e61d743622a1609f85839f9c4bb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanhD_NN" ref="ga250f2e61d743622a1609f85839f9c4bb" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanhD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8184fcb4e00b71d0e152a6cd441e611"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorTanhF_NN" ref="gac8184fcb4e00b71d0e152a6cd441e611" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorTanhF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ddd02df030d53aa2e7ef50e24d6aa84"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_N1N" ref="ga0ddd02df030d53aa2e7ef50e24d6aa84" args="(PlankD *result, PlankD a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87f14ff8770a1f823a4157bc40e1e5d6"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_NN1" ref="ga87f14ff8770a1f823a4157bc40e1e5d6" args="(PlankD *result, const PlankD *a, PlankD b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankD&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57d7f27f996ba4e74be09197791e404d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshD_NNN" ref="ga57d7f27f996ba4e74be09197791e404d" args="(PlankD *result, const PlankD *a, const PlankD *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshD_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9bc9357afdaecf35a48a2819a1673ec5"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_N1N" ref="ga9bc9357afdaecf35a48a2819a1673ec5" args="(PlankF *result, PlankF a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae27592fcf9a6e2511f691e2b840340a9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_NN1" ref="gae27592fcf9a6e2511f691e2b840340a9" args="(PlankF *result, const PlankF *a, PlankF b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankF&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3161963fd5d2e9453250a93f01226f5d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshF_NNN" ref="ga3161963fd5d2e9453250a93f01226f5d" args="(PlankF *result, const PlankF *a, const PlankF *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshF_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9119d072c56a8dcd37299be9cc0cfcbb"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshI_N1N" ref="ga9119d072c56a8dcd37299be9cc0cfcbb" args="(PlankI *result, PlankI a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshI_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshI() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ThreshI() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d56ca707caa7e03c034acd240cb8ef9"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshI_NN1" ref="ga0d56ca707caa7e03c034acd240cb8ef9" args="(PlankI *result, const PlankI *a, PlankI b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshI_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankI&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshI() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ThreshI() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3434cc8929b73c8e577b15860607c9c"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshI_NNN" ref="gae3434cc8929b73c8e577b15860607c9c" args="(PlankI *result, const PlankI *a, const PlankI *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshI_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankI *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankI *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshI() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ThreshI() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac52ca8882e12cc87a0973ad0f728db7b"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshLL_N1N" ref="gac52ca8882e12cc87a0973ad0f728db7b" args="(PlankLL *result, PlankLL a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshLL_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ThreshLL() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeddba6d777b29b1a424122c495f48e8f"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshLL_NN1" ref="gaeddba6d777b29b1a424122c495f48e8f" args="(PlankLL *result, const PlankLL *a, PlankLL b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshLL_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshLL() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ThreshLL() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaefcaea6937598439c1e27ff730e3b05"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshLL_NNN" ref="gaaefcaea6937598439c1e27ff730e3b05" args="(PlankLL *result, const PlankLL *a, const PlankLL *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshLL_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshLL() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ThreshLL() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad54338b76e8465146cbf3269d8a405d3"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshS_N1N" ref="gad54338b76e8465146cbf3269d8a405d3" args="(PlankS *result, PlankS a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshS_N1N </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshS() to an input vector and a scalar value. </p>
<p>This processes vector <em>b</em> and applies the function pl_ThreshS() to each item and the scalar value <em>a</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>A scalar value and the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em> and the source of the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfe493153f9a7e7d04af461a18368010"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshS_NN1" ref="gabfe493153f9a7e7d04af461a18368010" args="(PlankS *result, const PlankS *a, PlankS b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshS_NN1 </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankS&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshS() to an input vector and a scalar value. </p>
<p>This processes vector <em>a</em> and applies the function pl_ThreshS() to each item and the scalar value <em>b</em> and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em> and the source of the left operand of the operation. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar value and the right operand of the operation. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dc4f59cfde13de3c2e3e871e5d0517d"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorThreshS_NNN" ref="ga2dc4f59cfde13de3c2e3e871e5d0517d" args="(PlankS *result, const PlankS *a, const PlankS *b, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorThreshS_NNN </td>
          <td>(</td>
          <td class="paramtype">PlankS *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankS *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the binary operator function pl_ThreshS() to each item in two input vectors. </p>
<p>This processes vectors <em>a</em> and <em>b</em> applying the function pl_ThreshS() to each of their items in turn and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>Input vector <em>a</em>. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector <em>b</em>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfeb5cce886741713f4db15d8e45530a"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorZapD_NN" ref="gabfeb5cce886741713f4db15d8e45530a" args="(PlankD *result, const PlankD *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorZapD_NN </td>
          <td>(</td>
          <td class="paramtype">PlankD *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bd51dca6361c74850caf92244eefbf4"></a><!-- doxytag: member="plank_Vectors.h::pl_VectorZapF_NN" ref="ga6bd51dca6361c74850caf92244eefbf4" args="(PlankF *result, const PlankF *a, PlankUL N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_VectorZapF_NN </td>
          <td>(</td>
          <td class="paramtype">PlankF *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankF *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item in a vector. </p>
<p>This processes vector <em>a</em> applying the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item and returns the result in the vector <em>result</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output vector is placed here. </td></tr>
    <tr><td class="paramname">a</td><td>The input vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of items in the input/output vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Feb 8 2014 12:26:52 for pl-nk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
