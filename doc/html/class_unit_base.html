<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plinkplonk: UnitBase&lt; SampleType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">plinkplonk</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a>  </div>
  <div class="headertitle">
<div class="title">UnitBase&lt; SampleType &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="UnitBase" --><!-- doxytag: inherits="NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;" -->
<p>A Unit is effectively an array of Channel objects.  
 <a href="class_unit_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="plonk___unit_8h_source.html">plonk_Unit.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UnitBase&lt; SampleType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_unit_base.png" usemap="#UnitBase&lt; SampleType &gt;_map" alt=""/>
  <map id="UnitBase&lt; SampleType &gt;_map" name="UnitBase&lt; SampleType &gt;_map">
<area href="class_numerical_array.html" alt="NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;" shape="rect" coords="0,168,495,192"/>
<area href="class_object_array.html" alt="ObjectArray&lt; ChannelBase&lt; SampleType &gt; &gt;" shape="rect" coords="0,112,495,136"/>
<area href="class_smart_pointer_container.html" alt="SmartPointerContainer&lt; ObjectArrayInternal&lt; ChannelBase&lt; SampleType &gt; &gt; &gt;" shape="rect" coords="0,56,495,80"/>
<area href="class_smart_pointer_container_base.html" alt="SmartPointerContainerBase&lt; ObjectArrayInternal&lt; ChannelBase&lt; SampleType &gt; &gt; &gt;" shape="rect" coords="0,0,495,24"/>
</map>
 </div></div>

<p><a href="class_unit_base-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_object_array_internal.html">ObjectArrayInternal</a><br class="typebreak"/>
&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6555cf2c5d7f1cc1aaaece05a1207565">Internal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array.html">UnitType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aa3f11dbf214bdfaebf74fa89dbb3ac70">Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_weak_pointer_container.html">WeakPointerContainer</a><br class="typebreak"/>
&lt; <a class="el" href="class_unit_base.html">UnitBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a81fc09ea2199ab96ae945946bda07574">Weak</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array.html">NumericalArray</a><br class="typebreak"/>
&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9d48eb309ea0b8d7d25ef47ef57064bc">Buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_input_dictionary.html">InputDictionary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2fe763047acb612f46fbfe62ca3777a6">Inputs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array_1_1_initial_number.html">UnitType::InitialNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adbef4b52a9c1508d66750f10946b2a72">InitialUnit</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a1f8d70fb911d20b57408b2b22a989f0e">UnitBase</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a1f8d70fb911d20b57408b2b22a989f0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a419080b5014491cfbcda6fdb02752dff">UnitBase</a> (<a class="el" href="class_object_array_internal.html">Internal</a> *internal)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adadd88eba71d1676c28989bae727337f">UnitBase</a> (<a class="el" href="class_dynamic.html">Dynamic</a> const &amp;other)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ab51068fdaa593550f896912d0f8e157a">UnitBase</a> (<a class="el" href="class_channel_base.html">ChannelType</a> const &amp;channel)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a Unit with a single Channel.  <a href="#ab51068fdaa593550f896912d0f8e157a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a57a3ef6a6b7cb5b6b3796cc7553fa923">UnitBase</a> (ValueType const &amp;valueInit)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant Unit constructor.  <a href="#a57a3ef6a6b7cb5b6b3796cc7553fa923"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6033c6242a569daaf9c736607f054a08">UnitBase</a> (<a class="el" href="class_numerical_array.html">NumericalArray</a>&lt; ValueType &gt; const &amp;values)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multichannel Constant Unit constructor.  <a href="#a6033c6242a569daaf9c736607f054a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a8984afc268c34317885bb372cf0a834f">UnitBase</a> (<a class="el" href="class_variable.html">VariableType</a> const &amp;variable)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad639860274c7d3ee6170e4340edaeff0">UnitBase</a> (<a class="el" href="class_numerical_array.html">NumericalArray</a>&lt; <a class="el" href="class_variable.html">VariableType</a> &gt; const &amp;variables)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adeaf8e9083b75f03df0ef28ccd6432cd">UnitBase</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;copy)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from the base array type.  <a href="#adeaf8e9083b75f03df0ef28ccd6432cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5843bc2a5db8af9e33b1cde20e769a4e">UnitBase</a> (<a class="el" href="class_object_array.html">ObjectArray</a>&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt; const &amp;copy)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a7d7469eeee1b574d5299762f8a3d7036">operator=</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;other)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a7d7469eeee1b574d5299762f8a3d7036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ac5d6ddf8691c78944d448529f37006bb">operator=</a> (<a class="el" href="class_channel_base.html">ChannelType</a> const &amp;other)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from a single channel.  <a href="#ac5d6ddf8691c78944d448529f37006bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ae9d0d472add7bdcb4aec4baf35c52cc8">operator=</a> (<a class="el" href="class_numerical_array.html">UnitType</a> const &amp;other)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from the base array type.  <a href="#ae9d0d472add7bdcb4aec4baf35c52cc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aab0d06b9df0c6d0a56f469b2ee572c09">operator=</a> (<a class="el" href="class_object_array.html">ObjectArray</a>&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt; const &amp;other)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from an array of channels.  <a href="#aab0d06b9df0c6d0a56f469b2ee572c09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ab18b0bf950a219fb07257aca3a5e5b76">ar</a> (<a class="el" href="class_block_size.html">BlockSize</a> const &amp;preferredBlockSize=BlockSize::getDefault(), <a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;preferredSampleRate=SampleRate::getDefault())  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples this unit to a different sample rate and/or block size.  <a href="#ab18b0bf950a219fb07257aca3a5e5b76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ab9204dbea9636ed67d40fd663333ee44">kr</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples this unit to the default control rate sample rate and block size.  <a href="#ab9204dbea9636ed67d40fd663333ee44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a612cb53496d3ceb671bed8a632b77156">mix</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes this unit down to a single channel.  <a href="#a612cb53496d3ceb671bed8a632b77156"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a4f336f25723b5330c64b24fb964d568b">mixBarrier</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes this unit down to a single channel with and auto-deletion prevention barrier.  <a href="#a4f336f25723b5330c64b24fb964d568b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ae4b03e22f6ff31654815c457a85a78c6">overlapMake</a> (<a class="el" href="class_variable.html">DoubleVariable</a> const &amp;overlap=DoubleVariable::getHalf())  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an overlapping process from this unit's contrinuous stream.  <a href="#ae4b03e22f6ff31654815c457a85a78c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a3786ff0d71ec1cc2ab7f5c2de65ec36a">overlapMix</a> (<a class="el" href="class_variable.html">DoubleVariable</a> const &amp;overlap=DoubleVariable::getHalf())  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mix down overlapping process to a continuous stream.  <a href="#a3786ff0d71ec1cc2ab7f5c2de65ec36a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;SampleType(*)(SampleType, SampleType) op&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a35419f9d20253e5d52de37d4367c7311">binary</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;rightOperand) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated binary operator Unit creator.  <a href="#a35419f9d20253e5d52de37d4367c7311"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;SampleType(*)(SampleType) op&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a142b2de4be916e9eeec7957f550e3518">unary</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated unary operator Unit creator.  <a href="#a142b2de4be916e9eeec7957f550e3518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9ce47f1b83109061a4865b1ed3ff3578">addop</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'addop' function to this one and the <em>right</em> argument.  <a href="#a9ce47f1b83109061a4865b1ed3ff3578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a007485d6e5d46ba2f1c081b9f156d932">subop</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'subop' function to this one and the <em>right</em> argument.  <a href="#a007485d6e5d46ba2f1c081b9f156d932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af0679918598bab4c013cfc4f2d5c268f">mulop</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'mulop' function to this one and the <em>right</em> argument.  <a href="#af0679918598bab4c013cfc4f2d5c268f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6f745272970edbac5e99fb7cc30ffc4c">divop</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'divop' function to this one and the <em>right</em> argument.  <a href="#a6f745272970edbac5e99fb7cc30ffc4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a769265718d2edfe60c43e4cf797c0110">isEqualTo</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isEqualTo' function to this one and the <em>right</em> argument.  <a href="#a769265718d2edfe60c43e4cf797c0110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9cbfe5d8e80d28df1f5241e1ea874929">isNotEqualTo</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isNotEqualTo' function to this one and the <em>right</em> argument.  <a href="#a9cbfe5d8e80d28df1f5241e1ea874929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af70d74f6f77c5c5866146c89a2d123c9">isGreaterThan</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isGreaterThan' function to this one and the <em>right</em> argument.  <a href="#af70d74f6f77c5c5866146c89a2d123c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ac6b0846c1172e1fa275d51beb7895559">isGreaterThanOrEqualTo</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isGreaterThanOrEqualTo' function to this one and the <em>right</em> argument.  <a href="#ac6b0846c1172e1fa275d51beb7895559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af6582e308726a8e4fb63235ca5b73016">isLessThan</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isLessThan' function to this one and the <em>right</em> argument.  <a href="#af6582e308726a8e4fb63235ca5b73016"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a1e52af4d320c6b8ef1518458868a5953">isLessThanOrEqualTo</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isLessThanOrEqualTo' function to this one and the <em>right</em> argument.  <a href="#a1e52af4d320c6b8ef1518458868a5953"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a12fde7570fe1ff64ef675c0d5f91b736">hypot</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'hypot' function to this one and the <em>right</em> argument.  <a href="#a12fde7570fe1ff64ef675c0d5f91b736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aa44db5c79cca4f9ea0f7bb984cf2d8f9">pow</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'pow' function to this one and the <em>right</em> argument.  <a href="#aa44db5c79cca4f9ea0f7bb984cf2d8f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a764a7d2d34e98b273063606d76bd703b">atan2</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'atan2' function to this one and the <em>right</em> argument.  <a href="#a764a7d2d34e98b273063606d76bd703b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a64cf093d072095318f4c27a476d12208">min</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'min' function to this one and the <em>right</em> argument.  <a href="#a64cf093d072095318f4c27a476d12208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a4cdf04233317f510dda567bda01fb5dd">max</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'max' function to this one and the <em>right</em> argument.  <a href="#a4cdf04233317f510dda567bda01fb5dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9859d688170b57861e5373728a4304f4">sumsqr</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sumsqr' function to this one and the <em>right</em> argument.  <a href="#a9859d688170b57861e5373728a4304f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6276eb0d25731e070427370a27a5e86f">difsqr</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'difsqr' function to this one and the <em>right</em> argument.  <a href="#a6276eb0d25731e070427370a27a5e86f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adb1fc080c1b85651ab0f0a2da2a37fbe">sqrsum</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sqrsum' function to this one and the <em>right</em> argument.  <a href="#adb1fc080c1b85651ab0f0a2da2a37fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad44f311b28ebda6d59a8aca92b937ae9">sqrdif</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sqrdif' function to this one and the <em>right</em> argument.  <a href="#ad44f311b28ebda6d59a8aca92b937ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a8b2d8eaf1da10d44b0a50976a2d601af">absdif</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'absdif' function to this one and the <em>right</em> argument.  <a href="#a8b2d8eaf1da10d44b0a50976a2d601af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adab69c58f3fe0588d0d4aad52935e254">thresh</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'thresh' function to this one and the <em>right</em> argument.  <a href="#adab69c58f3fe0588d0d4aad52935e254"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#afa2a02a2c6fb51b2607ab7a1507788fb">round</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'round' function to this one and the <em>right</em> argument.  <a href="#afa2a02a2c6fb51b2607ab7a1507788fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a51eebe85fa983b84bc44a2def0a8ac7d">trunc</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'trunc' function to this one and the <em>right</em> argument.  <a href="#a51eebe85fa983b84bc44a2def0a8ac7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af384ce936686453e9689eeaf6457986f">clip2</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'clip2' function to this one and the <em>right</em> argument.  <a href="#af384ce936686453e9689eeaf6457986f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a783d354004272b602e116d058294f157">operator+</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '+' operator to this and the <em>right</em> argument.  <a href="#a783d354004272b602e116d058294f157"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aa00cdc04e68728d2892ba17b6efae5c2">operator-</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '-' operator to this and the <em>right</em> argument.  <a href="#aa00cdc04e68728d2892ba17b6efae5c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a61fabb5b95c3d391451bd5c394447d49">operator*</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '*' operator to this and the <em>right</em> argument.  <a href="#a61fabb5b95c3d391451bd5c394447d49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a50be2f9d83e178bd7ad755364655d357">operator/</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '/' operator to this and the <em>right</em> argument.  <a href="#a50be2f9d83e178bd7ad755364655d357"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad7f73b933867b036a575ff01c621ff08">operator+=</a> (RightType const &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '+' operator to this and the <em>right</em> argument.  <a href="#ad7f73b933867b036a575ff01c621ff08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a03113ab3519c80f88e78f97ea272bd94">operator-=</a> (RightType const &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '-' operator to this and the <em>right</em> argument.  <a href="#a03113ab3519c80f88e78f97ea272bd94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#afc7424b74a1185a578ba25c499986cff">operator*=</a> (RightType const &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '*' operator to this and the <em>right</em> argument.  <a href="#afc7424b74a1185a578ba25c499986cff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a0c0b2547f77f2840de847a77cf39f87f">operator/=</a> (RightType const &amp;right)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '/' operator to this and the <em>right</em> argument.  <a href="#a0c0b2547f77f2840de847a77cf39f87f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a3fbcb0b247b7335b27aa90c454b30308">operator&lt;</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&lt;' operator to this and the <em>right</em> argument.  <a href="#a3fbcb0b247b7335b27aa90c454b30308"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abd22385bfeb42dad70f0ef9d65e3bbcf">operator&lt;=</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&lt;=' operator to this and the <em>right</em> argument.  <a href="#abd22385bfeb42dad70f0ef9d65e3bbcf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5a1d2e2d65b20054478ab234e9a920a8">operator&gt;</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&gt;' operator to this and the <em>right</em> argument.  <a href="#a5a1d2e2d65b20054478ab234e9a920a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RightType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adafd268de4860a36a14c6d63f6247f28">operator&gt;=</a> (RightType const &amp;right) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&gt;=' operator to this and the <em>right</em> argument.  <a href="#adafd268de4860a36a14c6d63f6247f28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a3218bcc6c0d55a2b19b6d5ffd8a0af31">move</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'move' function to this one.  <a href="#a3218bcc6c0d55a2b19b6d5ffd8a0af31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2fd07c9e23fb1dcf2ba895306ff3cbc8">inc</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'inc' function to this one.  <a href="#a2fd07c9e23fb1dcf2ba895306ff3cbc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a44f39fd6c809e2c858ff959af4b41144">dec</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'dec' function to this one.  <a href="#a44f39fd6c809e2c858ff959af4b41144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a554c1b387f114d20d4d5b1215ffa27a4">abs</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'abs' function to this one.  <a href="#a554c1b387f114d20d4d5b1215ffa27a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af0d0038175b087694a309d47b66bf440">log2</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log2' function to this one.  <a href="#af0d0038175b087694a309d47b66bf440"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a0314952ec0909fb5cce927b12efc9a7f">neg</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'neg' function to this one.  <a href="#a0314952ec0909fb5cce927b12efc9a7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aedf8a851d44920f7c5569f5357587d01">reciprocal</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'reciprocal' function to this one.  <a href="#aedf8a851d44920f7c5569f5357587d01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#adfd01e6c59c15369e4bfda8f5776b570">sin</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sin' function to this one.  <a href="#adfd01e6c59c15369e4bfda8f5776b570"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6131c0e3755237cdec87441a2ab35ac1">cos</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cos' function to this one.  <a href="#a6131c0e3755237cdec87441a2ab35ac1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a0af939bf3ff068d959ae5be1fa581bce">tan</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'tan' function to this one.  <a href="#a0af939bf3ff068d959ae5be1fa581bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a4a3d949cd5c57c8fdb5badcca675497c">asin</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'asin' function to this one.  <a href="#a4a3d949cd5c57c8fdb5badcca675497c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abf0d922e1c6ca460292375fc895e8048">acos</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'acos' function to this one.  <a href="#abf0d922e1c6ca460292375fc895e8048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#acb2fdbd56ed53328c20327aa140c0f67">atan</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'atan' function to this one.  <a href="#acb2fdbd56ed53328c20327aa140c0f67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a7042232fed9247cb1c185a4405e62638">sinh</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sinh' function to this one.  <a href="#a7042232fed9247cb1c185a4405e62638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a337c6c7cc6c6c69fb4245a2524ffd747">cosh</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cosh' function to this one.  <a href="#a337c6c7cc6c6c69fb4245a2524ffd747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aad9b00972e19f50911631486aa44f590">tanh</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'tanh' function to this one.  <a href="#aad9b00972e19f50911631486aa44f590"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad3c6085937821c153209ae38a6471d85">sqrt</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sqrt' function to this one.  <a href="#ad3c6085937821c153209ae38a6471d85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#acc7d6774a51a7f17c98e2369158bd02a">log</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log' function to this one.  <a href="#acc7d6774a51a7f17c98e2369158bd02a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abae5ddb502112cbdaaba960ed041fe0a">log10</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log10' function to this one.  <a href="#abae5ddb502112cbdaaba960ed041fe0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad7558bfa0572b759fe423f1b8da02660">exp</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'exp' function to this one.  <a href="#ad7558bfa0572b759fe423f1b8da02660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad1bd91b6d6644cc438f16489ada2da9f">squared</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'squared' function to this one.  <a href="#ad1bd91b6d6644cc438f16489ada2da9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2a0d4359ab797a76531b844097e5b828">cubed</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cubed' function to this one.  <a href="#a2a0d4359ab797a76531b844097e5b828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9b625b6139101fc94112cb11fc25ede8">ceil</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'ceil' function to this one.  <a href="#a9b625b6139101fc94112cb11fc25ede8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ac65016aecebfe364574f328bf58a4f9f">floor</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'floor' function to this one.  <a href="#ac65016aecebfe364574f328bf58a4f9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a7543750a30dd2f6f87fc61d8d627beec">frac</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'frac' function to this one.  <a href="#a7543750a30dd2f6f87fc61d8d627beec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a498954490886e3acd13d5747f65d290a">sign</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sign' function to this one.  <a href="#a498954490886e3acd13d5747f65d290a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad8b08088db7545b26fe6d48872f08203">m2f</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'm2f' function to this one.  <a href="#ad8b08088db7545b26fe6d48872f08203"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aed8bc12ebfab2788c950c70ad5fc8a5c">f2m</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'f2m' function to this one.  <a href="#aed8bc12ebfab2788c950c70ad5fc8a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a88265b35eb65738f78899255c186efbe">a2dB</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'a2dB' function to this one.  <a href="#a88265b35eb65738f78899255c186efbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a887e8a891ea784749728c80c7bb670e2">dB2a</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'dB2a' function to this one.  <a href="#a887e8a891ea784749728c80c7bb670e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a7c498c5e54d2438b9461599fde9fb13e">d2r</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'd2r' function to this one.  <a href="#a7c498c5e54d2438b9461599fde9fb13e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abd8eaab7d56faed695675c0e98e4cd0f">r2d</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'r2d' function to this one.  <a href="#abd8eaab7d56faed695675c0e98e4cd0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a196824b85035fea76f750b642db6b42e">distort</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'distort' function to this one.  <a href="#a196824b85035fea76f750b642db6b42e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a928af1dac6e8b66ab2c9d7a7ceaa10a7">zap</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'zap' function to this one.  <a href="#a928af1dac6e8b66ab2c9d7a7ceaa10a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abc6b6d450e027fba5242bf9985eb614c">operator-</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary '-' operator to this one.  <a href="#abc6b6d450e027fba5242bf9985eb614c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_numerical_array2_d.html">UnitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a24aa111569583ac0e9329c837caaeece">operator&lt;&lt;</a> (<a class="el" href="class_numerical_array.html">UnitType</a> const &amp;other) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_numerical_array2_d.html">UnitArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a89dce5a55adbbdfaae908958b760012d">operator&lt;&lt;</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;other) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6926f7a29b3c0aeca299c649d885abee">operator,</a> (<a class="el" href="class_numerical_array.html">UnitType</a> const &amp;other) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a706c00f62f694ec1c825ac72697156fa">operator,</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;other) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a29c48bc96d194d72dc3ad84cb073aeb0">setLabel</a> (<a class="el" href="class_text.html">Text</a> const &amp;unitId)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a custom name to be set.  <a href="#a29c48bc96d194d72dc3ad84cb073aeb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a1f8d49c0651e927f3583fa6458a5b908">getNumChannels</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of channels in this unit.  <a href="#a1f8d49c0651e927f3583fa6458a5b908"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad9e6d5dad44ca41ebe4b6f6f56cab95e">getChannel</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit with the single channel specified.  <a href="#ad9e6d5dad44ca41ebe4b6f6f56cab95e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a6b70baa2348be760bdde2a8dcf0fb1ac">getChannel</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit with the single channel specified.  <a href="#a6b70baa2348be760bdde2a8dcf0fb1ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a51d3e16937b30c0469661261e6acb42d">operator[]</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit with the single channel specified.  <a href="#a51d3e16937b30c0469661261e6acb42d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#afd08e14c94c1e344a05b957308caa472">operator[]</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit with the single channel specified.  <a href="#afd08e14c94c1e344a05b957308caa472"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a336e560bdcb43adae1b83f1dc9f3d114">put</a> (const int index, <a class="el" href="class_unit_base.html">UnitBase</a> const &amp;channel)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_block_size.html">BlockSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aa7027499885c3206dee0b8b95f6e4fa2">getMinBlockSize</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum block size in the array of channels in this unit.  <a href="#aa7027499885c3206dee0b8b95f6e4fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_block_size.html">BlockSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a357165ca134a47f7204169b469e80b00">getMaxBlockSize</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum block size in the array of channels in this unit.  <a href="#a357165ca134a47f7204169b469e80b00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_block_size.html">BlockSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad7156eb1df81d39faa613cc37dcd7687">getBlockSize</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block size of a specific channel in this unit.  <a href="#ad7156eb1df81d39faa613cc37dcd7687"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_block_size.html">BlockSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a955a5aea58d79f8cde2b8ed080342acd">getBlockSize</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block size of a specific channel in this unit.  <a href="#a955a5aea58d79f8cde2b8ed080342acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9cee8690b55ba3b627eb5c741ae4d54c">setBlockSize</a> (<a class="el" href="class_block_size.html">BlockSize</a> const &amp;newBlockSize)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the block size of all channels in this unit.  <a href="#a9cee8690b55ba3b627eb5c741ae4d54c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sample_rate.html">SampleRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#affc5ede3dc74cbb4cb3ad72ddb444975">getMinSampleRate</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum sample rate in the array of channels in this unit.  <a href="#affc5ede3dc74cbb4cb3ad72ddb444975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sample_rate.html">SampleRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a293fb73766388495d285208bfd9ce0c3">getMaxSampleRate</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum sample rate in the array of channels in this unit.  <a href="#a293fb73766388495d285208bfd9ce0c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sample_rate.html">SampleRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a71526cc54801d1c5d2f312b47090618d">getSampleRate</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample rate of a specific channel in this unit.  <a href="#a71526cc54801d1c5d2f312b47090618d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sample_rate.html">SampleRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5d3580e278cb7e0d6ffc232f7c0fca2c">getSampleRate</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample rate of a specific channel in this unit.  <a href="#a5d3580e278cb7e0d6ffc232f7c0fca2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ae6b374388db6dd4125bd22350b765187">setSampleRate</a> (<a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;newSampleRate)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample rate of all channels in this unit.  <a href="#ae6b374388db6dd4125bd22350b765187"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a56260640747b48ffa5b3f6de840af3f3">getSampleDurationInTicks</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a20e388e3d6cd482f2cf417da0c8e5e88">getBlockDurationInTicks</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_variable.html">DoubleVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2a7a1b5cbe1b247e20d48927ec5fb676">getOverlap</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_variable.html">DoubleVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5903a71f02960ca268b94e2d481f8af9">getOverlap</a> (const int index)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a33079afffb4c6cb3de7cd8c62841022b">channelsHaveSameOverlap</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_numerical_array.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a08100240d3ae6e9f1dbe9add73d24d06">getOutputBuffer</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output buffer of a specific channel.  <a href="#a08100240d3ae6e9f1dbe9add73d24d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_numerical_array.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a65a60c385d78f0221acee780808e1517">getOutputBuffer</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output buffer of a specific channel.  <a href="#a65a60c385d78f0221acee780808e1517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const SampleType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a43faf13fd6fba7d41104578862a65863">getOutputSamples</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw samples of a specific channel.  <a href="#a43faf13fd6fba7d41104578862a65863"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SampleType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a52d71e0871badee91a8e565107e55936">getOutputSamples</a> (const int index)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw samples of a specific channel.  <a href="#a52d71e0871badee91a8e565107e55936"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aed36ad8bca094f3fa98d0a134cb2d36f">setOutputBuffer</a> (const int index, <a class="el" href="class_numerical_array.html">Buffer</a> const &amp;externalBuffer)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output buffer of a specific channel to use an external buffer.  <a href="#aed36ad8bca094f3fa98d0a134cb2d36f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5971dc08c2dc28db827df3b7ea671e94">setOutputBuffer</a> (<a class="el" href="class_numerical_array2_d.html">BufferArrayType</a> const &amp;externalBuffer)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output buffers of this unit's channels to use external buffers.  <a href="#a5971dc08c2dc28db827df3b7ea671e94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const SampleType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a0abca48d077f3f49b5c9639ac64eec5a">getValue</a> (const int index) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of a specific channel in this unit.  <a href="#a0abca48d077f3f49b5c9639ac64eec5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_time_stamp.html">TimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2c5e01a93876321a3e9fced5006c4521">getNextTimeStamp</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aee5909be3f87dca9156fe4611b7c94d6">isNull</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a405c7135663599a9603393a393f0bb66">isNotNull</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a5a9473b849ca895b72d058ad54f02eae">isConstant</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a4dc53a4989df63faf42b4c7b648ca5e3">isNotConstant</a> (const int index) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2b9e0433de29cce99dfa9e04cf7b4074">isNull</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this unit contains only a single null channel.  <a href="#a2b9e0433de29cce99dfa9e04cf7b4074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#afebc412bbc462492297cb0bb96d2b46a">isNotNull</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if this unit contains only a single null channel.  <a href="#afebc412bbc462492297cb0bb96d2b46a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a114f2a825a7fb1791ceefeba49df2c2f">isConstant</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this unit contains only a single constant channel.  <a href="#a114f2a825a7fb1791ceefeba49df2c2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ac107382b7aca87bb65fc8beb05c51b5b">isNotConstant</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if this unit contains only a single constant channel.  <a href="#ac107382b7aca87bb65fc8beb05c51b5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#af32d1a3c659048be9d9dc8b22c693491">setToNull</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_numerical_array.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a03ff4846d93ac89f7afab49972a9762d">process</a> (<a class="el" href="class_process_info.html">ProcessInfo</a> &amp;info, const int channel)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a specific channel in this unit.  <a href="#a03ff4846d93ac89f7afab49972a9762d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a0b69c2c88f25b4289ba2ac4ed01bebba">process</a> (<a class="el" href="class_process_info.html">ProcessInfo</a> &amp;info)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all channels in this unit.  <a href="#a0b69c2c88f25b4289ba2ac4ed01bebba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2891d6c1839d13315f8f950631688518">getTypeCode</a> () const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#aea8acd5fba79b7fe97712e2e9a09275c">getSampleTypeCode</a> () const   throw ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ad918f5ddca5ca251ffa25864e0b742a4">fromWeak</a> (<a class="el" href="class_weak_pointer_container.html">Weak</a> const &amp;weak)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a weakly linked copy of this object.  <a href="#ad918f5ddca5ca251ffa25864e0b742a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2a48b6e82bb1a93ee0b0ecd309688ff0">getNull</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a916cfd64bee364c7c7f06831d048b716">emptyChannels</a> (const int numChannels)  throw ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ChannelInternalClassType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a8780779f9d31414671b0500d90a92a3e">createFromInputs</a> (<a class="el" href="class_input_dictionary.html">Inputs</a> const &amp;inputs, typename ChannelInternalClassType::Data const &amp;data, <a class="el" href="class_block_size.html">BlockSize</a> const &amp;preferredBlockSize, <a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;preferredSampleRate)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary means of creating Unit objects.  <a href="#a8780779f9d31414671b0500d90a92a3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ProxyOwnerChannelInternalClassType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ab29dbe0f2064dcca44bf2f0e7371c782">proxiesFromInputs</a> (<a class="el" href="class_input_dictionary.html">Inputs</a> const &amp;inputs, typename ProxyOwnerChannelInternalClassType::Data const &amp;data, <a class="el" href="class_block_size.html">BlockSize</a> const &amp;preferredBlockSize, <a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;preferredSampleRate)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary means of creating Unit objects with proxies.  <a href="#ab29dbe0f2064dcca44bf2f0e7371c782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_unit_base.html">UnitBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a3d6a3fbf0d6a2f1dcec1a7503e74b9d4">applyMulAdd</a> (<a class="el" href="class_unit_base.html">UnitBase</a> const &amp;mainUnit, <a class="el" href="class_unit_base.html">UnitBase</a> const &amp;mul, <a class="el" href="class_unit_base.html">UnitBase</a> const &amp;add)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply multiply and addition operators to another unit.  <a href="#a3d6a3fbf0d6a2f1dcec1a7503e74b9d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abf3290de37effc698c5c81055587ee82">getZero</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a2b2a51f4a958f937afa37f31b6ba763c">getOne</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a8b89a879318d421de48965b84240dcc5">getTwo</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ade8af08eb2577b175b09d57ff406d3a4">getHalf</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a84f054cd5c680d2d8cd7d1788709a99e">getPi</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_unit_base.html">UnitBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a9421515920a65effeb303796895d0d49">getTwoPi</a> ()  throw ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_channel_base.html">ChannelBase</a>&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a026f3040d41d5a92072f6088c065508b">ChannelType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_channel_internal_base.html">ChannelInternalBase</a><br class="typebreak"/>
&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#ab5ddea019e1891d8dab854c1b21ca3f9">ChannelInternalType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array.html">NumericalArray</a><br class="typebreak"/>
&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a72d04200ca52533aec32209d8f06d3ad">UnitType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array2_d.html">NumericalArray2D</a><br class="typebreak"/>
&lt; <a class="el" href="class_channel_base.html">ChannelType</a>, <a class="el" href="class_numerical_array.html">UnitType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a47a57032361dd89ae13a00a2d9199a99">UnitArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_numerical_array2_d.html">NumericalArray2D</a><br class="typebreak"/>
&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a593b06cfae47f7507b7dbc4702ce3efb">BufferArrayType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_null_channel_internal.html">NullChannelInternal</a><br class="typebreak"/>
&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#a187eaefffead4cd269f692e3372cd577">NullInternal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_variable.html">Variable</a>&lt; SampleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unit_base.html#abe0f2c157863200f41ffbaf38063cfa8">VariableType</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SampleType&gt;<br/>
class UnitBase&lt; SampleType &gt;</h3>

<p>A Unit is effectively an array of Channel objects. </p>
<p>A Unit effective IS a Unit graph since each Channel of each Unit may be in turn connected to more Unit objects via its inputs.</p>
<p>Inherits from <a class="el" href="class_object_array.html" title="This is the base class for arrays.">ObjectArray</a> and is specifically designed to hold an array of <a class="el" href="class_channel_base.html" title="A single output signal.">ChannelBase</a> objects. The is perhaps the most important class at the user end of the code. The user deals with <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> objects and combines them into a graph to produce audio processing algorithms. In fact a <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> object is a graph. There are two primary static (factory) functions for creating <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> objects from specific channel types: createFromDictionary() and proxiesFromDictionary(). The latter will be discussed below, createFromDictionary() is passed a dictionary containing the desired inputs to the new Unit and it allocates a number of channels of a specified <a class="el" href="class_channel_internal.html" title="The base class from which most ChannelInternals should be derived.">ChannelInternal</a> type. These are passed a 'data' structure to initialise themselves. In many cases this might just be the default <a class="el" href="class_channel_internal_core.html#a09763233582f6f0985461449aa262ae5" title="To store channel state data.">ChannelInternalCore::Data</a> where the sample rate information can be transmitted up the graph. The <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> that is created will have a number of channels equal to the the maximum number of channels found in the provided inputs i.e., if a stereo unit is passed as the frequency input to the <a class="el" href="class_saw_unit.html" title="A non-bandlimted sawtooth oscillator.">SawUnit</a> then two channels of the <a class="el" href="class_saw_unit.html" title="A non-bandlimted sawtooth oscillator.">SawUnit</a> will be created - at render time the appropriate channel of the input unit will be passed to the appropriate channel of the destination unit. There is no concept of 'wire' or 'connections' in Plonk - the graph connections are implied by the layering of units to form a chain (and by implication the 'graph' is constructed by how the channels in these layers transmit to the next layer). <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> objects repsond to most of the standard unary and binary operators (including symbols +, -, * etc). These create units that apply this operator at render time. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_channel_base.html" title="A single output signal.">ChannelBase</a>, <a class="el" href="class_process_info.html" title="Holds information about the Unit graph.">ProcessInfo</a> </dd></dl>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa3f11dbf214bdfaebf74fa89dbb3ac70"></a><!-- doxytag: member="UnitBase::Base" ref="aa3f11dbf214bdfaebf74fa89dbb3ac70" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array.html">UnitType</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array.html">Base</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ae95ce32ea5bf1b47707cbf06e3ecac2b">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9d48eb309ea0b8d7d25ef47ef57064bc"></a><!-- doxytag: member="UnitBase::Buffer" ref="a9d48eb309ea0b8d7d25ef47ef57064bc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array.html">NumericalArray</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array.html">Buffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a593b06cfae47f7507b7dbc4702ce3efb"></a><!-- doxytag: member="UnitBase::BufferArrayType" ref="a593b06cfae47f7507b7dbc4702ce3efb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array2_d.html">NumericalArray2D</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array2_d.html">BufferArrayType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5ddea019e1891d8dab854c1b21ca3f9"></a><!-- doxytag: member="UnitBase::ChannelInternalType" ref="ab5ddea019e1891d8dab854c1b21ca3f9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_channel_internal_base.html">ChannelInternalBase</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_channel_internal_base.html">ChannelInternalType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a026f3040d41d5a92072f6088c065508b"></a><!-- doxytag: member="UnitBase::ChannelType" ref="a026f3040d41d5a92072f6088c065508b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_channel_base.html">ChannelBase</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_channel_base.html">ChannelType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adbef4b52a9c1508d66750f10946b2a72"></a><!-- doxytag: member="UnitBase::InitialUnit" ref="adbef4b52a9c1508d66750f10946b2a72" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array_1_1_initial_number.html">UnitType::InitialNumber</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array_1_1_initial_number.html">InitialUnit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fe763047acb612f46fbfe62ca3777a6"></a><!-- doxytag: member="UnitBase::Inputs" ref="a2fe763047acb612f46fbfe62ca3777a6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_input_dictionary.html">InputDictionary</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_input_dictionary.html">Inputs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6555cf2c5d7f1cc1aaaece05a1207565"></a><!-- doxytag: member="UnitBase::Internal" ref="a6555cf2c5d7f1cc1aaaece05a1207565" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_object_array_internal.html">ObjectArrayInternal</a>&lt;<a class="el" href="class_channel_base.html">ChannelType</a>&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_object_array_internal.html">Internal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a7e4c6b7c3510949ad880d92f5d3c804f">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a187eaefffead4cd269f692e3372cd577"></a><!-- doxytag: member="UnitBase::NullInternal" ref="a187eaefffead4cd269f692e3372cd577" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_null_channel_internal.html">NullChannelInternal</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_null_channel_internal.html">NullInternal</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47a57032361dd89ae13a00a2d9199a99"></a><!-- doxytag: member="UnitBase::UnitArray" ref="a47a57032361dd89ae13a00a2d9199a99" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array2_d.html">NumericalArray2D</a>&lt;<a class="el" href="class_channel_base.html">ChannelType</a>,<a class="el" href="class_numerical_array.html">UnitType</a>&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array2_d.html">UnitArray</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a72d04200ca52533aec32209d8f06d3ad"></a><!-- doxytag: member="UnitBase::UnitType" ref="a72d04200ca52533aec32209d8f06d3ad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_numerical_array.html">NumericalArray</a>&lt;<a class="el" href="class_channel_base.html">ChannelType</a>&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_numerical_array.html">UnitType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe0f2c157863200f41ffbaf38063cfa8"></a><!-- doxytag: member="UnitBase::VariableType" ref="abe0f2c157863200f41ffbaf38063cfa8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_variable.html">Variable</a>&lt;SampleType&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_variable.html">VariableType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a81fc09ea2199ab96ae945946bda07574"></a><!-- doxytag: member="UnitBase::Weak" ref="a81fc09ea2199ab96ae945946bda07574" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_weak_pointer_container.html">WeakPointerContainer</a>&lt;<a class="el" href="class_unit_base.html">UnitBase</a>&gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_weak_pointer_container.html">Weak</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_numerical_array.html#af615467ede36a9cf6410a92bb27cad41">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1f8d70fb911d20b57408b2b22a989f0e"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a1f8d70fb911d20b57408b2b22a989f0e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>This creates a Unit with a single null Channel. </p>

</div>
</div>
<a class="anchor" id="a419080b5014491cfbcda6fdb02752dff"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a419080b5014491cfbcda6fdb02752dff" args="(Internal *internal)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_object_array_internal.html">Internal</a> *&#160;</td>
          <td class="paramname"><em>internal</em></td><td>)</td>
          <td>  throw ()<code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adadd88eba71d1676c28989bae727337f"></a><!-- doxytag: member="UnitBase::UnitBase" ref="adadd88eba71d1676c28989bae727337f" args="(Dynamic const &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_dynamic.html">Dynamic</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab51068fdaa593550f896912d0f8e157a"></a><!-- doxytag: member="UnitBase::UnitBase" ref="ab51068fdaa593550f896912d0f8e157a" args="(ChannelType const &amp;channel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel_base.html">ChannelType</a> const &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This creates a Unit with a single Channel. </p>

</div>
</div>
<a class="anchor" id="a57a3ef6a6b7cb5b6b3796cc7553fa923"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a57a3ef6a6b7cb5b6b3796cc7553fa923" args="(ValueType const &amp;valueInit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType const &amp;&#160;</td>
          <td class="paramname"><em>valueInit</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant Unit constructor. </p>
<p>This creates a Unit with a single constant Channel. Ideally you could/should cache frequently used constants (e.g., 1, pi, etc). </p>

</div>
</div>
<a class="anchor" id="a6033c6242a569daaf9c736607f054a08"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a6033c6242a569daaf9c736607f054a08" args="(NumericalArray&lt; ValueType &gt; const &amp;values)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">NumericalArray</a>&lt; ValueType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multichannel Constant Unit constructor. </p>
<p>This creates a Unit with a multiple constant Channel objects derived from an array of numerical values. </p>

</div>
</div>
<a class="anchor" id="a8984afc268c34317885bb372cf0a834f"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a8984afc268c34317885bb372cf0a834f" args="(VariableType const &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_variable.html">VariableType</a> const &amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad639860274c7d3ee6170e4340edaeff0"></a><!-- doxytag: member="UnitBase::UnitBase" ref="ad639860274c7d3ee6170e4340edaeff0" args="(NumericalArray&lt; VariableType &gt; const &amp;variables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">NumericalArray</a>&lt; <a class="el" href="class_variable.html">VariableType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adeaf8e9083b75f03df0ef28ccd6432cd"></a><!-- doxytag: member="UnitBase::UnitBase" ref="adeaf8e9083b75f03df0ef28ccd6432cd" args="(UnitBase const &amp;copy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor from the base array type. </p>

</div>
</div>
<a class="anchor" id="a5843bc2a5db8af9e33b1cde20e769a4e"></a><!-- doxytag: member="UnitBase::UnitBase" ref="a5843bc2a5db8af9e33b1cde20e769a4e" args="(ObjectArray&lt; ChannelType &gt; const &amp;copy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::<a class="el" href="class_unit_base.html">UnitBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_object_array.html">ObjectArray</a>&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a88265b35eb65738f78899255c186efbe"></a><!-- doxytag: member="UnitBase::a2dB" ref="a88265b35eb65738f78899255c186efbe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::a2dB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'a2dB' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a4b1aba374f09890145c23e48ac790aca">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a554c1b387f114d20d4d5b1215ffa27a4"></a><!-- doxytag: member="UnitBase::abs" ref="a554c1b387f114d20d4d5b1215ffa27a4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'abs' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#adb5da433d91966c11849e4e3ae09b20c">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8b2d8eaf1da10d44b0a50976a2d601af"></a><!-- doxytag: member="UnitBase::absdif" ref="a8b2d8eaf1da10d44b0a50976a2d601af" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::absdif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'absdif' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="abf0d922e1c6ca460292375fc895e8048"></a><!-- doxytag: member="UnitBase::acos" ref="abf0d922e1c6ca460292375fc895e8048" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::acos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'acos' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a21247673f17dbb118748c1ef5868715d">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce47f1b83109061a4865b1ed3ff3578"></a><!-- doxytag: member="UnitBase::addop" ref="a9ce47f1b83109061a4865b1ed3ff3578" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::addop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'addop' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a3d6a3fbf0d6a2f1dcec1a7503e74b9d4"></a><!-- doxytag: member="UnitBase::applyMulAdd" ref="a3d6a3fbf0d6a2f1dcec1a7503e74b9d4" args="(UnitBase const &amp;mainUnit, UnitBase const &amp;mul, UnitBase const &amp;add)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::applyMulAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mainUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply multiply and addition operators to another unit. </p>
<p>Here <code>mul</code> will be ignored (not applied) if the value is a single channel constant equal to 1 (or null rather than just a constant 0). And <code>add</code> will be ignored (not applied) if it is a single channel constant equal to 0 (or null). On some platforms this might be implemented as a single multiply-and-add operation. </p>

</div>
</div>
<a class="anchor" id="ab18b0bf950a219fb07257aca3a5e5b76"></a><!-- doxytag: member="UnitBase::ar" ref="ab18b0bf950a219fb07257aca3a5e5b76" args="(BlockSize const &amp;preferredBlockSize=BlockSize::getDefault(), SampleRate const &amp;preferredSampleRate=SampleRate::getDefault())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::ar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_block_size.html">BlockSize</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredBlockSize</em> = <code>BlockSize::getDefault()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredSampleRate</em> = <code>SampleRate::getDefault()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resamples this unit to a different sample rate and/or block size. </p>

</div>
</div>
<a class="anchor" id="a4a3d949cd5c57c8fdb5badcca675497c"></a><!-- doxytag: member="UnitBase::asin" ref="a4a3d949cd5c57c8fdb5badcca675497c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::asin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'asin' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a78dc93f9d6203a2dc52f6b710cc53770">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acb2fdbd56ed53328c20327aa140c0f67"></a><!-- doxytag: member="UnitBase::atan" ref="acb2fdbd56ed53328c20327aa140c0f67" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::atan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'atan' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a958f1721d9c62493ec9cdb82a8656938">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a764a7d2d34e98b273063606d76bd703b"></a><!-- doxytag: member="UnitBase::atan2" ref="a764a7d2d34e98b273063606d76bd703b" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'atan2' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a35419f9d20253e5d52de37d4367c7311"></a><!-- doxytag: member="UnitBase::binary" ref="a35419f9d20253e5d52de37d4367c7311" args="(UnitBase const &amp;rightOperand) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;SampleType(*)(SampleType, SampleType) op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rightOperand</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Templated binary operator Unit creator. </p>

</div>
</div>
<a class="anchor" id="a9b625b6139101fc94112cb11fc25ede8"></a><!-- doxytag: member="UnitBase::ceil" ref="a9b625b6139101fc94112cb11fc25ede8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::ceil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'ceil' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aa42dd31de7f243533ffb84f5310ee5a7">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a33079afffb4c6cb3de7cd8c62841022b"></a><!-- doxytag: member="UnitBase::channelsHaveSameOverlap" ref="a33079afffb4c6cb3de7cd8c62841022b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::channelsHaveSameOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af384ce936686453e9689eeaf6457986f"></a><!-- doxytag: member="UnitBase::clip2" ref="af384ce936686453e9689eeaf6457986f" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::clip2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'clip2' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a6131c0e3755237cdec87441a2ab35ac1"></a><!-- doxytag: member="UnitBase::cos" ref="a6131c0e3755237cdec87441a2ab35ac1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::cos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cos' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ad8e91af12a57e6579d4fa944f0720bce">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a337c6c7cc6c6c69fb4245a2524ffd747"></a><!-- doxytag: member="UnitBase::cosh" ref="a337c6c7cc6c6c69fb4245a2524ffd747" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::cosh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cosh' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ae9dd56f3652efbbbaabe347ec9225f27">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8780779f9d31414671b0500d90a92a3e"></a><!-- doxytag: member="UnitBase::createFromInputs" ref="a8780779f9d31414671b0500d90a92a3e" args="(Inputs const &amp;inputs, typename ChannelInternalClassType::Data const &amp;data, BlockSize const &amp;preferredBlockSize, SampleRate const &amp;preferredSampleRate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class ChannelInternalClassType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::createFromInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_input_dictionary.html">Inputs</a> const &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ChannelInternalClassType::Data const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_block_size.html">BlockSize</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredBlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredSampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Primary means of creating Unit objects. </p>
<p>Used with most non-proxy-owning <a class="el" href="class_channel_internal.html" title="The base class from which most ChannelInternals should be derived.">ChannelInternal</a> classes. </p>

</div>
</div>
<a class="anchor" id="a2a0d4359ab797a76531b844097e5b828"></a><!-- doxytag: member="UnitBase::cubed" ref="a2a0d4359ab797a76531b844097e5b828" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::cubed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'cubed' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aba1b45c75b8a8e1a06708efd02c43464">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7c498c5e54d2438b9461599fde9fb13e"></a><!-- doxytag: member="UnitBase::d2r" ref="a7c498c5e54d2438b9461599fde9fb13e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::d2r </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'd2r' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a03bea6ba00183782f52b7c244292e678">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a887e8a891ea784749728c80c7bb670e2"></a><!-- doxytag: member="UnitBase::dB2a" ref="a887e8a891ea784749728c80c7bb670e2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::dB2a </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'dB2a' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a2be3c3ede1f2261a224c4da48e364b6e">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a44f39fd6c809e2c858ff959af4b41144"></a><!-- doxytag: member="UnitBase::dec" ref="a44f39fd6c809e2c858ff959af4b41144" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::dec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'dec' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#abd0ffdbf49fa2d8ee67110d58ace23d0">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6276eb0d25731e070427370a27a5e86f"></a><!-- doxytag: member="UnitBase::difsqr" ref="a6276eb0d25731e070427370a27a5e86f" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::difsqr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'difsqr' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a196824b85035fea76f750b642db6b42e"></a><!-- doxytag: member="UnitBase::distort" ref="a196824b85035fea76f750b642db6b42e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::distort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'distort' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a36bfa91e815e5f2a4e81d6a8a05a89a8">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6f745272970edbac5e99fb7cc30ffc4c"></a><!-- doxytag: member="UnitBase::divop" ref="a6f745272970edbac5e99fb7cc30ffc4c" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::divop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'divop' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a916cfd64bee364c7c7f06831d048b716"></a><!-- doxytag: member="UnitBase::emptyChannels" ref="a916cfd64bee364c7c7f06831d048b716" args="(const int numChannels)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::emptyChannels </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numChannels</em></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7558bfa0572b759fe423f1b8da02660"></a><!-- doxytag: member="UnitBase::exp" ref="ad7558bfa0572b759fe423f1b8da02660" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::exp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'exp' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aa97d16057f07d6400ac15f31497d34c2">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aed8bc12ebfab2788c950c70ad5fc8a5c"></a><!-- doxytag: member="UnitBase::f2m" ref="aed8bc12ebfab2788c950c70ad5fc8a5c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::f2m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'f2m' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a2b2452f6193c054cea33ce3a8162a085">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac65016aecebfe364574f328bf58a4f9f"></a><!-- doxytag: member="UnitBase::floor" ref="ac65016aecebfe364574f328bf58a4f9f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::floor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'floor' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a363a91ba97804be5c8217596807ccf5f">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7543750a30dd2f6f87fc61d8d627beec"></a><!-- doxytag: member="UnitBase::frac" ref="a7543750a30dd2f6f87fc61d8d627beec" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::frac </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'frac' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a9d212e39edd96f22493fb173f6a6d320">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad918f5ddca5ca251ffa25864e0b742a4"></a><!-- doxytag: member="UnitBase::fromWeak" ref="ad918f5ddca5ca251ffa25864e0b742a4" args="(Weak const &amp;weak)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::fromWeak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_weak_pointer_container.html">Weak</a> const &amp;&#160;</td>
          <td class="paramname"><em>weak</em></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a weakly linked copy of this object. </p>
<p>This will return a blank/empty/null object of this type if the original has already been deleted. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#afc49243d8e6c1c262a42d6691a5d6b32">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a20e388e3d6cd482f2cf417da0c8e5e88"></a><!-- doxytag: member="UnitBase::getBlockDurationInTicks" ref="a20e388e3d6cd482f2cf417da0c8e5e88" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getBlockDurationInTicks </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7156eb1df81d39faa613cc37dcd7687"></a><!-- doxytag: member="UnitBase::getBlockSize" ref="ad7156eb1df81d39faa613cc37dcd7687" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_block_size.html">BlockSize</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getBlockSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the block size of a specific channel in this unit. </p>

</div>
</div>
<a class="anchor" id="a955a5aea58d79f8cde2b8ed080342acd"></a><!-- doxytag: member="UnitBase::getBlockSize" ref="a955a5aea58d79f8cde2b8ed080342acd" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_block_size.html">BlockSize</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getBlockSize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the block size of a specific channel in this unit. </p>

</div>
</div>
<a class="anchor" id="ad9e6d5dad44ca41ebe4b6f6f56cab95e"></a><!-- doxytag: member="UnitBase::getChannel" ref="ad9e6d5dad44ca41ebe4b6f6f56cab95e" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a unit with the single channel specified. </p>
<p>This wraps the index so that it is always in range. It is alos recursive such that the returned channel has in turn stripped out the other multiple channels during the process. </p>

</div>
</div>
<a class="anchor" id="a6b70baa2348be760bdde2a8dcf0fb1ac"></a><!-- doxytag: member="UnitBase::getChannel" ref="a6b70baa2348be760bdde2a8dcf0fb1ac" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getChannel </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a unit with the single channel specified. </p>
<p>This wraps the index so that it is always in range. It is alos recursive such that the returned channel has in turn stripped out the other multiple channels during the process. </p>

</div>
</div>
<a class="anchor" id="ade8af08eb2577b175b09d57ff406d3a4"></a><!-- doxytag: member="UnitBase::getHalf" ref="ade8af08eb2577b175b09d57ff406d3a4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getHalf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a357165ca134a47f7204169b469e80b00"></a><!-- doxytag: member="UnitBase::getMaxBlockSize" ref="a357165ca134a47f7204169b469e80b00" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_block_size.html">BlockSize</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getMaxBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum block size in the array of channels in this unit. </p>

</div>
</div>
<a class="anchor" id="a293fb73766388495d285208bfd9ce0c3"></a><!-- doxytag: member="UnitBase::getMaxSampleRate" ref="a293fb73766388495d285208bfd9ce0c3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sample_rate.html">SampleRate</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getMaxSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum sample rate in the array of channels in this unit. </p>

</div>
</div>
<a class="anchor" id="aa7027499885c3206dee0b8b95f6e4fa2"></a><!-- doxytag: member="UnitBase::getMinBlockSize" ref="aa7027499885c3206dee0b8b95f6e4fa2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_block_size.html">BlockSize</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getMinBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimum block size in the array of channels in this unit. </p>

</div>
</div>
<a class="anchor" id="affc5ede3dc74cbb4cb3ad72ddb444975"></a><!-- doxytag: member="UnitBase::getMinSampleRate" ref="affc5ede3dc74cbb4cb3ad72ddb444975" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sample_rate.html">SampleRate</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getMinSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimum sample rate in the array of channels in this unit. </p>

</div>
</div>
<a class="anchor" id="a2c5e01a93876321a3e9fced5006c4521"></a><!-- doxytag: member="UnitBase::getNextTimeStamp" ref="a2c5e01a93876321a3e9fced5006c4521" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_time_stamp.html">TimeStamp</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getNextTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2a48b6e82bb1a93ee0b0ecd309688ff0"></a><!-- doxytag: member="UnitBase::getNull" ref="a2a48b6e82bb1a93ee0b0ecd309688ff0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_numerical_array.html#acd997a3e645f9c570204a3cb6cd5075e">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1f8d49c0651e927f3583fa6458a5b908"></a><!-- doxytag: member="UnitBase::getNumChannels" ref="a1f8d49c0651e927f3583fa6458a5b908" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getNumChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of channels in this unit. </p>

</div>
</div>
<a class="anchor" id="a2b2a51f4a958f937afa37f31b6ba763c"></a><!-- doxytag: member="UnitBase::getOne" ref="a2b2a51f4a958f937afa37f31b6ba763c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a08100240d3ae6e9f1dbe9add73d24d06"></a><!-- doxytag: member="UnitBase::getOutputBuffer" ref="a08100240d3ae6e9f1dbe9add73d24d06" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_numerical_array.html">Buffer</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the output buffer of a specific channel. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="a65a60c385d78f0221acee780808e1517"></a><!-- doxytag: member="UnitBase::getOutputBuffer" ref="a65a60c385d78f0221acee780808e1517" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_numerical_array.html">Buffer</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the output buffer of a specific channel. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="a52d71e0871badee91a8e565107e55936"></a><!-- doxytag: member="UnitBase::getOutputSamples" ref="a52d71e0871badee91a8e565107e55936" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SampleType* <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOutputSamples </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the raw samples of a specific channel. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="a43faf13fd6fba7d41104578862a65863"></a><!-- doxytag: member="UnitBase::getOutputSamples" ref="a43faf13fd6fba7d41104578862a65863" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const SampleType* <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOutputSamples </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the raw samples of a specific channel. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="a2a7a1b5cbe1b247e20d48927ec5fb676"></a><!-- doxytag: member="UnitBase::getOverlap" ref="a2a7a1b5cbe1b247e20d48927ec5fb676" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_variable.html">DoubleVariable</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOverlap </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5903a71f02960ca268b94e2d481f8af9"></a><!-- doxytag: member="UnitBase::getOverlap" ref="a5903a71f02960ca268b94e2d481f8af9" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_variable.html">DoubleVariable</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getOverlap </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84f054cd5c680d2d8cd7d1788709a99e"></a><!-- doxytag: member="UnitBase::getPi" ref="a84f054cd5c680d2d8cd7d1788709a99e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getPi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a56260640747b48ffa5b3f6de840af3f3"></a><!-- doxytag: member="UnitBase::getSampleDurationInTicks" ref="a56260640747b48ffa5b3f6de840af3f3" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getSampleDurationInTicks </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d3580e278cb7e0d6ffc232f7c0fca2c"></a><!-- doxytag: member="UnitBase::getSampleRate" ref="a5d3580e278cb7e0d6ffc232f7c0fca2c" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sample_rate.html">SampleRate</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getSampleRate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sample rate of a specific channel in this unit. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="a71526cc54801d1c5d2f312b47090618d"></a><!-- doxytag: member="UnitBase::getSampleRate" ref="a71526cc54801d1c5d2f312b47090618d" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sample_rate.html">SampleRate</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getSampleRate </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sample rate of a specific channel in this unit. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="aea8acd5fba79b7fe97712e2e9a09275c"></a><!-- doxytag: member="UnitBase::getSampleTypeCode" ref="aea8acd5fba79b7fe97712e2e9a09275c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getSampleTypeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b89a879318d421de48965b84240dcc5"></a><!-- doxytag: member="UnitBase::getTwo" ref="a8b89a879318d421de48965b84240dcc5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getTwo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9421515920a65effeb303796895d0d49"></a><!-- doxytag: member="UnitBase::getTwoPi" ref="a9421515920a65effeb303796895d0d49" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getTwoPi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2891d6c1839d13315f8f950631688518"></a><!-- doxytag: member="UnitBase::getTypeCode" ref="a2891d6c1839d13315f8f950631688518" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getTypeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a095cf7075cb975098c35eaac78f6225e">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0abca48d077f3f49b5c9639ac64eec5a"></a><!-- doxytag: member="UnitBase::getValue" ref="a0abca48d077f3f49b5c9639ac64eec5a" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const SampleType&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current value of a specific channel in this unit. </p>
<p>Indices out of range will be wrapped to the available channels. </p>

</div>
</div>
<a class="anchor" id="abf3290de37effc698c5c81055587ee82"></a><!-- doxytag: member="UnitBase::getZero" ref="abf3290de37effc698c5c81055587ee82" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::getZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12fde7570fe1ff64ef675c0d5f91b736"></a><!-- doxytag: member="UnitBase::hypot" ref="a12fde7570fe1ff64ef675c0d5f91b736" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'hypot' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a2fd07c9e23fb1dcf2ba895306ff3cbc8"></a><!-- doxytag: member="UnitBase::inc" ref="a2fd07c9e23fb1dcf2ba895306ff3cbc8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::inc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'inc' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ac99a652927b8588c19e3b0fb58ced052">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a114f2a825a7fb1791ceefeba49df2c2f"></a><!-- doxytag: member="UnitBase::isConstant" ref="a114f2a825a7fb1791ceefeba49df2c2f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if this unit contains only a single constant channel. </p>

</div>
</div>
<a class="anchor" id="a5a9473b849ca895b72d058ad54f02eae"></a><!-- doxytag: member="UnitBase::isConstant" ref="a5a9473b849ca895b72d058ad54f02eae" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isConstant </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a769265718d2edfe60c43e4cf797c0110"></a><!-- doxytag: member="UnitBase::isEqualTo" ref="a769265718d2edfe60c43e4cf797c0110" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isEqualTo' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="af70d74f6f77c5c5866146c89a2d123c9"></a><!-- doxytag: member="UnitBase::isGreaterThan" ref="af70d74f6f77c5c5866146c89a2d123c9" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isGreaterThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isGreaterThan' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="ac6b0846c1172e1fa275d51beb7895559"></a><!-- doxytag: member="UnitBase::isGreaterThanOrEqualTo" ref="ac6b0846c1172e1fa275d51beb7895559" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isGreaterThanOrEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isGreaterThanOrEqualTo' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="af6582e308726a8e4fb63235ca5b73016"></a><!-- doxytag: member="UnitBase::isLessThan" ref="af6582e308726a8e4fb63235ca5b73016" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isLessThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isLessThan' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a1e52af4d320c6b8ef1518458868a5953"></a><!-- doxytag: member="UnitBase::isLessThanOrEqualTo" ref="a1e52af4d320c6b8ef1518458868a5953" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isLessThanOrEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isLessThanOrEqualTo' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="ac107382b7aca87bb65fc8beb05c51b5b"></a><!-- doxytag: member="UnitBase::isNotConstant" ref="ac107382b7aca87bb65fc8beb05c51b5b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNotConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>false</code> if this unit contains only a single constant channel. </p>

</div>
</div>
<a class="anchor" id="a4dc53a4989df63faf42b4c7b648ca5e3"></a><!-- doxytag: member="UnitBase::isNotConstant" ref="a4dc53a4989df63faf42b4c7b648ca5e3" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNotConstant </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cbfe5d8e80d28df1f5241e1ea874929"></a><!-- doxytag: member="UnitBase::isNotEqualTo" ref="a9cbfe5d8e80d28df1f5241e1ea874929" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNotEqualTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'isNotEqualTo' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="afebc412bbc462492297cb0bb96d2b46a"></a><!-- doxytag: member="UnitBase::isNotNull" ref="afebc412bbc462492297cb0bb96d2b46a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>false</code> if this unit contains only a single null channel. </p>

<p>Reimplemented from <a class="el" href="class_smart_pointer_container_base.html#a9255ebf1edd50a68f0e13fb44bb64b96">SmartPointerContainerBase&lt; ObjectArrayInternal&lt; ChannelBase&lt; SampleType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a405c7135663599a9603393a393f0bb66"></a><!-- doxytag: member="UnitBase::isNotNull" ref="a405c7135663599a9603393a393f0bb66" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNotNull </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b9e0433de29cce99dfa9e04cf7b4074"></a><!-- doxytag: member="UnitBase::isNull" ref="a2b9e0433de29cce99dfa9e04cf7b4074" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if this unit contains only a single null channel. </p>

<p>Reimplemented from <a class="el" href="class_smart_pointer_container_base.html#aac32791ba8b99b3192c00d9a8f8c8230">SmartPointerContainerBase&lt; ObjectArrayInternal&lt; ChannelBase&lt; SampleType &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aee5909be3f87dca9156fe4611b7c94d6"></a><!-- doxytag: member="UnitBase::isNull" ref="aee5909be3f87dca9156fe4611b7c94d6" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::isNull </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9204dbea9636ed67d40fd663333ee44"></a><!-- doxytag: member="UnitBase::kr" ref="ab9204dbea9636ed67d40fd663333ee44" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::kr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resamples this unit to the default control rate sample rate and block size. </p>

</div>
</div>
<a class="anchor" id="acc7d6774a51a7f17c98e2369158bd02a"></a><!-- doxytag: member="UnitBase::log" ref="acc7d6774a51a7f17c98e2369158bd02a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aaac2483594423eca542b918f3868bafa">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abae5ddb502112cbdaaba960ed041fe0a"></a><!-- doxytag: member="UnitBase::log10" ref="abae5ddb502112cbdaaba960ed041fe0a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::log10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log10' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ae46ae0e874297a5ef8a29ba9ee1d6732">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af0d0038175b087694a309d47b66bf440"></a><!-- doxytag: member="UnitBase::log2" ref="af0d0038175b087694a309d47b66bf440" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::log2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'log2' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a070b5d8792fba8be0e49aa67d466c7c5">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad8b08088db7545b26fe6d48872f08203"></a><!-- doxytag: member="UnitBase::m2f" ref="ad8b08088db7545b26fe6d48872f08203" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::m2f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'm2f' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a0eaa8e96782b6afb620ad4bcd09b5bd1">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4cdf04233317f510dda567bda01fb5dd"></a><!-- doxytag: member="UnitBase::max" ref="a4cdf04233317f510dda567bda01fb5dd" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'max' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a64cf093d072095318f4c27a476d12208"></a><!-- doxytag: member="UnitBase::min" ref="a64cf093d072095318f4c27a476d12208" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'min' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a612cb53496d3ceb671bed8a632b77156"></a><!-- doxytag: member="UnitBase::mix" ref="a612cb53496d3ceb671bed8a632b77156" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::mix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mixes this unit down to a single channel. </p>

</div>
</div>
<a class="anchor" id="a4f336f25723b5330c64b24fb964d568b"></a><!-- doxytag: member="UnitBase::mixBarrier" ref="a4f336f25723b5330c64b24fb964d568b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::mixBarrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mixes this unit down to a single channel with and auto-deletion prevention barrier. </p>
<p>This prevents things like envelopes from releasing the mixer that contains this unit. </p>

</div>
</div>
<a class="anchor" id="a3218bcc6c0d55a2b19b6d5ffd8a0af31"></a><!-- doxytag: member="UnitBase::move" ref="a3218bcc6c0d55a2b19b6d5ffd8a0af31" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::move </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'move' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a874ca968256c98cd3832c186c46b3982">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af0679918598bab4c013cfc4f2d5c268f"></a><!-- doxytag: member="UnitBase::mulop" ref="af0679918598bab4c013cfc4f2d5c268f" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::mulop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'mulop' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a0314952ec0909fb5cce927b12efc9a7f"></a><!-- doxytag: member="UnitBase::neg" ref="a0314952ec0909fb5cce927b12efc9a7f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::neg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'neg' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a55de58ebf08c5847b883fc490d08b9d4">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a61fabb5b95c3d391451bd5c394447d49"></a><!-- doxytag: member="UnitBase::operator*" ref="a61fabb5b95c3d391451bd5c394447d49" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '*' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a8368368153fe158df9e918bc6ba80022">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afc7424b74a1185a578ba25c499986cff"></a><!-- doxytag: member="UnitBase::operator*=" ref="afc7424b74a1185a578ba25c499986cff" args="(RightType const &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '*' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a1a43141b93f7a8e24d777acb30ca115c">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a783d354004272b602e116d058294f157"></a><!-- doxytag: member="UnitBase::operator+" ref="a783d354004272b602e116d058294f157" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '+' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ac73002a959b7fbdb0e1bf49150e00ac7">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f73b933867b036a575ff01c621ff08"></a><!-- doxytag: member="UnitBase::operator+=" ref="ad7f73b933867b036a575ff01c621ff08" args="(RightType const &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '+' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a2cbf65a8a44ec8fbe2afab55cd39418b">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6926f7a29b3c0aeca299c649d885abee"></a><!-- doxytag: member="UnitBase::operator," ref="a6926f7a29b3c0aeca299c649d885abee" args="(UnitType const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator, </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">UnitType</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a706c00f62f694ec1c825ac72697156fa"></a><!-- doxytag: member="UnitBase::operator," ref="a706c00f62f694ec1c825ac72697156fa" args="(UnitBase const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator, </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc6b6d450e027fba5242bf9985eb614c"></a><!-- doxytag: member="UnitBase::operator&#45;" ref="abc6b6d450e027fba5242bf9985eb614c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary '-' operator to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a403fa7e62e11b0315fcf1d573a6c86b4">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa00cdc04e68728d2892ba17b6efae5c2"></a><!-- doxytag: member="UnitBase::operator&#45;" ref="aa00cdc04e68728d2892ba17b6efae5c2" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '-' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#ad8c78788dec82a15c338319174e891c2">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a03113ab3519c80f88e78f97ea272bd94"></a><!-- doxytag: member="UnitBase::operator&#45;=" ref="a03113ab3519c80f88e78f97ea272bd94" args="(RightType const &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '-' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a5538284563eac6f5682d50976ea9119f">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a50be2f9d83e178bd7ad755364655d357"></a><!-- doxytag: member="UnitBase::operator/" ref="a50be2f9d83e178bd7ad755364655d357" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '/' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a4290f465e129c3acb29872229f31ea26">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0c0b2547f77f2840de847a77cf39f87f"></a><!-- doxytag: member="UnitBase::operator/=" ref="a0c0b2547f77f2840de847a77cf39f87f" args="(RightType const &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> and assign it to this one by applying the binary '/' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aeab50549403525ae68bf3eea47869601">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3fbcb0b247b7335b27aa90c454b30308"></a><!-- doxytag: member="UnitBase::operator&lt;" ref="a3fbcb0b247b7335b27aa90c454b30308" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&lt;' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a0fc984fa1bddcb904611f9c4c8ac355c">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a24aa111569583ac0e9329c837caaeece"></a><!-- doxytag: member="UnitBase::operator&lt;&lt;" ref="a24aa111569583ac0e9329c837caaeece" args="(UnitType const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_numerical_array2_d.html">UnitArray</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">UnitType</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a89dce5a55adbbdfaae908958b760012d"></a><!-- doxytag: member="UnitBase::operator&lt;&lt;" ref="a89dce5a55adbbdfaae908958b760012d" args="(UnitBase const &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_numerical_array2_d.html">UnitArray</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd22385bfeb42dad70f0ef9d65e3bbcf"></a><!-- doxytag: member="UnitBase::operator&lt;=" ref="abd22385bfeb42dad70f0ef9d65e3bbcf" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&lt;=' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a66f4fe62052817c7a7452d4d8129c40f">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac5d6ddf8691c78944d448529f37006bb"></a><!-- doxytag: member="UnitBase::operator=" ref="ac5d6ddf8691c78944d448529f37006bb" args="(ChannelType const &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel_base.html">ChannelType</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator from a single channel. </p>

</div>
</div>
<a class="anchor" id="ae9d0d472add7bdcb4aec4baf35c52cc8"></a><!-- doxytag: member="UnitBase::operator=" ref="ae9d0d472add7bdcb4aec4baf35c52cc8" args="(UnitType const &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">UnitType</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator from the base array type. </p>

</div>
</div>
<a class="anchor" id="aab0d06b9df0c6d0a56f469b2ee572c09"></a><!-- doxytag: member="UnitBase::operator=" ref="aab0d06b9df0c6d0a56f469b2ee572c09" args="(ObjectArray&lt; ChannelType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_object_array.html">ObjectArray</a>&lt; <a class="el" href="class_channel_base.html">ChannelType</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator from an array of channels. </p>

</div>
</div>
<a class="anchor" id="a7d7469eeee1b574d5299762f8a3d7036"></a><!-- doxytag: member="UnitBase::operator=" ref="a7d7469eeee1b574d5299762f8a3d7036" args="(UnitBase const &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="a5a1d2e2d65b20054478ab234e9a920a8"></a><!-- doxytag: member="UnitBase::operator&gt;" ref="a5a1d2e2d65b20054478ab234e9a920a8" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&gt;' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a8d0c7dc1faa2bb93bc3cb9eade40d7eb">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adafd268de4860a36a14c6d63f6247f28"></a><!-- doxytag: member="UnitBase::operator&gt;=" ref="adafd268de4860a36a14c6d63f6247f28" args="(RightType const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class RightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">RightType const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary '&gt;=' operator to this and the <em>right</em> argument. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a1aedf3452546d858bc38253ee95b6904">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afd08e14c94c1e344a05b957308caa472"></a><!-- doxytag: member="UnitBase::operator[]" ref="afd08e14c94c1e344a05b957308caa472" args="(const int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a unit with the single channel specified. </p>
<p>This wraps the index so that it is always in range. It is alos recursive such that the returned channel has in turn stripped out the other multiple channels during the process. </p>

<p>Reimplemented from <a class="el" href="class_object_array.html#a0bc80ee77d245f592d75f480293937b6">ObjectArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a51d3e16937b30c0469661261e6acb42d"></a><!-- doxytag: member="UnitBase::operator[]" ref="a51d3e16937b30c0469661261e6acb42d" args="(const int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a unit with the single channel specified. </p>
<p>This wraps the index so that it is always in range. It is alos recursive such that the returned channel has in turn stripped out the other multiple channels during the process. </p>

<p>Reimplemented from <a class="el" href="class_object_array.html#a64873f1b21d3888d606f555da6a2014a">ObjectArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae4b03e22f6ff31654815c457a85a78c6"></a><!-- doxytag: member="UnitBase::overlapMake" ref="ae4b03e22f6ff31654815c457a85a78c6" args="(DoubleVariable const &amp;overlap=DoubleVariable::getHalf())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::overlapMake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_variable.html">DoubleVariable</a> const &amp;&#160;</td>
          <td class="paramname"><em>overlap</em> = <code>DoubleVariable::getHalf()</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an overlapping process from this unit's contrinuous stream. </p>

</div>
</div>
<a class="anchor" id="a3786ff0d71ec1cc2ab7f5c2de65ec36a"></a><!-- doxytag: member="UnitBase::overlapMix" ref="a3786ff0d71ec1cc2ab7f5c2de65ec36a" args="(DoubleVariable const &amp;overlap=DoubleVariable::getHalf())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::overlapMix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_variable.html">DoubleVariable</a> const &amp;&#160;</td>
          <td class="paramname"><em>overlap</em> = <code>DoubleVariable::getHalf()</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mix down overlapping process to a continuous stream. </p>

</div>
</div>
<a class="anchor" id="aa44db5c79cca4f9ea0f7bb984cf2d8f9"></a><!-- doxytag: member="UnitBase::pow" ref="aa44db5c79cca4f9ea0f7bb984cf2d8f9" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'pow' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a03ff4846d93ac89f7afab49972a9762d"></a><!-- doxytag: member="UnitBase::process" ref="a03ff4846d93ac89f7afab49972a9762d" args="(ProcessInfo &amp;info, const int channel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_numerical_array.html">Buffer</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_process_info.html">ProcessInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a specific channel in this unit. </p>
<p>The host should prepare a <a class="el" href="class_process_info.html" title="Holds information about the Unit graph.">ProcessInfo</a> which is passed to this function for each required block of data. This is generally used by <a class="el" href="class_channel_internal.html" title="The base class from which most ChannelInternals should be derived.">ChannelInternal</a> subclasses when obtaining input data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The buffer from the requested channel. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b69c2c88f25b4289ba2ac4ed01bebba"></a><!-- doxytag: member="UnitBase::process" ref="a0b69c2c88f25b4289ba2ac4ed01bebba" args="(ProcessInfo &amp;info)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_process_info.html">ProcessInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process all channels in this unit. </p>
<p>The host should prepare a <a class="el" href="class_process_info.html" title="Holds information about the Unit graph.">ProcessInfo</a> which is passed to this function for each required block of data. </p>

</div>
</div>
<a class="anchor" id="ab29dbe0f2064dcca44bf2f0e7371c782"></a><!-- doxytag: member="UnitBase::proxiesFromInputs" ref="ab29dbe0f2064dcca44bf2f0e7371c782" args="(Inputs const &amp;inputs, typename ProxyOwnerChannelInternalClassType::Data const &amp;data, BlockSize const &amp;preferredBlockSize, SampleRate const &amp;preferredSampleRate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;class ProxyOwnerChannelInternalClassType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::proxiesFromInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_input_dictionary.html">Inputs</a> const &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ProxyOwnerChannelInternalClassType::Data const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_block_size.html">BlockSize</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredBlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;&#160;</td>
          <td class="paramname"><em>preferredSampleRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Primary means of creating Unit objects with proxies. </p>
<p>Used with most proxy-owning <a class="el" href="class_channel_internal.html" title="The base class from which most ChannelInternals should be derived.">ChannelInternal</a> classes. </p>

</div>
</div>
<a class="anchor" id="a336e560bdcb43adae1b83f1dc9f3d114"></a><!-- doxytag: member="UnitBase::put" ref="a336e560bdcb43adae1b83f1dc9f3d114" args="(const int index, UnitBase const &amp;channel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd8eaab7d56faed695675c0e98e4cd0f"></a><!-- doxytag: member="UnitBase::r2d" ref="abd8eaab7d56faed695675c0e98e4cd0f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::r2d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'r2d' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a60278e868bb7668d86217f640d113920">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aedf8a851d44920f7c5569f5357587d01"></a><!-- doxytag: member="UnitBase::reciprocal" ref="aedf8a851d44920f7c5569f5357587d01" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::reciprocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'reciprocal' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aab34a0718dfa0dd4ae5fdbc2c1c00773">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afa2a02a2c6fb51b2607ab7a1507788fb"></a><!-- doxytag: member="UnitBase::round" ref="afa2a02a2c6fb51b2607ab7a1507788fb" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'round' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a9cee8690b55ba3b627eb5c741ae4d54c"></a><!-- doxytag: member="UnitBase::setBlockSize" ref="a9cee8690b55ba3b627eb5c741ae4d54c" args="(BlockSize const &amp;newBlockSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setBlockSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_block_size.html">BlockSize</a> const &amp;&#160;</td>
          <td class="paramname"><em>newBlockSize</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the block size of all channels in this unit. </p>

</div>
</div>
<a class="anchor" id="a29c48bc96d194d72dc3ad84cb073aeb0"></a><!-- doxytag: member="UnitBase::setLabel" ref="a29c48bc96d194d72dc3ad84cb073aeb0" args="(Text const &amp;unitId)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a>&amp; <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_text.html">Text</a> const &amp;&#160;</td>
          <td class="paramname"><em>unitId</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables a custom name to be set. </p>
<p>This conventiently returns this unit so it can be used in nested graph construction functions. </p>

</div>
</div>
<a class="anchor" id="a5971dc08c2dc28db827df3b7ea671e94"></a><!-- doxytag: member="UnitBase::setOutputBuffer" ref="a5971dc08c2dc28db827df3b7ea671e94" args="(BufferArrayType const &amp;externalBuffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setOutputBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_numerical_array2_d.html">BufferArrayType</a> const &amp;&#160;</td>
          <td class="paramname"><em>externalBuffer</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the output buffers of this unit's channels to use external buffers. </p>

</div>
</div>
<a class="anchor" id="aed36ad8bca094f3fa98d0a134cb2d36f"></a><!-- doxytag: member="UnitBase::setOutputBuffer" ref="aed36ad8bca094f3fa98d0a134cb2d36f" args="(const int index, Buffer const &amp;externalBuffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setOutputBuffer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_numerical_array.html">Buffer</a> const &amp;&#160;</td>
          <td class="paramname"><em>externalBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the output buffer of a specific channel to use an external buffer. </p>

</div>
</div>
<a class="anchor" id="ae6b374388db6dd4125bd22350b765187"></a><!-- doxytag: member="UnitBase::setSampleRate" ref="ae6b374388db6dd4125bd22350b765187" args="(SampleRate const &amp;newSampleRate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setSampleRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sample_rate.html">SampleRate</a> const &amp;&#160;</td>
          <td class="paramname"><em>newSampleRate</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the sample rate of all channels in this unit. </p>

</div>
</div>
<a class="anchor" id="af32d1a3c659048be9d9dc8b22c693491"></a><!-- doxytag: member="UnitBase::setToNull" ref="af32d1a3c659048be9d9dc8b22c693491" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::setToNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a498954490886e3acd13d5747f65d290a"></a><!-- doxytag: member="UnitBase::sign" ref="a498954490886e3acd13d5747f65d290a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sign' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a2c97c407bb1d944e3c357c7ff22eb91d">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adfd01e6c59c15369e4bfda8f5776b570"></a><!-- doxytag: member="UnitBase::sin" ref="adfd01e6c59c15369e4bfda8f5776b570" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sin' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a8c6a229a1ca6aa62ce2f16a7cddc81c7">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7042232fed9247cb1c185a4405e62638"></a><!-- doxytag: member="UnitBase::sinh" ref="a7042232fed9247cb1c185a4405e62638" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sinh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sinh' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a93eff4090af911add420281e8825debc">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad44f311b28ebda6d59a8aca92b937ae9"></a><!-- doxytag: member="UnitBase::sqrdif" ref="ad44f311b28ebda6d59a8aca92b937ae9" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sqrdif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sqrdif' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="adb1fc080c1b85651ab0f0a2da2a37fbe"></a><!-- doxytag: member="UnitBase::sqrsum" ref="adb1fc080c1b85651ab0f0a2da2a37fbe" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sqrsum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sqrsum' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="ad3c6085937821c153209ae38a6471d85"></a><!-- doxytag: member="UnitBase::sqrt" ref="ad3c6085937821c153209ae38a6471d85" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'sqrt' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a99590a6747640c9adf4ecd0dab889507">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad1bd91b6d6644cc438f16489ada2da9f"></a><!-- doxytag: member="UnitBase::squared" ref="ad1bd91b6d6644cc438f16489ada2da9f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::squared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'squared' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a10c88d42c1a68c2cf019ba599ce39386">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a007485d6e5d46ba2f1c081b9f156d932"></a><!-- doxytag: member="UnitBase::subop" ref="a007485d6e5d46ba2f1c081b9f156d932" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::subop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'subop' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a9859d688170b57861e5373728a4304f4"></a><!-- doxytag: member="UnitBase::sumsqr" ref="a9859d688170b57861e5373728a4304f4" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::sumsqr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'sumsqr' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a0af939bf3ff068d959ae5be1fa581bce"></a><!-- doxytag: member="UnitBase::tan" ref="a0af939bf3ff068d959ae5be1fa581bce" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::tan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'tan' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a012a46fa5971b4e4d453fd3134adcc6e">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aad9b00972e19f50911631486aa44f590"></a><!-- doxytag: member="UnitBase::tanh" ref="aad9b00972e19f50911631486aa44f590" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::tanh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'tanh' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a279cbc086c73080ae0ee9f341cd6934f">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adab69c58f3fe0588d0d4aad52935e254"></a><!-- doxytag: member="UnitBase::thresh" ref="adab69c58f3fe0588d0d4aad52935e254" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::thresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'thresh' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a51eebe85fa983b84bc44a2def0a8ac7d"></a><!-- doxytag: member="UnitBase::trunc" ref="a51eebe85fa983b84bc44a2def0a8ac7d" args="(UnitBase const &amp;right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the binary 'trunc' function to this one and the <em>right</em> argument. </p>

</div>
</div>
<a class="anchor" id="a142b2de4be916e9eeec7957f550e3518"></a><!-- doxytag: member="UnitBase::unary" ref="a142b2de4be916e9eeec7957f550e3518" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
<div class="memtemplate">
template&lt;SampleType(*)(SampleType) op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::unary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Templated unary operator Unit creator. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#a533dbf3a2404de6f1618e0559231b785">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a928af1dac6e8b66ab2c9d7a7ceaa10a7"></a><!-- doxytag: member="UnitBase::zap" ref="a928af1dac6e8b66ab2c9d7a7ceaa10a7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SampleType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_base.html">UnitBase</a> <a class="el" href="class_unit_base.html">UnitBase</a>&lt; SampleType &gt;::zap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects.">UnitBase</a> by applying the unary 'zap' function to this one. </p>

<p>Reimplemented from <a class="el" href="class_numerical_array.html#aa803bf54847396f2a846f435676ab117">NumericalArray&lt; ChannelBase&lt; SampleType &gt; &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="plonk___unit_8h_source.html">plonk_Unit.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 21 2012 13:47:40 for plinkplonk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
