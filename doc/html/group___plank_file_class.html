<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pl-nk: Plank File class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk&#160;<span id="projectnumber">v0.4.5</span></div>
   <div id="projectbrief">Plonk|Plink|Plank are a set of cross-platform C/C++ frameworks for audio software development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Plank File class</div>  </div>
<div class="ingroups"><a class="el" href="group___plank_classes.html">Plank classes</a></div></div>
<div class="contents">

<p>A crossplatform file reading/writing utility.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga58c5e1d5a7b1a826f055f4f4afa697a5">PLANKFILE_READ</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify 'read' mode.  <a href="#ga58c5e1d5a7b1a826f055f4f4afa697a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga97b49043ad22933861f58b6055b402c9">PLANKFILE_WRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify 'write' mode.  <a href="#ga97b49043ad22933861f58b6055b402c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga740a67928b707cef8887cbf95002fd77">PLANKFILE_BINARY</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify 'binary' mode.  <a href="#ga740a67928b707cef8887cbf95002fd77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac5e888429c54d187fe6c3d4ae7aabb89">PLANKFILE_APPEND</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify 'append' mode.  <a href="#gac5e888429c54d187fe6c3d4ae7aabb89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga6780b0323fabdb2768c6195a070d4ecf">PLANKFILE_NEW</a>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify 'new' mode.  <a href="#ga6780b0323fabdb2768c6195a070d4ecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gae8cee2fd2a05cca85533363920cda208">PLANKFILE_BIGENDIAN</a>&#160;&#160;&#160;(1 &lt;&lt; 5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify big endian mode for binary files (otherwise it will be little endian).  <a href="#gae8cee2fd2a05cca85533363920cda208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf9b6225e790088d064215175430846cf">PLANKFILE_OWNMULTI</a>&#160;&#160;&#160;(1 &lt;&lt; 6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify that a multi file object should be owned by the File object.  <a href="#gaf9b6225e790088d064215175430846cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga31ae3a1fb4cc0df712aa68e3bb1d5885">PLANKFILE_DYNAMICARRAYOWNED</a>&#160;&#160;&#160;(1 &lt;&lt; 6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to identify when in DynamciArray mode that the array is owned by this object.  <a href="#ga31ae3a1fb4cc0df712aa68e3bb1d5885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga977a90e90ad400a6c6927d4ea1a4fe20">PLANKFILE_MASK</a>&#160;&#160;&#160;(PLANKFILE_READ | PLANKFILE_WRITE | PLANKFILE_BINARY | PLANKFILE_APPEND | PLANKFILE_NEW)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode mask with all the mode flags except PLANKFILE_BIGENDIAN.  <a href="#ga977a90e90ad400a6c6927d4ea1a4fe20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga007fd6edcef4c3e78f9822c446b65508">PLANKFILE_ALL</a>&#160;&#160;&#160;(PLANKFILE_MASK | PLANKFILE_BIGENDIAN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode mask with all the mode flags.  <a href="#ga007fd6edcef4c3e78f9822c446b65508"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct PlankFile *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque reference to the <em>Plank File</em> object.  <a href="#ga7a3834c3811eceffb81213155fd14e59"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga9010c7fcd068f755105a30409cfda8a7">pl_FileErase</a> (const char *filepath)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file with the given path form the filesystem.  <a href="#ga9010c7fcd068f755105a30409cfda8a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf3d641d92bc5a937e2d44127b690bf2e">pl_File_CreateAndInit</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise a <em>Plank File</em> object and return an oqaque reference to it.  <a href="#gaf3d641d92bc5a937e2d44127b690bf2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaa082f0286f7db42cb80a1d3a02ef0966">pl_File_Create</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <em>Plank File</em> object and return an oqaque reference to it.  <a href="#gaa082f0286f7db42cb80a1d3a02ef0966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga28528f2257dadba6daf977160b706ccd">pl_File_Init</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <em>Plank File</em> object.  <a href="#ga28528f2257dadba6daf977160b706ccd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga38f26cb71c29db7e1a4e2b45f0d769ad">pl_File_DeInit</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialise a <em>Plank File</em> object.  <a href="#ga38f26cb71c29db7e1a4e2b45f0d769ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gab857b1acf9fae3d94d3c08bc4883a1fa">pl_File_Destroy</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <em>Plank File</em> object.  <a href="#gab857b1acf9fae3d94d3c08bc4883a1fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gae559595e5fd9ae0c9516748b07e1102c">pl_File_Open</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const int mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file.  <a href="#gae559595e5fd9ae0c9516748b07e1102c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga7c4ce239aeac329367be8ca3930e7a51">pl_File_OpenTextRead</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andWrite)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a text file for reading and optionally writing.  <a href="#ga7c4ce239aeac329367be8ca3930e7a51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga4c3df13be9beaa2a4a75bf56ee09dc34">pl_File_OpenTextWrite</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a text file for writing and optionally reading.  <a href="#ga4c3df13be9beaa2a4a75bf56ee09dc34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac0e2fb70c1f212c23860a3cefaeebf15">pl_File_OpenBinaryRead</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andWrite, const PlankB isBigEndian)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a binary file for reading and optionally writing.  <a href="#gac0e2fb70c1f212c23860a3cefaeebf15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga660dbb16fe9917836248430fb355576c">pl_File_OpenBinaryWrite</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile, const PlankB isBigEndian)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a binary file for writing and optionally reading.  <a href="#ga660dbb16fe9917836248430fb355576c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gae80ca5d7e106be93f18cdc48d05fd895">pl_File_OpenBinaryNativeEndianRead</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andWrite)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a binary file for reading and optionally writing in the native endian format.  <a href="#gae80ca5d7e106be93f18cdc48d05fd895"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf777842917cc18433b3828ecc9537d41">pl_File_OpenBinaryNativeEndianWrite</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a binary file for writing and optionally reading in the native endian format.  <a href="#gaf777842917cc18433b3828ecc9537d41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf0125ef82c4af98c33534d25fa1aad9c">pl_File_IsBigEndian</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file object is in big endian format.  <a href="#gaf0125ef82c4af98c33534d25fa1aad9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga6be51df6cd1114dc7cd8d6704e6aec99">pl_File_IsLittleEndian</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file object is in little endian format.  <a href="#ga6be51df6cd1114dc7cd8d6704e6aec99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaab3dd901ce039e26debe9e792492744b">pl_File_IsNativeEndian</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file object is in the native endian format.  <a href="#gaab3dd901ce039e26debe9e792492744b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gad508ef1ca04986784eebd8f58e7fe5d7">pl_File_Close</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file.  <a href="#gad508ef1ca04986784eebd8f58e7fe5d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaa61247a2d83c3ab1fbc2bb0e18c7ad12">pl_File_SetPosition</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const PlankLL position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position of the file read/write pointer.  <a href="#gaa61247a2d83c3ab1fbc2bb0e18c7ad12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaea3b7367b42566c7e801fffc78fc56f8">pl_File_OffsetPosition</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const PlankLL offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset the current position of the file read/write pointer.  <a href="#gaea3b7367b42566c7e801fffc78fc56f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga71c0032e9f87f01510ed5cc12737d5ef">pl_File_ResetPosition</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the current position of the file read/write pointer to the start of the file.  <a href="#ga71c0032e9f87f01510ed5cc12737d5ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga0605466aa8e1ed3b806e09a3489f2c7d">pl_File_SetPositionEnd</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position of the file read/write pointer to the end of the file.  <a href="#ga0605466aa8e1ed3b806e09a3489f2c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gafd6ac54a2bfee59aff3da84dc288536c">pl_File_IsValid</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file object is valid.  <a href="#gafd6ac54a2bfee59aff3da84dc288536c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga334bb77095a53b4bc5a5d30e35e83250">pl_File_IsEOF</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a file object read/write pointer has reached the end of the file.  <a href="#ga334bb77095a53b4bc5a5d30e35e83250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga38986081f4e645e125378d898ab4aa08">pl_File_SetEOF</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file object read/write pointer to the end of the file.  <a href="#ga38986081f4e645e125378d898ab4aa08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac259f0da23f6ce83409e93371deb07a7">pl_File_GetPosition</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankLL *position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current position of the file read/write pointer.  <a href="#gac259f0da23f6ce83409e93371deb07a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf7db745b9435d03b79a30479d2431312">pl_File_SetMode</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const int mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopen the file with a different mode (e.g, read/write/binary etc).  <a href="#gaf7db745b9435d03b79a30479d2431312"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga3f6b4549317ddc62ca95d43cafb4f191">pl_File_Read</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankP data, const int maximumBytes, int *bytesRead)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array of bytes from the file.  <a href="#ga3f6b4549317ddc62ca95d43cafb4f191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga0c08e9720517a352698a7f27f45287f6">pl_File_ReadC</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, char *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one signed byte from the file.  <a href="#ga0c08e9720517a352698a7f27f45287f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga06c37458676b12ff128f0bb28417d60d">pl_File_ReadS</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, short *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a short from the file (16-bit int).  <a href="#ga06c37458676b12ff128f0bb28417d60d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga0bc77191531de3373c4c4a375fc59b87">pl_File_ReadI</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an int from the file (32-bit int).  <a href="#ga0bc77191531de3373c4c4a375fc59b87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga117e4cc8e3670c1b0f98b1eaa04cf7f6">pl_File_ReadI24</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, <a class="el" href="struct_plank_i24.html">PlankI24</a> *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 24-bit int from the file (i.e.  <a href="#ga117e4cc8e3670c1b0f98b1eaa04cf7f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga4758673a34464a71ad6b923ff1328c2e">pl_File_ReadLL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankLL *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a long from the file.  <a href="#ga4758673a34464a71ad6b923ff1328c2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaffce2c63afa28bf408775a86b61d588d">pl_File_ReadUC</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned char *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one unsigned byte from the file.  <a href="#gaffce2c63afa28bf408775a86b61d588d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gad456be7c79815fa8ef29a4cae5365371">pl_File_ReadUS</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned short *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned short from the file (16-bit int).  <a href="#gad456be7c79815fa8ef29a4cae5365371"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gae3c80fd2b556c056ded0d31ff3d07db4">pl_File_ReadUI</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned int *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned int from the file (32-bit int).  <a href="#gae3c80fd2b556c056ded0d31ff3d07db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga9a6d94236a721891dbe505ae9d7a761a">pl_File_ReadUI24</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, <a class="el" href="struct_plank_u_i24.html">PlankUI24</a> *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned 24-bit int from the file (i.e.  <a href="#ga9a6d94236a721891dbe505ae9d7a761a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaed5a1d81b1d4ca59c6285375f776fbfe">pl_File_ReadUL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankUL *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a long from the file.  <a href="#gaed5a1d81b1d4ca59c6285375f776fbfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaf244d0e568c034926617726825f2e57d">pl_File_ReadULL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankULL *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an unsigned 64-bit int from the file (i.e.  <a href="#gaf244d0e568c034926617726825f2e57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaa95f3c6bf37685747b373455da60457c">pl_File_ReadF</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, float *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a float from the file (32-bit float).  <a href="#gaa95f3c6bf37685747b373455da60457c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga69ae9efd0b11c5e2118044675e99f303">pl_File_ReadD</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, double *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a double from the file (64-bit float).  <a href="#ga69ae9efd0b11c5e2118044675e99f303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga854f1f38dd0882255b21ce9131b16efc">pl_File_ReadLine</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, char *text, const int maximumLength)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array of bytes as text upto the next line ending (or the end of the file if sooner).  <a href="#ga854f1f38dd0882255b21ce9131b16efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaaa3fb85b283c5c4f3b0bdd81035f00dd">pl_File_SkipBytes</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const int numBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip over a number of bytes in the file.  <a href="#gaaa3fb85b283c5c4f3b0bdd81035f00dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga94fb1c8ba6c324f1e032ec55c74bf83b">pl_File_Write</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const void *data, const int maximumBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array of bytes to the file.  <a href="#ga94fb1c8ba6c324f1e032ec55c74bf83b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gab77b1864e3a13b3a269a9e9eff1bd8e7">pl_File_WriteC</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, char data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one signed byte to the file.  <a href="#gab77b1864e3a13b3a269a9e9eff1bd8e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga4bdabdaf7cba10def430252ff5286417">pl_File_WriteS</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, short data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a short to the file (16-bit int).  <a href="#ga4bdabdaf7cba10def430252ff5286417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga4222dbbc8486e8dd2d67f7afd9e10128">pl_File_WriteI</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, int data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an int to the file (32-bit int).  <a href="#ga4222dbbc8486e8dd2d67f7afd9e10128"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga114a1629f0996ea44925fe69e212f364">pl_File_WriteI24</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, <a class="el" href="struct_plank_i24.html">PlankI24</a> data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 24-bit int to the file (i.e., 3 bytes).  <a href="#ga114a1629f0996ea44925fe69e212f364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaa8f23f4d4f62c1f2bc16c2db28652c7a">pl_File_WriteLL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankLL data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a long to the file.  <a href="#gaa8f23f4d4f62c1f2bc16c2db28652c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga1211786a40a82960493585fec6f8cf88">pl_File_WriteUC</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned char data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one unsigned byte to the file.  <a href="#ga1211786a40a82960493585fec6f8cf88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga547d377121983dcfa573af98bd7a04ff">pl_File_WriteUS</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned short data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned short to the file (16-bit int).  <a href="#ga547d377121983dcfa573af98bd7a04ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac232eadb468ceecfdac10225f320db2f">pl_File_WriteUI</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, unsigned int data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned int to the file (32-bit int).  <a href="#gac232eadb468ceecfdac10225f320db2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga4329d8c87cded92f8a20fd289df8948a">pl_File_WriteUI24</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, <a class="el" href="struct_plank_u_i24.html">PlankUI24</a> data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned 24-bit int to the file (i.e., 3 bytes).  <a href="#ga4329d8c87cded92f8a20fd289df8948a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gad4f9aa825fb07dfcdab31cd471a10d76">pl_File_WriteUL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankUL data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unisigned long to the file.  <a href="#gad4f9aa825fb07dfcdab31cd471a10d76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gaac61e8626ecaadcd40dc31dadaa6c148">pl_File_WriteULL</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, PlankULL data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an unsigned 64-bit int to the file.  <a href="#gaac61e8626ecaadcd40dc31dadaa6c148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac616b003e797c36cec2ce89cea88d6fb">pl_File_WriteF</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, float data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a float to the file (32-bit float).  <a href="#gac616b003e797c36cec2ce89cea88d6fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gadeef54a7fd4811f363cc55ef3ba618d4">pl_File_WriteD</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, double data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a double to the file (64-bit float).  <a href="#gadeef54a7fd4811f363cc55ef3ba618d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#ga32760bb91c90d10b3a241816d5b6d418">pl_File_WriteString</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string to the file.  <a href="#ga32760bb91c90d10b3a241816d5b6d418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_file_class.html#gac5c9f5593d89fa99365d80d76da43256">pl_File_WriteLine</a> (<a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> p, const char *text)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write line of text to the file.  <a href="#gac5c9f5593d89fa99365d80d76da43256"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>A crossplatform file reading/writing utility. </p>
<p>Most of the "member functions" return a PlankResult which is a status and/or error code. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga007fd6edcef4c3e78f9822c446b65508"></a><!-- doxytag: member="plank_File.h::PLANKFILE_ALL" ref="ga007fd6edcef4c3e78f9822c446b65508" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_ALL&#160;&#160;&#160;(PLANKFILE_MASK | PLANKFILE_BIGENDIAN)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mode mask with all the mode flags. </p>

</div>
</div>
<a class="anchor" id="gac5e888429c54d187fe6c3d4ae7aabb89"></a><!-- doxytag: member="plank_File.h::PLANKFILE_APPEND" ref="gac5e888429c54d187fe6c3d4ae7aabb89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_APPEND&#160;&#160;&#160;(1 &lt;&lt; 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify 'append' mode. </p>

</div>
</div>
<a class="anchor" id="gae8cee2fd2a05cca85533363920cda208"></a><!-- doxytag: member="plank_File.h::PLANKFILE_BIGENDIAN" ref="gae8cee2fd2a05cca85533363920cda208" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_BIGENDIAN&#160;&#160;&#160;(1 &lt;&lt; 5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify big endian mode for binary files (otherwise it will be little endian). </p>

</div>
</div>
<a class="anchor" id="ga740a67928b707cef8887cbf95002fd77"></a><!-- doxytag: member="plank_File.h::PLANKFILE_BINARY" ref="ga740a67928b707cef8887cbf95002fd77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_BINARY&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify 'binary' mode. </p>

</div>
</div>
<a class="anchor" id="ga31ae3a1fb4cc0df712aa68e3bb1d5885"></a><!-- doxytag: member="plank_File.h::PLANKFILE_DYNAMICARRAYOWNED" ref="ga31ae3a1fb4cc0df712aa68e3bb1d5885" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_DYNAMICARRAYOWNED&#160;&#160;&#160;(1 &lt;&lt; 6)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify when in DynamciArray mode that the array is owned by this object. </p>

</div>
</div>
<a class="anchor" id="ga977a90e90ad400a6c6927d4ea1a4fe20"></a><!-- doxytag: member="plank_File.h::PLANKFILE_MASK" ref="ga977a90e90ad400a6c6927d4ea1a4fe20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_MASK&#160;&#160;&#160;(PLANKFILE_READ | PLANKFILE_WRITE | PLANKFILE_BINARY | PLANKFILE_APPEND | PLANKFILE_NEW)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mode mask with all the mode flags except PLANKFILE_BIGENDIAN. </p>

</div>
</div>
<a class="anchor" id="ga6780b0323fabdb2768c6195a070d4ecf"></a><!-- doxytag: member="plank_File.h::PLANKFILE_NEW" ref="ga6780b0323fabdb2768c6195a070d4ecf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_NEW&#160;&#160;&#160;(1 &lt;&lt; 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify 'new' mode. </p>

</div>
</div>
<a class="anchor" id="gaf9b6225e790088d064215175430846cf"></a><!-- doxytag: member="plank_File.h::PLANKFILE_OWNMULTI" ref="gaf9b6225e790088d064215175430846cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_OWNMULTI&#160;&#160;&#160;(1 &lt;&lt; 6)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify that a multi file object should be owned by the File object. </p>

</div>
</div>
<a class="anchor" id="ga58c5e1d5a7b1a826f055f4f4afa697a5"></a><!-- doxytag: member="plank_File.h::PLANKFILE_READ" ref="ga58c5e1d5a7b1a826f055f4f4afa697a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_READ&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify 'read' mode. </p>

</div>
</div>
<a class="anchor" id="ga97b49043ad22933861f58b6055b402c9"></a><!-- doxytag: member="plank_File.h::PLANKFILE_WRITE" ref="ga97b49043ad22933861f58b6055b402c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLANKFILE_WRITE&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag to identify 'write' mode. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga7a3834c3811eceffb81213155fd14e59"></a><!-- doxytag: member="plank_File.h::PlankFileRef" ref="ga7a3834c3811eceffb81213155fd14e59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct PlankFile* <a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An opaque reference to the <em>Plank File</em> object. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad508ef1ca04986784eebd8f58e7fe5d7"></a><!-- doxytag: member="plank_File.h::pl_File_Close" ref="gad508ef1ca04986784eebd8f58e7fe5d7" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa082f0286f7db42cb80a1d3a02ef0966"></a><!-- doxytag: member="plank_File.h::pl_File_Create" ref="gaa082f0286f7db42cb80a1d3a02ef0966" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> pl_File_Create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <em>Plank File</em> object and return an oqaque reference to it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <em>Plank File</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d641d92bc5a937e2d44127b690bf2e"></a><!-- doxytag: member="plank_File.h::pl_File_CreateAndInit" ref="gaf3d641d92bc5a937e2d44127b690bf2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a> pl_File_CreateAndInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and initialise a <em>Plank File</em> object and return an oqaque reference to it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <em>Plank File</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38f26cb71c29db7e1a4e2b45f0d769ad"></a><!-- doxytag: member="plank_File.h::pl_File_DeInit" ref="ga38f26cb71c29db7e1a4e2b45f0d769ad" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deinitialise a <em>Plank File</em> object. </p>
<p>This also closes the file if it is still open. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gab857b1acf9fae3d94d3c08bc4883a1fa"></a><!-- doxytag: member="plank_File.h::pl_File_Destroy" ref="gab857b1acf9fae3d94d3c08bc4883a1fa" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a <em>Plank File</em> object. </p>
<p>This also closes the file if it is still open. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac259f0da23f6ce83409e93371deb07a7"></a><!-- doxytag: member="plank_File.h::pl_File_GetPosition" ref="gac259f0da23f6ce83409e93371deb07a7" args="(PlankFileRef p, PlankLL *position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_GetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current position of the file read/write pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">position</td><td>A pointer to a variable that will receive the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28528f2257dadba6daf977160b706ccd"></a><!-- doxytag: member="plank_File.h::pl_File_Init" ref="ga28528f2257dadba6daf977160b706ccd" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a <em>Plank File</em> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0125ef82c4af98c33534d25fa1aad9c"></a><!-- doxytag: member="plank_File.h::pl_File_IsBigEndian" ref="gaf0125ef82c4af98c33534d25fa1aad9c" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankB pl_File_IsBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a file object is in big endian format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file object refers to a file opened in big endian format, othewise returns <code>false</code> (i.e., it is litte endian). </dd></dl>

</div>
</div>
<a class="anchor" id="ga334bb77095a53b4bc5a5d30e35e83250"></a><!-- doxytag: member="plank_File.h::pl_File_IsEOF" ref="ga334bb77095a53b4bc5a5d30e35e83250" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankB pl_File_IsEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a file object read/write pointer has reached the end of the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file read/write pointer has reached the end of the file, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6be51df6cd1114dc7cd8d6704e6aec99"></a><!-- doxytag: member="plank_File.h::pl_File_IsLittleEndian" ref="ga6be51df6cd1114dc7cd8d6704e6aec99" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankB pl_File_IsLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a file object is in little endian format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file object refers to a file opened in little endian format, othewise returns <code>false</code> (i.e., it is big endian). </dd></dl>

</div>
</div>
<a class="anchor" id="gaab3dd901ce039e26debe9e792492744b"></a><!-- doxytag: member="plank_File.h::pl_File_IsNativeEndian" ref="gaab3dd901ce039e26debe9e792492744b" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankB pl_File_IsNativeEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a file object is in the native endian format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file object refers to a file opened in endian format of the machine on which this is running, othewise returns <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd6ac54a2bfee59aff3da84dc288536c"></a><!-- doxytag: member="plank_File.h::pl_File_IsValid" ref="gafd6ac54a2bfee59aff3da84dc288536c" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankB pl_File_IsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a file object is valid. </p>
<p>This currently checks only if the file object is null. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the file object is not null. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea3b7367b42566c7e801fffc78fc56f8"></a><!-- doxytag: member="plank_File.h::pl_File_OffsetPosition" ref="gaea3b7367b42566c7e801fffc78fc56f8" args="(PlankFileRef p, const PlankLL offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OffsetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset the current position of the file read/write pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset by which to move the file read/write pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae559595e5fd9ae0c9516748b07e1102c"></a><!-- doxytag: member="plank_File.h::pl_File_Open" ref="gae559595e5fd9ae0c9516748b07e1102c" args="(PlankFileRef p, const char *filepath, const int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">mode</td><td>A bit mask code to identify the mode in which to open the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae80ca5d7e106be93f18cdc48d05fd895"></a><!-- doxytag: member="plank_File.h::pl_File_OpenBinaryNativeEndianRead" ref="gae80ca5d7e106be93f18cdc48d05fd895" args="(PlankFileRef p, const char *filepath, const PlankB andWrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenBinaryNativeEndianRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a binary file for reading and optionally writing in the native endian format. </p>
<p>This will open a file for reading/writing in little endian format on little endian machines (x86, x86_64, ARM etc) and big endian format on big endian machines (e.g., PPC). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andWrite</td><td>If <code>true</code> the file will also be opened for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf777842917cc18433b3828ecc9537d41"></a><!-- doxytag: member="plank_File.h::pl_File_OpenBinaryNativeEndianWrite" ref="gaf777842917cc18433b3828ecc9537d41" args="(PlankFileRef p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenBinaryNativeEndianWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>replaceExistingFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a binary file for writing and optionally reading in the native endian format. </p>
<p>This will open a file for reading/writing in little endian format on little endian machines (x86, x86_64, ARM etc) and big endian format on big endian machines (e.g., PPC). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andRead</td><td>If <code>true</code> the file will also be opened for reading. </td></tr>
    <tr><td class="paramname">replaceExistingFile</td><td>If <code>true</code> any exising file will be erased otherwise data will be appended to the existing file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0e2fb70c1f212c23860a3cefaeebf15"></a><!-- doxytag: member="plank_File.h::pl_File_OpenBinaryRead" ref="gac0e2fb70c1f212c23860a3cefaeebf15" args="(PlankFileRef p, const char *filepath, const PlankB andWrite, const PlankB isBigEndian)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenBinaryRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>isBigEndian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a binary file for reading and optionally writing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andWrite</td><td>If <code>true</code> the file will also be opened for writing. </td></tr>
    <tr><td class="paramname">isBigEndian</td><td>Set to <code>true</code> to write multibyte values in big endian format, otherwise write in little endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga660dbb16fe9917836248430fb355576c"></a><!-- doxytag: member="plank_File.h::pl_File_OpenBinaryWrite" ref="ga660dbb16fe9917836248430fb355576c" args="(PlankFileRef p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile, const PlankB isBigEndian)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenBinaryWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>replaceExistingFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>isBigEndian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a binary file for writing and optionally reading. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andRead</td><td>If <code>true</code> the file will also be opened for reading. </td></tr>
    <tr><td class="paramname">replaceExistingFile</td><td>If <code>true</code> any exising file will be erased otherwise data will be appended to the existing file. </td></tr>
    <tr><td class="paramname">isBigEndian</td><td>Set to <code>true</code> to write multibyte values in big endian format, otherwise write in little endian format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c4ce239aeac329367be8ca3930e7a51"></a><!-- doxytag: member="plank_File.h::pl_File_OpenTextRead" ref="ga7c4ce239aeac329367be8ca3930e7a51" args="(PlankFileRef p, const char *filepath, const PlankB andWrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenTextRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a text file for reading and optionally writing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andWrite</td><td>If <code>true</code> the file will also be opened for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c3df13be9beaa2a4a75bf56ee09dc34"></a><!-- doxytag: member="plank_File.h::pl_File_OpenTextWrite" ref="ga4c3df13be9beaa2a4a75bf56ee09dc34" args="(PlankFileRef p, const char *filepath, const PlankB andRead, const PlankB replaceExistingFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_OpenTextWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>andRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankB&#160;</td>
          <td class="paramname"><em>replaceExistingFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a text file for writing and optionally reading. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">filepath</td><td>The filepath of the file to open. </td></tr>
    <tr><td class="paramname">andRead</td><td>If <code>true</code> the file will also be opened for reading. </td></tr>
    <tr><td class="paramname">replaceExistingFile</td><td>If <code>true</code> any exising file will be erased otherwise data will be appended to the existing file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f6b4549317ddc62ca95d43cafb4f191"></a><!-- doxytag: member="plank_File.h::pl_File_Read" ref="ga3f6b4549317ddc62ca95d43cafb4f191" args="(PlankFileRef p, PlankP data, const int maximumBytes, int *bytesRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maximumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an array of bytes from the file. </p>
<p>NB as this reads raw bytes it takes no account of the likely endian format of any data read. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
    <tr><td class="paramname">maximumBytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">bytesRead</td><td>On return contains the number of bytes read (pass PLANK_NULL to ignore this). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c08e9720517a352698a7f27f45287f6"></a><!-- doxytag: member="plank_File.h::pl_File_ReadC" ref="ga0c08e9720517a352698a7f27f45287f6" args="(PlankFileRef p, char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read one signed byte from the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga69ae9efd0b11c5e2118044675e99f303"></a><!-- doxytag: member="plank_File.h::pl_File_ReadD" ref="ga69ae9efd0b11c5e2118044675e99f303" args="(PlankFileRef p, double *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a double from the file (64-bit float). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa95f3c6bf37685747b373455da60457c"></a><!-- doxytag: member="plank_File.h::pl_File_ReadF" ref="gaa95f3c6bf37685747b373455da60457c" args="(PlankFileRef p, float *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a float from the file (32-bit float). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bc77191531de3373c4c4a375fc59b87"></a><!-- doxytag: member="plank_File.h::pl_File_ReadI" ref="ga0bc77191531de3373c4c4a375fc59b87" args="(PlankFileRef p, int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an int from the file (32-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga117e4cc8e3670c1b0f98b1eaa04cf7f6"></a><!-- doxytag: member="plank_File.h::pl_File_ReadI24" ref="ga117e4cc8e3670c1b0f98b1eaa04cf7f6" args="(PlankFileRef p, PlankI24 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadI24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_plank_i24.html">PlankI24</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a 24-bit int from the file (i.e. </p>
<p>3 bytes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga854f1f38dd0882255b21ce9131b16efc"></a><!-- doxytag: member="plank_File.h::pl_File_ReadLine" ref="ga854f1f38dd0882255b21ce9131b16efc" args="(PlankFileRef p, char *text, const int maximumLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maximumLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an array of bytes as text upto the next line ending (or the end of the file if sooner). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">text</td><td>A pointer to the memory location that will receive the data. </td></tr>
    <tr><td class="paramname">maximumLength</td><td>The maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4758673a34464a71ad6b923ff1328c2e"></a><!-- doxytag: member="plank_File.h::pl_File_ReadLL" ref="ga4758673a34464a71ad6b923ff1328c2e" args="(PlankFileRef p, PlankLL *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a long from the file. </p>
<p>This will be a 32-bit int on 32-bit systems (i.e., 4 bytes) and a 64-bit int on 64-bit systems (i.e., 8 bytes) even on Windows where a 'long' is normally 32 bits on both architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. Read a 64-bit int from the file (i.e. 8 bytes). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06c37458676b12ff128f0bb28417d60d"></a><!-- doxytag: member="plank_File.h::pl_File_ReadS" ref="ga06c37458676b12ff128f0bb28417d60d" args="(PlankFileRef p, short *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a short from the file (16-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffce2c63afa28bf408775a86b61d588d"></a><!-- doxytag: member="plank_File.h::pl_File_ReadUC" ref="gaffce2c63afa28bf408775a86b61d588d" args="(PlankFileRef p, unsigned char *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadUC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read one unsigned byte from the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gae3c80fd2b556c056ded0d31ff3d07db4"></a><!-- doxytag: member="plank_File.h::pl_File_ReadUI" ref="gae3c80fd2b556c056ded0d31ff3d07db4" args="(PlankFileRef p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadUI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an unsigned int from the file (32-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a6d94236a721891dbe505ae9d7a761a"></a><!-- doxytag: member="plank_File.h::pl_File_ReadUI24" ref="ga9a6d94236a721891dbe505ae9d7a761a" args="(PlankFileRef p, PlankUI24 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadUI24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_plank_u_i24.html">PlankUI24</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an unsigned 24-bit int from the file (i.e. </p>
<p>3 bytes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed5a1d81b1d4ca59c6285375f776fbfe"></a><!-- doxytag: member="plank_File.h::pl_File_ReadUL" ref="gaed5a1d81b1d4ca59c6285375f776fbfe" args="(PlankFileRef p, PlankUL *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadUL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a long from the file. </p>
<p>This will be a 32-bit int on 32-bit systems (i.e., 4 bytes) and a 64-bit int on 64-bit systems (i.e., 8 bytes) even on Windows where a 'long' is normally 32 bits on both architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf244d0e568c034926617726825f2e57d"></a><!-- doxytag: member="plank_File.h::pl_File_ReadULL" ref="gaf244d0e568c034926617726825f2e57d" args="(PlankFileRef p, PlankULL *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadULL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankULL *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an unsigned 64-bit int from the file (i.e. </p>
<p>8 bytes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gad456be7c79815fa8ef29a4cae5365371"></a><!-- doxytag: member="plank_File.h::pl_File_ReadUS" ref="gad456be7c79815fa8ef29a4cae5365371" args="(PlankFileRef p, unsigned short *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ReadUS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an unsigned short from the file (16-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that will receive the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71c0032e9f87f01510ed5cc12737d5ef"></a><!-- doxytag: member="plank_File.h::pl_File_ResetPosition" ref="ga71c0032e9f87f01510ed5cc12737d5ef" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_ResetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the current position of the file read/write pointer to the start of the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38986081f4e645e125378d898ab4aa08"></a><!-- doxytag: member="plank_File.h::pl_File_SetEOF" ref="ga38986081f4e645e125378d898ab4aa08" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_SetEOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the file object read/write pointer to the end of the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7db745b9435d03b79a30479d2431312"></a><!-- doxytag: member="plank_File.h::pl_File_SetMode" ref="gaf7db745b9435d03b79a30479d2431312" args="(PlankFileRef p, const int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reopen the file with a different mode (e.g, read/write/binary etc). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">mode</td><td>A bit mask code to identify the mode in which to open the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa61247a2d83c3ab1fbc2bb0e18c7ad12"></a><!-- doxytag: member="plank_File.h::pl_File_SetPosition" ref="gaa61247a2d83c3ab1fbc2bb0e18c7ad12" args="(PlankFileRef p, const PlankLL position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_SetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PlankLL&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current position of the file read/write pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">position</td><td>The position within the file in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0605466aa8e1ed3b806e09a3489f2c7d"></a><!-- doxytag: member="plank_File.h::pl_File_SetPositionEnd" ref="ga0605466aa8e1ed3b806e09a3489f2c7d" args="(PlankFileRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_SetPositionEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current position of the file read/write pointer to the end of the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa3fb85b283c5c4f3b0bdd81035f00dd"></a><!-- doxytag: member="plank_File.h::pl_File_SkipBytes" ref="gaaa3fb85b283c5c4f3b0bdd81035f00dd" args="(PlankFileRef p, const int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_SkipBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Skip over a number of bytes in the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94fb1c8ba6c324f1e032ec55c74bf83b"></a><!-- doxytag: member="plank_File.h::pl_File_Write" ref="ga94fb1c8ba6c324f1e032ec55c74bf83b" args="(PlankFileRef p, const void *data, const int maximumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maximumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an array of bytes to the file. </p>
<p>NB as this reads raw bytes it takes no account of the likely endian format of any data read. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory location that is the source of the data. </td></tr>
    <tr><td class="paramname">maximumBytes</td><td>The number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gab77b1864e3a13b3a269a9e9eff1bd8e7"></a><!-- doxytag: member="plank_File.h::pl_File_WriteC" ref="gab77b1864e3a13b3a269a9e9eff1bd8e7" args="(PlankFileRef p, char data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write one signed byte to the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gadeef54a7fd4811f363cc55ef3ba618d4"></a><!-- doxytag: member="plank_File.h::pl_File_WriteD" ref="gadeef54a7fd4811f363cc55ef3ba618d4" args="(PlankFileRef p, double data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a double to the file (64-bit float). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac616b003e797c36cec2ce89cea88d6fb"></a><!-- doxytag: member="plank_File.h::pl_File_WriteF" ref="gac616b003e797c36cec2ce89cea88d6fb" args="(PlankFileRef p, float data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a float to the file (32-bit float). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4222dbbc8486e8dd2d67f7afd9e10128"></a><!-- doxytag: member="plank_File.h::pl_File_WriteI" ref="ga4222dbbc8486e8dd2d67f7afd9e10128" args="(PlankFileRef p, int data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an int to the file (32-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga114a1629f0996ea44925fe69e212f364"></a><!-- doxytag: member="plank_File.h::pl_File_WriteI24" ref="ga114a1629f0996ea44925fe69e212f364" args="(PlankFileRef p, PlankI24 data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteI24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_plank_i24.html">PlankI24</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a 24-bit int to the file (i.e., 3 bytes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5c9f5593d89fa99365d80d76da43256"></a><!-- doxytag: member="plank_File.h::pl_File_WriteLine" ref="gac5c9f5593d89fa99365d80d76da43256" args="(PlankFileRef p, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write line of text to the file. </p>
<p>This writes until it hits the first null character in the string and adds carriage return and line feed characters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">text</td><td>The string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8f23f4d4f62c1f2bc16c2db28652c7a"></a><!-- doxytag: member="plank_File.h::pl_File_WriteLL" ref="gaa8f23f4d4f62c1f2bc16c2db28652c7a" args="(PlankFileRef p, PlankLL data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankLL&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a long to the file. </p>
<p>This will be a 32-bit int on 32-bit systems (i.e., 4 bytes) and a 64-bit int on 64-bit systems (i.e., 8 bytes) even on Windows where a 'long' is normally 32 bits on both architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. Write a 64-bit int to the file. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bdabdaf7cba10def430252ff5286417"></a><!-- doxytag: member="plank_File.h::pl_File_WriteS" ref="ga4bdabdaf7cba10def430252ff5286417" args="(PlankFileRef p, short data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a short to the file (16-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32760bb91c90d10b3a241816d5b6d418"></a><!-- doxytag: member="plank_File.h::pl_File_WriteString" ref="ga32760bb91c90d10b3a241816d5b6d418" args="(PlankFileRef p, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write string to the file. </p>
<p>This writes until it hits the first null character in the string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">text</td><td>The string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1211786a40a82960493585fec6f8cf88"></a><!-- doxytag: member="plank_File.h::pl_File_WriteUC" ref="ga1211786a40a82960493585fec6f8cf88" args="(PlankFileRef p, unsigned char data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteUC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write one unsigned byte to the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gac232eadb468ceecfdac10225f320db2f"></a><!-- doxytag: member="plank_File.h::pl_File_WriteUI" ref="gac232eadb468ceecfdac10225f320db2f" args="(PlankFileRef p, unsigned int data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteUI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unsigned int to the file (32-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4329d8c87cded92f8a20fd289df8948a"></a><!-- doxytag: member="plank_File.h::pl_File_WriteUI24" ref="ga4329d8c87cded92f8a20fd289df8948a" args="(PlankFileRef p, PlankUI24 data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteUI24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_plank_u_i24.html">PlankUI24</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unsigned 24-bit int to the file (i.e., 3 bytes). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4f9aa825fb07dfcdab31cd471a10d76"></a><!-- doxytag: member="plank_File.h::pl_File_WriteUL" ref="gad4f9aa825fb07dfcdab31cd471a10d76" args="(PlankFileRef p, PlankUL data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteUL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unisigned long to the file. </p>
<p>This will be a 32-bit int on 32-bit systems (i.e., 4 bytes) and a 64-bit int on 64-bit systems (i.e., 8 bytes) even on Windows where a 'long' is normally 32 bits on both architectures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac61e8626ecaadcd40dc31dadaa6c148"></a><!-- doxytag: member="plank_File.h::pl_File_WriteULL" ref="gaac61e8626ecaadcd40dc31dadaa6c148" args="(PlankFileRef p, PlankULL data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteULL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankULL&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unsigned 64-bit int to the file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga547d377121983dcfa573af98bd7a04ff"></a><!-- doxytag: member="plank_File.h::pl_File_WriteUS" ref="ga547d377121983dcfa573af98bd7a04ff" args="(PlankFileRef p, unsigned short data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_File_WriteUS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_file_class.html#ga7a3834c3811eceffb81213155fd14e59">PlankFileRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an unsigned short to the file (16-bit int). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank File</em> object. </td></tr>
    <tr><td class="paramname">data</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A result code which will be PlankResult_OK if the operation was completely successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9010c7fcd068f755105a30409cfda8a7"></a><!-- doxytag: member="plank_File.h::pl_FileErase" ref="ga9010c7fcd068f755105a30409cfda8a7" args="(const char *filepath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_FileErase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a file with the given path form the filesystem. </p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Feb 8 2014 12:26:52 for pl-nk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
