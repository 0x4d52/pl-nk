<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>pl-nk: Core Plonk concepts.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk
   &#160;<span id="projectnumber">v0.6.0</span>
   </div>
   <div id="projectbrief">Plonk|Plink|Plank are a set of cross-platform C/C++ frameworks for audio software development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Core Plonk concepts.<div class="ingroups"><a class="el" href="group___plonk_modules.html">Plonk</a> &raquo; <a class="el" href="group___plonk_fundamentals.html">Fundamentals</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An outline of the core concepts used in Plonk.  
<a href="#details">More...</a></p>
<p>An outline of the core concepts used in Plonk. </p>
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<h1><a class="anchor" id="FundamentalTypes"></a>
Fundamental types</h1>
<p>Plonk generally makes use of the standard C++ types, <code>char</code>, <code>int</code>, <code>float</code>, <code>double</code> etc. To keep consistent types on all platforms these are <code>typedef</code> 'd in the plonk namespace as follows:</p><ul>
<li><code>Char</code> (generally built-in <code>char</code>) always an 8-bit signed integer.</li>
<li><code>Short</code> (generally built-in <code>short</code>) always a 16-bit signed integer.</li>
<li><code>Int</code> (generally built-in <code>int_</code> always a 32-bit signed integer.</li>
<li><code>Long</code> - a 32-bit signed integer on 32-bit architectures and 64-bits on 64-bit architectures. NB this is therefore not the same as a <code>long</code> on Windows under Visual Studio.</li>
<li><code>LongLong</code> - a 64-bit signed integer.</li>
<li><code>UnsignedChar</code> (generally built-in <code>unsigned</code> <code>char</code>) always an 8-bit unsigned integer.</li>
<li><code>UnsignedShort</code> (generally built-in <code>unsigned</code> <code>short</code>) always a 16-bit unsigned integer.</li>
<li><code>UnsignedInt</code> (generally built-in <code>unsigned</code> <code>int</code>) always a 32-bit unsigned integer.</li>
<li><code>UnsignedLong</code> - a 32-bit unsigned integer on 32-bit architectures and 64-bits on 64-bit architectures.</li>
<li><code>UnsignedLongLong</code> - a 64-bit unsigned integer.</li>
<li><code>Float</code> (generally built-in <code>float</code>) always a 32-bit floating point type.</li>
<li><code>Double</code> (generally built-in <code>double</code>) always a 64-bit floating point type.</li>
<li><code>Bool</code> - built-in <code>bool</code>.</li>
</ul>
<p>There is also an <a class="el" href="class_int24.html" title="An emulated 24-bit integer type. ">Int24</a> class to assist with manipulating 24-bit audio data.</p>
<h1><a class="anchor" id="CoreClasses"></a>
Core classes</h1>
<p>Plonk is designed to fully support a range of audio sample types in the future. Currently, only 32-bit float support is extensively tested but 64-bit support should work (and the infrastructure is in place to make integer and maybe fixed-point processing a possibility in the future). To help support this many Plonk classes are C++ template classes. For example, The <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class is a template. Essentially, this allows you to store another value or object in a rerefence counted container (<a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> has other useful features too which are outlined below). To store an <code>int</code> in a <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> you would use a Variable&lt;Int&gt;, for convenience (and to avoid many nested angle brackets that can result from templated code) commonly used types are <code>typedef</code> 'd. For example, IntVariable is equivalent to Variable&lt;Int&gt; (and this naming scheme is used throughout Plonk for similar <code>typedef</code> s</p>
<p>Plonk classes are divided into "user" classes and "internal" (i.e., implementation) classes. Most internal classes are denoted by the <code>Internal</code> suffix added to the class name (should you come across them in the documentation). Generally, Plonk classes come in pairs (e.g., <code>SomeClass</code> and <code>SomeClassInternal</code>). As a user you will generally deal with the user classes and almost never the internal classes directly (unless of course you write your own extensions using the same pattern). Almost all Plonk classes like this are built on a custom reference counting base class (which incidentally is thread safe and lock free) to help manage object lifetimes. You should never need to deal with the reference counting system, simply create user classes on the stack, store them by value in your own classes, and pass around by value (or by reference if you're careful).</p>
<p>For example, to use the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class to store and manipulate integers you could do something like:</p>
<div class="fragment"><div class="line"><a class="code" href="class_variable.html">IntVariable</a> a (1); <span class="comment">// &#39;a&#39; initialised to 1</span></div>
<div class="line"><a class="code" href="class_variable.html">IntVariable</a> b (2); <span class="comment">// &#39;b&#39; initialised to 2</span></div>
<div class="line"><a class="code" href="class_variable.html">IntVariable</a> c (b); <span class="comment">// &#39;c&#39; shares same state as &#39;b&#39;</span></div>
<div class="line"></div>
<div class="line">a = 3; <span class="comment">// &#39;a&#39; now set to 3 - &quot;a.setValue(3)&quot; is equivalent</span></div>
<div class="line">a = b; <span class="comment">// &#39;a&#39; now shares &#39;b&#39; (the original internal from &#39;a&#39; is destroyed as it&#39;s no longer referenced) </span></div>
<div class="line">b = 4; <span class="comment">// &#39;a&#39;, &#39;b&#39; and &#39;c&#39; all store 4 since they all share the same state</span></div>
</div><!-- fragment --><p>This technique should mean that you can avoid the use of explicit memory allocation in your own user code. You should rarely need to use <code>new</code>, <code>delete</code>, <code>malloc</code> or <code>free</code> (etc). One use of the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class is to store values you wish to use in an audio process that you wish to manipulate from elsewhere (e.g., from A GUI).</p>
<p>As mentioned previously, the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class has other useful features. Instances of <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> can be combined into expressions that are evaluated at a later time. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_variable.html">IntVariable</a> a (1);</div>
<div class="line"><a class="code" href="class_variable.html">IntVariable</a> b (2);</div>
<div class="line"><a class="code" href="class_variable.html">IntVariable</a> c = a + b; <span class="comment">// creates a variable that will evaluate &quot;a + b&quot; at a later time;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> t1 = a; <span class="comment">// is 1 - implies &quot;t1 = a.getValue()&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> t2 = b; <span class="comment">// is 2</span></div>
<div class="line"><span class="keywordtype">int</span> t3 = c; <span class="comment">// is 3 - evaluates &quot;a.getValue() + b.getValue()&quot;</span></div>
<div class="line"></div>
<div class="line">a = 100;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> t4 = c; <span class="comment">// is 102</span></div>
</div><!-- fragment --><p><a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> supports many unary and binary arithmetic operators in this way including <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>pow</code>, and so on. The <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> documentation page provides a full list.</p>
<h2><a class="anchor" id="Arrays"></a>
Arrays</h2>
<p>Plonk provides its own dynamic array class <a class="el" href="class_object_array.html" title="This is the base class for arrays. ">ObjectArray</a> (which is also a template class and employs the same reference counted lifetime management as the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class). <a class="el" href="class_object_array.html" title="This is the base class for arrays. ">ObjectArray</a> is very generalised. Please note that while assignment of a Plonk array is thread safe, manipulations of the array are not. To store and manipulate numerical data there is the specialised class <a class="el" href="class_numerical_array.html" title="Stores arrays of simple numerical values. ">NumericalArray</a> (which inherits from <a class="el" href="class_object_array.html" title="This is the base class for arrays. ">ObjectArray</a>).</p>
<p>As with the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class there are <code>typedef</code> s for many of the common types. One convention in Plonk is to use the plural form to imply an array e.g., Ints is a <a class="el" href="class_numerical_array.html">NumericalArray&lt;Int&gt;</a>. It is appreciated that this style may not suit all users and there are alternative forms using the word 'Array', thus IntArray is equivalent to Ints (both are <a class="el" href="class_numerical_array.html">NumericalArray&lt;Int&gt;</a>). There is nothing to prevent you from using an <a class="el" href="class_object_array.html">ObjectArray&lt;Int&gt;</a> but the <a class="el" href="class_numerical_array.html" title="Stores arrays of simple numerical values. ">NumericalArray</a> has added arithmetic functionality.</p>
<div class="fragment"><div class="line"><a class="code" href="class_numerical_array.html">Ints</a> a;              <span class="comment">// empty array</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> b (1);          <span class="comment">// an array containing a single element &#39;1&#39;</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> c (1, 2, 3, 4); <span class="comment">// initialise with array {1, 2, 3, 4}, up to 32 items can be used to initialise this way</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> cn = c.length(); <span class="comment">// is 4, the number of items stored in &#39;c&#39;</span></div>
<div class="line"><span class="keywordtype">int</span> cs = c.size();   <span class="comment">// is also 4, &#39;size&#39; and &#39;length&#39; are only different for null terminated arrays (see Text below)</span></div>
<div class="line"></div>
<div class="line">b.add (10);          <span class="comment">// &#39;b&#39; is now {1, 10}</span></div>
<div class="line">b.add (100);         <span class="comment">// &#39;b&#39; is now {1, 10, 100}</span></div>
<div class="line"></div>
<div class="line">c[1] = 20;           <span class="comment">// &#39;c&#39; is now {1, 20, 3, 4}</span></div>
<div class="line">b[2] = c[1];         <span class="comment">// &#39;b&#39; is now {1, 10, 20}</span></div>
<div class="line">a = b;               <span class="comment">// &#39;a&#39; now shares &#39;b&#39;</span></div>
<div class="line"></div>
<div class="line">a.<a class="code" href="class_object_array.html#a6b2d22402553fb5e22ed7c2966d74de7">remove</a> (0);        <span class="comment">// remove at index 0, &#39;a&#39; and &#39;b&#39; are now both {10, 20}</span></div>
<div class="line">c.removeItem (20);   <span class="comment">// removes item &#39;20&#39;, &#39;c&#39; is now { 1, 3, 4}</span></div>
<div class="line">c.removeItem (100);  <span class="comment">// has no effect as &#39;c&#39; doesn&#39;t contain &#39;100&#39;</span></div>
<div class="line">cn = c.length();     <span class="comment">// is now 3</span></div>
</div><!-- fragment --><p>By default Plonk checks inidices to ensure they are not out of bounds. If you wish to avoid these checks and are sure that array indices are within the bounds you can call faster versions:</p>
<div class="fragment"><div class="line"><a class="code" href="class_numerical_array.html">Ints</a> a (1, 2, 3);</div>
<div class="line"><span class="keywordtype">int</span> b = a[0]; <span class="comment">// is 1</span></div>
<div class="line"><span class="keywordtype">int</span> c = a[1]; <span class="comment">// is 2</span></div>
<div class="line"><span class="keywordtype">int</span> d = a[2]; <span class="comment">// is 3</span></div>
<div class="line"><span class="keywordtype">int</span> e = a[3]; <span class="comment">// index out-of-bounds, returns zero (or a &#39;null&#39; object if this is not a NumericalArray)</span></div>
<div class="line"><span class="keywordtype">int</span> f = a.<a class="code" href="class_object_array.html#a3027a6cfd4eef94f604a7d446c244cfc">atUnchecked</a> (0); <span class="comment">// is 1</span></div>
<div class="line"><span class="keywordtype">int</span> g = a.<a class="code" href="class_object_array.html#a3027a6cfd4eef94f604a7d446c244cfc">atUnchecked</a> (1); <span class="comment">// is 2</span></div>
<div class="line"><span class="keywordtype">int</span> h = a.<a class="code" href="class_object_array.html#a3027a6cfd4eef94f604a7d446c244cfc">atUnchecked</a> (2); <span class="comment">// is 3</span></div>
<div class="line"><span class="keywordtype">int</span> i = a.<a class="code" href="class_object_array.html#a3027a6cfd4eef94f604a7d446c244cfc">atUnchecked</a> (3); <span class="comment">// returns garbage or may crash, raises an assertion though in a Debug build</span></div>
</div><!-- fragment --><p>As dicsussed above, arithmetic can be performed on <a class="el" href="class_numerical_array.html" title="Stores arrays of simple numerical values. ">NumericalArray</a> types. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_numerical_array.html">Ints</a> a (1, 2, 3);          </div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> b (4, 5, 6);</div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> c (a + b);            <span class="comment">// &#39;c&#39; is {5, 7, 9}</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> d (1, 10, 100, 1000); </div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> e (c * d);            <span class="comment">// &#39;e&#39; is {5, 70, 900, 5000} i.e., the shorter array &#39;loops&#39; to complete the pattern</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Ints</a> f (e);                <span class="comment">// &#39;f&#39; shares &#39;e&#39;</span></div>
<div class="line">e *= 10;                   <span class="comment">// &#39;e&#39; is now {50, 700, 9000, 50000} but &#39;f&#39; is still {5, 70, 900, 5000}</span></div>
</div><!-- fragment --><p>These arithmetic operations are evaluated on assignment unlike the <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> class (although you could wrap a <a class="el" href="class_numerical_array.html" title="Stores arrays of simple numerical values. ">NumericalArray</a> in a <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> if you wish, to leverage the deferred evaluation capabiltiies of <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a>).</p>
<p>Numerical arrays can be filled with commonly required data e.g., sine wave tables, random values. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_numerical_array.html">Floats</a> a (<a class="code" href="class_numerical_array.html#a35333c3e01ef69f3a2915165c2d3ab83">Floats::newClear</a> (10));        <span class="comment">// array with 10 items all zero</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Floats</a> b (<a class="code" href="class_numerical_array.html#aa474beef987896c1d5122828b433a958">Floats::sineTable</a> (8));        <span class="comment">// sine wave shape using 8 items (bipolar -1...+1) starting at 0</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Floats</a> c (<a class="code" href="class_numerical_array.html#abd89c7757fc3ea124480f8f47de2bbfc">Floats::cosineTable</a> (8));      <span class="comment">// cosine wave shape using 8 items (bipolar -1...+1) starting at 1</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Floats</a> d (<a class="code" href="class_numerical_array.html#ae89ecb5b770c242fd6ed6393a8401bf5">Floats::cosineWindow</a> (8));     <span class="comment">// cosine wave shape using 8 items (unipolar 0...+1) starting at 0</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Floats</a> e (<a class="code" href="class_numerical_array.html#ab98a6073517a23189d9f8ca7c64b1cef">Floats::rand</a> (4, 10, 100));    <span class="comment">// array of 4 random values 10...100 uniformly distributed</span></div>
<div class="line"><a class="code" href="class_numerical_array.html">Floats</a> f (<a class="code" href="class_numerical_array.html#a91f325eeff8bd44e9774cf92b1bb438e">Floats::exprand</a> (4, 10, 100)); <span class="comment">// array of 4 random values 10...100 exponentially distributed</span></div>
</div><!-- fragment --><p><a class="el" href="class_text.html" title="A class for storing and manipulating text strings. ">Text</a> is a specially adapted Chars (CharArray or <a class="el" href="class_numerical_array.html">NumericalArray&lt;Char&gt;</a>) for dealing with text strings.</p>
<div class="fragment"><div class="line"><a class="code" href="class_text.html">Text</a> a (<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line"><a class="code" href="class_text.html">Text</a> b (<span class="stringliteral">&quot;World!&quot;</span>);</div>
<div class="line"><a class="code" href="class_text.html">Text</a> c (a + <span class="stringliteral">&quot; &quot;</span> + b); <span class="comment">// is &quot;Hello World!&quot; as &#39;+&#39; is overidden to do concatenation</span></div>
<div class="line"><span class="keywordtype">int</span> an = a.<a class="code" href="class_object_array.html#a861101ff2f817b137a481fa4a62b41a3">length</a>();  <span class="comment">// is 5</span></div>
<div class="line"><span class="keywordtype">int</span> bn = b.length();  <span class="comment">// is 6</span></div>
<div class="line"><span class="keywordtype">int</span> cn = c.length();  <span class="comment">// is 12</span></div>
<div class="line"><span class="keywordtype">int</span> as = a.<a class="code" href="class_object_array.html#a6fb5345981765f2704f9a4e8dbc8f6c8">size</a>();    <span class="comment">// is 6  (size is one larger to hold the null terminating character</span></div>
<div class="line"><span class="keywordtype">int</span> bs = b.size();    <span class="comment">// is 7</span></div>
<div class="line"><span class="keywordtype">int</span> cs = c.size();    <span class="comment">// is 13</span></div>
</div><!-- fragment --><p>If you need to access the raw C++ array stored in the Plonk array you can use getArray() or cast the Plonk array to a pointer to the array's value type:</p>
<div class="fragment"><div class="line"><a class="code" href="class_numerical_array.html">Ints</a> a (1, 2, 3);</div>
<div class="line"></div>
<div class="line"><span class="comment">// all of these are equivalent</span></div>
<div class="line"><span class="keywordtype">int</span>* ptr1 = a.<a class="code" href="class_object_array.html#aaa751e7a03cb2b3f8f067611ed1f1a41">getArray</a>();           <span class="comment">// explicit getArray()</span></div>
<div class="line"><span class="keywordtype">int</span>* ptr2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span> (a);  <span class="comment">// explicit cast, calls getArray() internally </span></div>
<div class="line"><span class="keywordtype">int</span>* ptr3 (a);                      <span class="comment">// implicit cast, calls getArray() internally</span></div>
<div class="line"><span class="keywordtype">int</span>* ptr4 = a;                      <span class="comment">// implicit cast, calls getArray() internally</span></div>
<div class="line"><span class="keywordtype">int</span>* ptr5 = (<span class="keywordtype">int</span>*)a;                <span class="comment">// should work, but C casts are not recommended in C++</span></div>
</div><!-- fragment --><p>It is best not to store any of the pointers obtained this way as the array could be reallocated if it is modified (e.g., by adding items). If you are iterating through an array this may be faster than repeated calls to atUnchecked() or the [] operator.</p>
<h2><a class="anchor" id="ChannelsUnitsAndGraphs"></a>
Channels, units and graphs</h2>
<p>Channels, units and graphs are concepts used to represent audio processing configurations in Plonk.</p><ul>
<li>channel: a single channel of audio (i.e, mono)</li>
<li>unit: an array of channels</li>
<li>graph: an interconnected collection of units</li>
</ul>
<p>In fact in Plonk there is no separate "graph" object, rather graphs are built by passing units to other units during construction. There are channel objects (the ChannelBase&lt;SampleType&gt; class) although you rarely deal with these directly in user code. Most user code will create and manipulate unit objects (via the UnitBase&lt;SampleType&gt; class). By default Plonk is setup to deal with 32-bit floating point data throughout its graphs. This is achieved by the macro PLONK_TYPE_DEFAULT which is set to 'float'. This macro is used to set the default type for the <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects. ">UnitBase</a> class and the unit factory classes. A NumericalArray&lt;PLONK_TYPE_DEFAULT&gt; is <code>typedef</code> 'd to Buffer (thus a Buffer is by default the same as a Floats or FloatArray object). Another convention is for the base types (<a class="el" href="class_channel_base.html" title="A single output signal. ">ChannelBase</a>, <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects. ">UnitBase</a>) to become simply 'Channel' and 'Unit' for the default sample type. For factory classes, these are generally names like SomethingUnit, which becomes simply 'Something' for the default sample type.</p>
<p>For example, the <a class="el" href="class_sine_unit.html" title="Sine oscillator. ">SineUnit</a> factory class is used to create wavetable-based sine wave oscillators. To create one using the default sample type you would do this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, 0.1);</div>
</div><!-- fragment --><p>This creates a single channel 1kHz sine oscillator unit at an amplitude of 0.1 and stores it in the variable 'u' (of type Unit). The 'ar' factory function name is common throughout the factory classes and denotes 'audio rate' in a similar way to other Music-N languages (Csound, SuperCollider etc). This means it will output one sample for each sample required by the audio hardware. It is possible to create 'control rate' units too although this will be discussed later (in fact there isn't really a global notion of 'control rate' as there is in other Music-N langauges as Plonk channels can run at arbitrary sample rates and block sizes).</p>
<p>To create a non-bandlimited sawtooth with amplitude 0.1 and frequency 1kHz you would use:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (1000, 0.1);</div>
</div><!-- fragment --><p>The arguments, or 'inputs', for the factory functions are documented in the factory class documentation. For example, <a class="el" href="class_sine_unit.html" title="Sine oscillator. ">SineUnit</a> documentation states:</p>
<table class="doxtable">
<tr>
<td><dl class="section user"><dt>Factory functions:</dt><dd><ul>
<li>ar (frequency=440, mul=1, add=0, preferredBlockSize=default, preferredSampleRate=default)</li>
<li>kr (frequency=440, mul=1, add=0)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Inputs:</dt><dd><ul>
<li>frequency: (unit, multi) the frequency of the oscillator in Hz</li>
<li>mul: (unit, multi) the multiplier applied to the output</li>
<li>add: (unit, multi) the offset added to the output</li>
<li>preferredBlockSize: the preferred output block size (for advanced usage, leave on default if unsure)</li>
<li>preferredSampleRate: the preferred output sample rate (for advanced usage, leave on default if unsure) </li>
</ul>
</dd></dl>
</td></tr>
</table>
<p>The 'mul' and 'add' inputs are common to many factory classes these are applied after the output of the unit at full ampltitude. The default for float and double sample types is ±1. Thus Sine::ar(1000) would output a full scale sine wave at 1kHz. The 'add' input can be used to mix a unit with the output of another unit. Depending on which optimisations are turned on this may be the most efficient way of mixing signals (if not the most convenient). The 'add' input is also useful for creating modulators. E.g.,</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (5, 100, 1000), 0.1);</div>
</div><!-- fragment --><p>Here the 5Hz sine is used to modulate another sine. This could be rewritten a follows:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> m = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (5, 100, 1000);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (m, 0.1);</div>
</div><!-- fragment --><p>(Both of these versions produce identical graphs, the processing required to render either graph will be exactly the same. The latter version <em>may</em> be a fraction slower to construct but most compilers should be able to optimise.)</p>
<p>The 'mul' input for 'm' is 100, this is effectively the modulation depth. The 'add' input is 1000, this is effectively the centre value for the modulation. Thus the modulator will have a centre value of 1000 and deviate by ±100 (i.e., 900...1100). The unit 'm' is then used as the frequency input for the unit 'u'. Any input marked as 'unit' can be any other unit. Units can be created explicitly using the factory classes, or in some cases implicitly from constants, <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> types, <a class="el" href="class_numerical_array.html" title="Stores arrays of simple numerical values. ">NumericalArray</a> types and so on. Inputs marked as 'multi' can be used to create multichannel units by passing in a multichannel unit to this input. For example, the following code creates a two-channel unit, both with amplitude 0.1 but one with frequency 995Hz and the other 1005Hz:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005), 0.1);</div>
</div><!-- fragment --><p>Or alternatively:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_unit_base.html">Unit</a> (995, 1005), 0.1);</div>
</div><!-- fragment --><p>This is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_unit_base.html">Unit</a> (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (995, 0.1), <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1005, 0.1));</div>
</div><!-- fragment --><p>Similarly, multichannel units can be passed into all inputs labelled 'multi'. The following code creates two sines with frequencies as above but with different amplitudes too:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005), <a class="code" href="class_numerical_array.html">Floats</a> (0.09, 0.11));</div>
</div><!-- fragment --><p>This is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_unit_base.html">Unit</a> (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (995, 0.09), <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1005, 0.11));</div>
</div><!-- fragment --><h2><a class="anchor" id="RunningProcessesAndAudioHosts"></a>
Running processes and 'audio hosts'</h2>
<p>Plonk is not tied to any particular platform or audio IO system. Plonk does provide some built-in "audio hosts" which interface with commonly available IO APIs. For example, there are audio hosts for PortAudio (PortAudioAudioHost), iOS (IOSAudioHost) and Juce (JuceAudioHost). It's reasonably trivial to add hosts, each derives from the <a class="el" href="class_audio_host_base.html" title="An abstract class to interface with audio devices. ">AudioHostBase</a> class.</p>
<p>In each case the audio host class communicates with the host API. As a user you simply need to inherit from the desired audio host, implement the constructGraph() function (see below) and call startHost().</p>
<p>The constructGraph() function needs to return the graph (i.e., a unit) that contains the audio processing algorithm you want to play. For example, here is a PortAudio-based example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AudioHost : <span class="keyword">public</span> PortAudioAudioHost</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   AudioHost()</div>
<div class="line">   {</div>
<div class="line">       <span class="comment">// ..DO NOT call startHost() here.. </span></div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   ~AudioHost();</div>
<div class="line">   {</div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   <a class="code" href="class_unit_base.html">Unit</a> constructGraph()</div>
<div class="line">   {</div>
<div class="line">       <a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, 0.1);</div>
<div class="line">       <span class="keywordflow">return</span> u;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Then you need to create an instance of this class and call its startHost() function. For a naive implementation could be:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">   AudioHost host;</div>
<div class="line">   host.startHost();</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">while</span>(<span class="keyword">true</span>) <span class="comment">// pause forever..</span></div>
<div class="line">       <a class="code" href="class_threading.html#af06e4d7a02ac3054e17b01ae78e39684">Threading::sleep</a> (0.001);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In reality, you would probably use your AudioHost class within the context of an event driven system (e.g., on Mac OS X and iOS you could store your AudioHost in your AppDelegate class as per the macplnk and iosplnk examples).</p>
<p>In each of the examples below you would be able to return the 'u' variable from a constructGraph() function as above.</p>
<h2><a class="anchor" id="ImplicitArithmeticUnits"></a>
Implicit arithmetic units</h2>
<p>Arithmetic can be performed on units in an intuitive fashion. For example, the following lines are all equivalent to each other:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005), 0.1);         <span class="comment">// use the mul input</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005)) * 0.1;        <span class="comment">// explicit multiply</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005)) * <a class="code" href="class_unit_base.html">Unit</a> (0.1); <span class="comment">// explicit multiply and explicit unit creation</span></div>
</div><!-- fragment --><p>Similarly, the following lines are also equivalent to each other:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005), <a class="code" href="class_numerical_array.html">Floats</a> (0.09, 0.11));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005)) * <a class="code" href="class_numerical_array.html">Floats</a> (0.09, 0.11);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (995, 1005)) * <a class="code" href="class_unit_base.html">Unit</a> (0.1, 0.11);</div>
</div><!-- fragment --><p>Mixing can be performed using the addition operator:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (200, 0.1) +</div>
<div class="line">         <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (400, 0.1 / 2) +</div>
<div class="line">         <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (600, 0.1 / 3) +</div>
<div class="line">         <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (800, 0.1 / 4);</div>
</div><!-- fragment --><p>(This creates the first four harmonics of a sawtooth wave.)</p>
<p>Ring modulation can be achieved using the '*' operator too:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1200) * <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000) * 0.1; <span class="comment">// 2200 and 200 Hz will be heard at 0.1 amplitude (1200+1000 &amp; 1200-1000)</span></div>
</div><!-- fragment --><p>As can amplitude modulation:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000) * <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5, 0.1, 0.1);</div>
</div><!-- fragment --><p>Here the amplitude modulation is at a rate of 0.5Hz and the 'mul' and 'add' of 0.1 scales and shifts the sine wave to fit betweem 0...0.2. Alternatives to this are:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5, 0.1, 0.1));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5).linlin (-1, 1, 0.0, 0.2));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5).linlin (0.0, 0.2));</div>
</div><!-- fragment --><p>Here the latter two versions use the 'linlin' function which maps one linear range onto another. With all four arguments, the first two are the input range of the source unit (-1, 1) and the second two are the desired output range (0.0, 0.2). As most units' use a default output range (i.e., ±1 for float and double sample types) only the output range needs specifying (i.e., the last of the three forms).</p>
<p>Plonk units also support unary operators such as standard trig functions (sin, cos, etc) and some useful coverters (for dBs, MIDI note numbers, etc). For example, an inefficient way to synthesise a sine wave would be:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> pi = FloatMath::getPi();  <span class="comment">// Math&lt;Type&gt; contains some useful constants</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> p = <a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (1000, pi);          <span class="comment">// phasor ±pi (i.e., ±180° in radians)</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="group___plonk_unary_op_functions.html#gab399ee6d2f8ccbcc2c9fad1932981cad">sin</a> (p) * 0.1;               <span class="comment">// call sin() on the phasor and scale</span></div>
</div><!-- fragment --><p>The <a class="el" href="group___plonk_unary_op_functions.html#gab399ee6d2f8ccbcc2c9fad1932981cad" title="Returns the sine of the input argument. ">sin()</a> function can be called like this or in "message passing" format when called on Plonk units or arrays but <b>not</b> built-in types. This can often make reading a chain of arithmetic functions easier):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> pi = FloatMath::getPi();  <span class="comment">// Math&lt;Type&gt; contains some useful constants</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> p = <a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (1000, pi);          <span class="comment">// phasor ±pi (i.e., ±180° in radians)</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = p.<a class="code" href="class_unit_base.html#ad504c6d0f8c95720ebeff4ac5dbbb288">sin</a>() * 0.1;               <span class="comment">// call sin() on the phasor and scale</span></div>
</div><!-- fragment --><p>Coversions from MIDI note to frequency in Hertz is often useful:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="group___plonk_unary_op_functions.html#ga9710edd72880e512366d222437e94553">m2f</a> (69), 0.1); <span class="comment">// MIDI note 69 = 440Hz</span></div>
</div><!-- fragment --><p>This also works on units, of course, where message passing format can be used:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> f = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5).<a class="code" href="class_unit_base.html#a5ab7510fa83f52623906cc83bf63c78b">linlin</a> (60, 72).<a class="code" href="class_unit_base.html#a5f855c83fae6c395b2aff51e3e17927b">m2f</a>(); <span class="comment">// sweep between notes 60 and 72 i.e., middle-C to the next octave</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (f, 0.1);</div>
</div><!-- fragment --><p>For a similar sweep with discrete steps round() can be used to quantise the MIDI not numbers to integers before conversion to Hz:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> f = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5).<a class="code" href="class_unit_base.html#a5ab7510fa83f52623906cc83bf63c78b">linlin</a> (60, 72).<a class="code" href="class_unit_base.html#acb25c31e47b9e179fdaadb8254dbf50c">round</a> (1).<a class="code" href="class_unit_base.html#a5f855c83fae6c395b2aff51e3e17927b">m2f</a>();</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (f, 0.1);</div>
</div><!-- fragment --><p>Similar coversions are available from frequency back to MIDI notes (f2m) and between dB and linear amplitude (dB2a and a2dB) e.g,:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1000, <a class="code" href="group___plonk_unary_op_functions.html#ga1e0e8f35253a808588f24a93b482ad9a">dB2a</a> (-18)); <span class="comment">// -18dB is amplitude 0.125</span></div>
</div><!-- fragment --><p>A simple non-bandlimited square wave can be created using the comparison operators e.g.,:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = (<a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (200) &gt; 0).linlin (0, 1, -0.1, 0.1);</div>
</div><!-- fragment --><p>The comparison operator units output either 0 or 1 (corresponding to false and true). Here, when the sawtooth wave is greater than zero the comparison results in '1' and when is is zero or below it outputs '0'. Thus a square wave is created, this is then mapped to ±0.1.</p>
<p>A pulse wave can be created by comparing against a value other than zero. This can even be modulated as in the example below, to achieve pulse width modulation:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> m = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.5, 0.25);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = (<a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (200) &gt; m).linlin (0, 1, -0.1, 0.1);</div>
</div><!-- fragment --><p>See the <a class="el" href="class_unit_base.html" title="A Unit is effectively an array of Channel objects. ">UnitBase</a> for full list of supported operators and arithmetic functions.</p>
<h2><a class="anchor" id="Mixing"></a>
Mixing</h2>
<p>Returning to techniques for mixing units, in most cases it is more straightforward and efficient to use the <a class="el" href="class_mixer_unit.html" title="Mixer. ">MixerUnit</a> rather than chains of '+' operators:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_mixer_unit.html#ac6358840aff51693d2061dcab5f72c07">Mixer::ar</a> (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 400, 600, 800), </div>
<div class="line">                              <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/2, 0.1/3, 0.1/4)));</div>
</div><!-- fragment --><p>Or perhaps more clearly:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> s = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 400, 600, 800), </div>
<div class="line">                   <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/2, 0.1/3, 0.1/4));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_mixer_unit.html#ac6358840aff51693d2061dcab5f72c07">Mixer::ar</a> (s);</div>
</div><!-- fragment --><p>Or:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 400, 600, 800), </div>
<div class="line">                   <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/2, 0.1/3, 0.1/4)).<a class="code" href="class_unit_base.html#a63fad077c90ec084384004295be2063c">mix</a>();</div>
</div><!-- fragment --><p>Thus Mixer and <a class="el" href="class_unit_base.html#a63fad077c90ec084384004295be2063c" title="Mixes this unit down to a single channel. ">Unit::mix()</a> mix down multiple channels to a single channel.</p>
<p>Mixing multiple channels is as straightforward but requires the use of arrays of units i.e. a Units or UnitArray. Take the following example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> a = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 600), <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/3));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> b = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (400, 800), <a class="code" href="class_numerical_array.html">Floats</a> (0.1/2, 0.1/4));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = a + b;</div>
</div><!-- fragment --><p>Here 200Hz and 400Hz are mixed in one channel and 600Hz and 800Hz are mixed in another channel. Using Mixer this could be:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> a = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 600), <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/3));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> b = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (400, 800), <a class="code" href="class_numerical_array.html">Floats</a> (0.1/2, 0.1/4));</div>
<div class="line">Units us = Units (a, b);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_mixer_unit.html#ac6358840aff51693d2061dcab5f72c07">Mixer::ar</a> (us);</div>
</div><!-- fragment --><p>Clearly in this case this results in <em>more</em> code but with larger numbers of units to mix this can be more convenient.</p>
<p>An equivalent would be:</p>
<div class="fragment"><div class="line">Units us;</div>
<div class="line">us.add (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (200, 600), <a class="code" href="class_numerical_array.html">Floats</a> (0.1, 0.1/3)));</div>
<div class="line">us.add (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html">Floats</a> (400, 800), <a class="code" href="class_numerical_array.html">Floats</a> (0.1/2, 0.1/4)));</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_mixer_unit.html#ac6358840aff51693d2061dcab5f72c07">Mixer::ar</a> (us);</div>
</div><!-- fragment --><p>This technique allows you to build arrays of units using conventional C++ loops:</p>
<div class="fragment"><div class="line">Units us;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)</div>
<div class="line">{</div>
<div class="line">   us.add (<a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_numerical_array.html#a91f325eeff8bd44e9774cf92b1bb438e">Floats::exprand</a> (2, 100, 1000), </div>
<div class="line">                     <a class="code" href="class_numerical_array.html#ab98a6073517a23189d9f8ca7c64b1cef">Floats::rand</a> (2, 0.05, 0.1)));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_mixer_unit.html#ac6358840aff51693d2061dcab5f72c07">Mixer::ar</a> (us);</div>
</div><!-- fragment --><h2><a class="anchor" id="OscillatorsAndGenerators"></a>
Oscillators and generators</h2>
<p>See the <a class="el" href="group___generator_units.html">oscillator </a> and <a class="el" href="group___noise_units.html">noise </a> unit documentation for a list of available unit factories. These include sine, saw, square oscillators and white noise.</p>
<h2><a class="anchor" id="AudioRateControlRate"></a>
Audio rate and control rate</h2>
<p>As mentioned previously, most Music-N style langauges have a notion of "audio rate" (where signals are calculated every hardware sample "tick"); and, "control rate" (where some signals are calulcated only every few samples). This can often lead to more efficient processing although care needs to be taken to achieve similar audio quality since it is easy to introduce discontinuities into the signal path when <b>not</b> performing the calculations on every sample. Take for example a hardware sampling rate of 44100Hz, a typical "control
rate" might be every 64 samples; this gives a control rate of 44100/64 = 689.0625Hz. All channels in Plonk have their own sample rate, thus an audio rate channel might run at 44100Hz and a control rate channel might run at a lower frequency. It wouldn't make sense to run many, many different rates but in theory it is possible in Plonk.</p>
<p>Closely linked to sample rate is the processing "block size". Rather than processing one sample from each channel in a Plonk graph before moving onto the next sample, it is common to process a block of samples using the same process then apply another process to that (and so on). This makes all sorts of optimisations possible (either manually or by clever compiler tricks that we never see). In Plonk all channels can run at differnt block sizes.</p>
<p>The default sample rate in Plonk is intially 44100Hz, although this is changed very soon after starting an audio host if the hardware sample rate is different. Similarly, the default block size is 512 samples, although this may also be changed by an audio host to match the hardware block size. Also by default the "control rate" is governed by the default block size so in fact the default control rate is 44100/512 or around 86Hz.</p>
<p>These defaults are stored in two specially adapted <a class="el" href="class_variable.html" title="A template class for storing any variable type. ">Variable</a> classes: <a class="el" href="class_sample_rate.html" title="A specialised Variable<double> for handling sample rates. ">SampleRate</a> (which is as special kind of <a class="el" href="class_variable.html">Variable&lt;double&gt;</a>); and, <a class="el" href="class_block_size.html" title="A specialised Variable<int> for handling block sizes. ">BlockSize</a> (which is a special kind of <a class="el" href="class_variable.html">Variable&lt;int&gt;</a>).</p>
<p>If you need to, these values can be obtained:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sr = SampleRate::getDefault().<a class="code" href="class_variable.html#a039e7aa6f46e5115f8a835612a7607f5">getValue</a>();</div>
<div class="line"><span class="keywordtype">int</span> bs = <a class="code" href="class_block_size.html#ac022f97ed4f42a64936fdc0f3479c1cb">BlockSize::getDefault</a>().<a class="code" href="class_variable.html#a039e7aa6f46e5115f8a835612a7607f5">getValue</a>();</div>
</div><!-- fragment --><p>Here is an example where control rate can be appropriately used (based on an example above where all units/channels were audio rate): </p><div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> f = <a class="code" href="class_sine_unit.html#a83bb481d279a888b7caec0df17b7ce8e">Sine::kr</a> (0.5).<a class="code" href="class_unit_base.html#a5ab7510fa83f52623906cc83bf63c78b">linlin</a> (60, 72).<a class="code" href="class_unit_base.html#a5f855c83fae6c395b2aff51e3e17927b">m2f</a>(); <span class="comment">// use a control rate &#39;kr&#39; modulator</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (f.<a class="code" href="class_unit_base.html#a1dd0d41795ab69cfa25400704756e7b0">ar</a>(), 0.1);               <span class="comment">// resample modulator to audio rate</span></div>
</div><!-- fragment --><p>Here the 'linlin' code and the 'm2f' code (which in fact contains some expensive mathematical functions) are only called once every control rate 'tick'. In fact, the default here is once every block. This is then resampled before being used as the modulator in the second Sine in order to remove discontinuities. A quick test of this example showed it was 40% faster to use the control rate in this way, rather than using an audio rate modulator that is calling 'm2f' every sample.</p>
<p>[todo]</p>
<h2><a class="anchor" id="Filters"></a>
Filters</h2>
<p>The underlying code for the filter units can look daunting but the classes designed to be used in user code are straightforward. These are as follows:</p>
<ul>
<li><a class="el" href="class_l_p_f_unit.html" title="Butterworth 2nd-order low-pass filter. ">LPFUnit</a>: a Butterworth 2nd-order low-pass filter</li>
<li><a class="el" href="class_l_p_f_p1_unit.html" title="One-pole low-pass filter. ">LPFP1Unit</a>: a one-pole low-pass filter</li>
<li><a class="el" href="class_r_l_p_f_unit.html" title="Resonant low-pass filter. ">RLPFUnit</a>: a resonant low-pass filter</li>
<li><a class="el" href="class_h_p_f_unit.html" title="Butterworth 2nd-order high-pass filter. ">HPFUnit</a>: a Butterworth 2nd-order high-pass filter</li>
<li><a class="el" href="class_h_p_f_p1_unit.html" title="One-pole high-pass filter. ">HPFP1Unit</a>: a one-pole high-pass filter</li>
<li><a class="el" href="class_r_h_p_f_unit.html" title="Resonant high-pass filter. ">RHPFUnit</a>: a resonant high-pass filter</li>
<li><a class="el" href="class_b_p_f_unit.html" title="Bandpass filter. ">BPFUnit</a>: a band-pass filter</li>
<li><a class="el" href="class_b_r_f_unit.html" title="Bandreject (band-elimination) filter. ">BRFUnit</a>: a band-reject (band-elimination) filter</li>
<li><a class="el" href="class_notch_unit.html" title="Notch filter (i.e, parametric mid-EQ). ">NotchUnit</a>: a notching filter (i.e., a parametric EQ, or peaking filter)</li>
<li><a class="el" href="class_low_shelf_unit.html" title="Low-shelving (bass) filter. ">LowShelfUnit</a>: a low-shelving filter</li>
<li><a class="el" href="class_high_shelf_unit.html" title="High-shelving (treble) filter. ">HighShelfUnit</a>: a high-shelving filter</li>
<li><a class="el" href="class_lag_unit.html" title="Exponential lag filter. ">LagUnit</a>: an exponential lag filter for parameter smoothing</li>
<li><a class="el" href="class_decay_unit.html" title="Exponential decay filter. ">DecayUnit</a>: an exponential decay filter</li>
</ul>
<p>You need to view each filter's documentation for the inputs each accepts but in general the first input is the signal to filter. For example, to apply a low-pass filter to a sawtooth wave you could do the following:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> s = <a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (200, 0.1);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_l_p_f_unit.html#ab68f9c65805da1f60b4491c1e7c9443c">LPF::ar</a> (s, 400); <span class="comment">// cut-off at 400Hz</span></div>
</div><!-- fragment --><p>Of course, the cutoff frequency can be modulated, here with a resonant low-pass: </p><div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> s = <a class="code" href="class_saw_unit.html#ac227416ad5260b17557db86b03762e5d">Saw::ar</a> (200, 0.1);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> m = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (1).<a class="code" href="class_unit_base.html#a9e3d7d1a992ea71b021d90f3d94b13a3">linexp</a> (400, 1600); <span class="comment">// exponential map ±1 to 400...1600</span></div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_r_l_p_f_unit.html#a4bb648a0368c953e1f57c6247e4233a6">RLPF::ar</a> (s, m, 5);              <span class="comment">// Q-factor of 5</span></div>
</div><!-- fragment --><p>Here linexp() is the equivalent of linlin() but the output range is exponential. This means in the example above 0 maps to 800, this makes the musical interval the same for both the negative and positive phases of the input sine wave. Here -1..0 maps to 400..800 which is an octave and 0..+1 maps to 800..1600 which is also an octave. (If linlin() had been used then 0 would have mapped to the linear half way point between 400 and 1600 i.e., 1000.) However, linexp() is more CPU intensive so linlin() may be a useful compromise in some circumstances even when exponential mapping is more appropriate.</p>
<p>In addition to the audio filters, <a class="el" href="class_lag_unit.html" title="Exponential lag filter. ">LagUnit</a> is useful for smoothing out discontinuities in control signals (e.g., from a slider). For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_unit_base.html">Unit</a> f = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (0.1).<a class="code" href="class_unit_base.html#a5ab7510fa83f52623906cc83bf63c78b">linlin</a> (60, 72).<a class="code" href="class_unit_base.html#acb25c31e47b9e179fdaadb8254dbf50c">round</a> (1).<a class="code" href="class_unit_base.html#a5f855c83fae6c395b2aff51e3e17927b">m2f</a>();</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u = <a class="code" href="class_sine_unit.html#a3a5dee949336bc3a5291179568a9805e">Sine::ar</a> (<a class="code" href="class_lag_unit.html#a56644135d9bf9335a3845b04d8686e45">Lag::ar</a> (f, 0.075), 0.1);</div>
</div><!-- fragment --><p>Here the quantised control signal (from an example earlier) is rounded off slightly to give a gentle portamento effect (it takes 0.075s to glide to the desired note).</p>
<h2><a class="anchor" id="SoundFiles"></a>
Sound files</h2>
<p>Plonk inlcudes range of sound file reading routines. It currently supports WAV and AIFF (and AIFC) by default and optionally Ogg Vorbis and Opus formats (by adding the appropriate files from the /ext directory and enabling the relevant preprocessor macro).</p>
<p>Sound files may be read into a memory and played back from there or streamed from disk. In either case the <a class="el" href="class_audio_file_reader.html" title="Audio file reader. ">AudioFileReader</a> class does the work of reading and decoding the sample data.</p>
<div class="fragment"><div class="line"><a class="code" href="class_audio_file_reader.html">AudioFileReader</a> reader (<span class="stringliteral">&quot;/path/to/file.wav&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (reader.isReady())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// do something with the file </span></div>
<div class="line">}</div>
</div><!-- fragment --><p>An entire sound file can be read into a Signal object. This can then be played back using the SignalPlay unit.</p>
<div class="fragment"><div class="line"><a class="code" href="class_audio_file_reader.html">AudioFileReader</a> reader (<span class="stringliteral">&quot;/path/to/file.wav&quot;</span>);</div>
<div class="line"><a class="code" href="class_unit_base.html">Unit</a> u;</div>
<div class="line"><span class="keywordflow">if</span> (reader.isReady())</div>
<div class="line">{</div>
<div class="line">   Signal signal = reader.getSignal();</div>
<div class="line">   u = <a class="code" href="class_signal_play_unit.html#a57e8b75bed5b361f7038ab2369903aa2">SignalPlay::ar</a> (signal);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Delay"></a>
Delay</h2>
<p>[todo]</p>
<h2><a class="anchor" id="FFTProcessing"></a>
FFT processing</h2>
<p>[todo] </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 19 2015 07:22:51 for pl-nk by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
