<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>pl-nk: Plank AtomicPX class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk
   &#160;<span id="projectnumber">v0.6.0</span>
   </div>
   <div id="projectbrief">Plonk|Plink|Plank are a set of cross-platform C/C++ frameworks for audio software development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Plank AtomicPX class<div class="ingroups"><a class="el" href="group___plank_modules.html">Plank</a> &raquo; <a class="el" href="group___plank_classes.html">Plank classes</a> &raquo; <a class="el" href="group___plank_atomic_classes.html">Plank Atomic operation classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Extended atomic pointer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga71e2a3899219aaf2d3b0b881a2613776"><td class="memItemLeft" align="right" valign="top">typedef struct PlankAtomicPX *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a></td></tr>
<tr class="memdesc:ga71e2a3899219aaf2d3b0b881a2613776"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque reference to the <em>Plank AtomicPX</em> object (atomic pointer with an extended tag of data).  <a href="#ga71e2a3899219aaf2d3b0b881a2613776">More...</a><br /></td></tr>
<tr class="separator:ga71e2a3899219aaf2d3b0b881a2613776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e5a5c826870a0873b7f3df9a6c4e36d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga0e5a5c826870a0873b7f3df9a6c4e36d">pl_AtomicPX_CreateAndInit</a> ()</td></tr>
<tr class="memdesc:ga0e5a5c826870a0873b7f3df9a6c4e36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initialises a <em>Plank AtomicPX</em> object and return an oqaque reference to it.  <a href="#ga0e5a5c826870a0873b7f3df9a6c4e36d">More...</a><br /></td></tr>
<tr class="separator:ga0e5a5c826870a0873b7f3df9a6c4e36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a42522025f98175817ed47ce46117ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga5a42522025f98175817ed47ce46117ed">pl_AtomicPX_Create</a> ()</td></tr>
<tr class="memdesc:ga5a42522025f98175817ed47ce46117ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <em>Plank AtomicPX</em> object and return an oqaque reference to it.  <a href="#ga5a42522025f98175817ed47ce46117ed">More...</a><br /></td></tr>
<tr class="separator:ga5a42522025f98175817ed47ce46117ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f2b2252a2e09f2c70ee6127d207f81"><td class="memItemLeft" align="right" valign="top">static PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gaa6f2b2252a2e09f2c70ee6127d207f81">pl_AtomicPX_Init</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:gaa6f2b2252a2e09f2c70ee6127d207f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <em>Plank AtomicPX</em> object.  <a href="#gaa6f2b2252a2e09f2c70ee6127d207f81">More...</a><br /></td></tr>
<tr class="separator:gaa6f2b2252a2e09f2c70ee6127d207f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb63860f41079032acd2d7cc55a8c3d"><td class="memItemLeft" align="right" valign="top">static PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga7fb63860f41079032acd2d7cc55a8c3d">pl_AtomicPX_DeInit</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:ga7fb63860f41079032acd2d7cc55a8c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialise a <em>Plank AtomicPX</em> object.  <a href="#ga7fb63860f41079032acd2d7cc55a8c3d">More...</a><br /></td></tr>
<tr class="separator:ga7fb63860f41079032acd2d7cc55a8c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12e8b323fd1c1c53186c1fe7e888764"><td class="memItemLeft" align="right" valign="top">static PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gae12e8b323fd1c1c53186c1fe7e888764">pl_AtomicPX_Destroy</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:gae12e8b323fd1c1c53186c1fe7e888764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <em>Plank AtomicPX</em> object.  <a href="#gae12e8b323fd1c1c53186c1fe7e888764">More...</a><br /></td></tr>
<tr class="separator:gae12e8b323fd1c1c53186c1fe7e888764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38fdb0e5886f12bc6b0af2dc63ea97a3"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga38fdb0e5886f12bc6b0af2dc63ea97a3">pl_AtomicPX_Get</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:ga38fdb0e5886f12bc6b0af2dc63ea97a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current pointer.  <a href="#ga38fdb0e5886f12bc6b0af2dc63ea97a3">More...</a><br /></td></tr>
<tr class="separator:ga38fdb0e5886f12bc6b0af2dc63ea97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bb8eeae596eed8f9dffec9c9a29f06"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga78bb8eeae596eed8f9dffec9c9a29f06">pl_AtomicPX_GetUnchecked</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:ga78bb8eeae596eed8f9dffec9c9a29f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value nonatomically.  <a href="#ga78bb8eeae596eed8f9dffec9c9a29f06">More...</a><br /></td></tr>
<tr class="separator:ga78bb8eeae596eed8f9dffec9c9a29f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef1d996c5a82187ca083cf0a622f1fa"><td class="memItemLeft" align="right" valign="top">static PlankUL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga8ef1d996c5a82187ca083cf0a622f1fa">pl_AtomicPX_GetExtra</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:ga8ef1d996c5a82187ca083cf0a622f1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the extra "tag".  <a href="#ga8ef1d996c5a82187ca083cf0a622f1fa">More...</a><br /></td></tr>
<tr class="separator:ga8ef1d996c5a82187ca083cf0a622f1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f8af6f1ae892f3d63a126925ce8d9f"><td class="memItemLeft" align="right" valign="top">static PlankUL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gaa0f8af6f1ae892f3d63a126925ce8d9f">pl_AtomicPX_GetExtraUnchecked</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:gaa0f8af6f1ae892f3d63a126925ce8d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the extra "tag" nonatomically.  <a href="#gaa0f8af6f1ae892f3d63a126925ce8d9f">More...</a><br /></td></tr>
<tr class="separator:gaa0f8af6f1ae892f3d63a126925ce8d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c257d70c858f6502a431b120724d11"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga35c257d70c858f6502a431b120724d11">pl_AtomicPX_SwapAll</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankP newPtr, PlankUL newExtra, PlankUL *oldExtra)</td></tr>
<tr class="memdesc:ga35c257d70c858f6502a431b120724d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the current pointer with a new pointer and change the tag.  <a href="#ga35c257d70c858f6502a431b120724d11">More...</a><br /></td></tr>
<tr class="separator:ga35c257d70c858f6502a431b120724d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba45d76543bfd43f75a2b3e38b4d505"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga3ba45d76543bfd43f75a2b3e38b4d505">pl_AtomicPX_Swap</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankP newPtr)</td></tr>
<tr class="memdesc:ga3ba45d76543bfd43f75a2b3e38b4d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the current pointer with a new pointer.  <a href="#ga3ba45d76543bfd43f75a2b3e38b4d505">More...</a><br /></td></tr>
<tr class="separator:ga3ba45d76543bfd43f75a2b3e38b4d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404ac946ec4ef0808e946c59de8fd474"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga404ac946ec4ef0808e946c59de8fd474">pl_AtomicPX_SwapOther</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p1, <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p2)</td></tr>
<tr class="memdesc:ga404ac946ec4ef0808e946c59de8fd474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap over two values.  <a href="#ga404ac946ec4ef0808e946c59de8fd474">More...</a><br /></td></tr>
<tr class="separator:ga404ac946ec4ef0808e946c59de8fd474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08aac7c5aa9335840e6333bdc5afaec1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga08aac7c5aa9335840e6333bdc5afaec1">pl_AtomicPX_SetAll</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankP newPtr, PlankUL newExtra)</td></tr>
<tr class="memdesc:ga08aac7c5aa9335840e6333bdc5afaec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current pointer to a new pointer and change the tag.  <a href="#ga08aac7c5aa9335840e6333bdc5afaec1">More...</a><br /></td></tr>
<tr class="separator:ga08aac7c5aa9335840e6333bdc5afaec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5222fb0c24d3c106b08a027a28c09d81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga5222fb0c24d3c106b08a027a28c09d81">pl_AtomicPX_Set</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankP newPtr)</td></tr>
<tr class="memdesc:ga5222fb0c24d3c106b08a027a28c09d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current pointer to a new pointer.  <a href="#ga5222fb0c24d3c106b08a027a28c09d81">More...</a><br /></td></tr>
<tr class="separator:ga5222fb0c24d3c106b08a027a28c09d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38739ce1ac0e46d846b62f049647681"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gaa38739ce1ac0e46d846b62f049647681">pl_AtomicPX_Add</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankL operand)</td></tr>
<tr class="memdesc:gaa38739ce1ac0e46d846b62f049647681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset current pointer.  <a href="#gaa38739ce1ac0e46d846b62f049647681">More...</a><br /></td></tr>
<tr class="separator:gaa38739ce1ac0e46d846b62f049647681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ec5244496ea32891ea98ab6ca1f34b"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga99ec5244496ea32891ea98ab6ca1f34b">pl_AtomicPX_Subtract</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankL operand)</td></tr>
<tr class="memdesc:ga99ec5244496ea32891ea98ab6ca1f34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset current pointer in a negative direct.  <a href="#ga99ec5244496ea32891ea98ab6ca1f34b">More...</a><br /></td></tr>
<tr class="separator:ga99ec5244496ea32891ea98ab6ca1f34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcb2adb46addf8492d17df015e28a42"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gaafcb2adb46addf8492d17df015e28a42">pl_AtomicPX_Increment</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:gaafcb2adb46addf8492d17df015e28a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the current pointer by 1 byte.  <a href="#gaafcb2adb46addf8492d17df015e28a42">More...</a><br /></td></tr>
<tr class="separator:gaafcb2adb46addf8492d17df015e28a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc026e3552e6a705f9eceb8612c38d10"><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#gafc026e3552e6a705f9eceb8612c38d10">pl_AtomicPX_Decrement</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p)</td></tr>
<tr class="memdesc:gafc026e3552e6a705f9eceb8612c38d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the current pointer by 1 byte.  <a href="#gafc026e3552e6a705f9eceb8612c38d10">More...</a><br /></td></tr>
<tr class="separator:gafc026e3552e6a705f9eceb8612c38d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99de3470a8390069e982fb5f1cadbcf7"><td class="memItemLeft" align="right" valign="top">static PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_x_class.html#ga99de3470a8390069e982fb5f1cadbcf7">pl_AtomicPX_CompareAndSwap</a> (<a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> p, PlankP oldPtr, PlankUL oldExtra, PlankP newPtr, PlankUL newExtra)</td></tr>
<tr class="memdesc:ga99de3470a8390069e982fb5f1cadbcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the current values with new values if specified old values are still current.  <a href="#ga99de3470a8390069e982fb5f1cadbcf7">More...</a><br /></td></tr>
<tr class="separator:ga99de3470a8390069e982fb5f1cadbcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Extended atomic pointer. </p>
<p>This combines a pointer and an extra "tag" which can be written in a single atomic operation. This can help avoid the "ABA problem" in certain lock-free data structures.</p>
<p>The default is to use the extra tag as a counter such that the counter is incremented each time the stored pointer us set. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga71e2a3899219aaf2d3b0b881a2613776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct PlankAtomicPX* <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An opaque reference to the <em>Plank AtomicPX</em> object (atomic pointer with an extended tag of data). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa38739ce1ac0e46d846b62f049647681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankL&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset current pointer. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">operand</td><td>The number of bytes by which to offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga99de3470a8390069e982fb5f1cadbcf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankB pl_AtomicPX_CompareAndSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>oldPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>oldExtra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>newExtra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the current values with new values if specified old values are still current. </p>
<p>This is the most important atomic operation for each atomic class, many other operations are based on this. If the operation fails the user would generally try again by getting the old pointer again and retrying to write the new pointer (e.g., in a loop) until successful. If there are no other threads contending to write the pointer the operation should succeed without blocking.</p>
<p>This swaps both the pointer AND the extra tag but importantly both "old" values must match the currenty stored values for the swap to take place. This is the most important function for helping avoid the ABA problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">oldPtr</td><td>The expected old pointer being currently stored. </td></tr>
    <tr><td class="paramname">oldExtra</td><td>The expected old extra tag being currently stored. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new pointer to attempt to store. </td></tr>
    <tr><td class="paramname">newExtra</td><td>The new extra tag to attempt to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the swap was successful, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a42522025f98175817ed47ce46117ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> pl_AtomicPX_Create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <em>Plank AtomicPX</em> object and return an oqaque reference to it. </p>
<p>In this case both the pointer and the extra tag are set to 0. </p><dl class="section return"><dt>Returns</dt><dd>A <em>Plank AtomicPX</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e5a5c826870a0873b7f3df9a6c4e36d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a> pl_AtomicPX_CreateAndInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initialises a <em>Plank AtomicPX</em> object and return an oqaque reference to it. </p>
<dl class="section return"><dt>Returns</dt><dd>A <em>Plank AtomicPX</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc026e3552e6a705f9eceb8612c38d10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Decrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the current pointer by 1 byte. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fb63860f41079032acd2d7cc55a8c3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankResult pl_AtomicPX_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialise a <em>Plank AtomicPX</em> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gae12e8b323fd1c1c53186c1fe7e888764"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankResult pl_AtomicPX_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a <em>Plank AtomicPX</em> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38fdb0e5886f12bc6b0af2dc63ea97a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current pointer. </p>
<p>The extra tag can be obtained using <a class="el" href="group___plank_atomic_p_x_class.html#ga8ef1d996c5a82187ca083cf0a622f1fa" title="Get the current value of the extra &quot;tag&quot;. ">pl_AtomicPX_GetExtra()</a> although for many algorithms the user doesn't need to know the value of the tag as it is simply used to make each write commit unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ef1d996c5a82187ca083cf0a622f1fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankUL pl_AtomicPX_GetExtra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current value of the extra "tag". </p>
<p>Many algorithms the user doesn't need to know the value of the tag as it is simply used to make each write commit unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extra tag. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0f8af6f1ae892f3d63a126925ce8d9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankUL pl_AtomicPX_GetExtraUnchecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current value of the extra "tag" nonatomically. </p>
<p>Many algorithms the user doesn't need to know the value of the tag as it is simply used to make each write commit unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extra tag. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78bb8eeae596eed8f9dffec9c9a29f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_GetUnchecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current value nonatomically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaafcb2adb46addf8492d17df015e28a42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the current pointer by 1 byte. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6f2b2252a2e09f2c70ee6127d207f81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankResult pl_AtomicPX_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a <em>Plank AtomicPX</em> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5222fb0c24d3c106b08a027a28c09d81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_AtomicPX_Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current pointer to a new pointer. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new pointer to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08aac7c5aa9335840e6333bdc5afaec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_AtomicPX_SetAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>newExtra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current pointer to a new pointer and change the tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new value to store. </td></tr>
    <tr><td class="paramname">newExtra</td><td>The new extra tag to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99ec5244496ea32891ea98ab6ca1f34b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankL&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset current pointer in a negative direct. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">operand</td><td>The number of bytes to subtract from the pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ba45d76543bfd43f75a2b3e38b4d505"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the current pointer with a new pointer. </p>
<p>This also increments the extra tag by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new pointer to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previously stored value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35c257d70c858f6502a431b120724d11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicPX_SwapAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL&#160;</td>
          <td class="paramname"><em>newExtra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankUL *&#160;</td>
          <td class="paramname"><em>oldExtra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the current pointer with a new pointer and change the tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new value to store. </td></tr>
    <tr><td class="paramname">newExtra</td><td>The new extra tag to store. </td></tr>
    <tr><td class="paramname">oldExtra</td><td>The old tage will be place here (you can pass PLANK_NULL if you don't need this). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previously stored value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga404ac946ec4ef0808e946c59de8fd474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_AtomicPX_SwapOther </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_x_class.html#ga71e2a3899219aaf2d3b0b881a2613776">PlankAtomicPXRef</a>&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap over two values. </p>
<p>The contents of p1 is copied to p2 and p2 is copied to p1 in an atomic operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>One <em>Plank AtomicPX</em> object. </td></tr>
    <tr><td class="paramname">p2</td><td>The other <em>Plank AtomicPX</em> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 19 2015 08:52:12 for pl-nk by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
