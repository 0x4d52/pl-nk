<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pl-nk: Plank AtomicP class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pl-nk-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">pl-nk&#160;<span id="projectnumber">v0.4.5</span></div>
   <div id="projectbrief">Plonk|Plink|Plank are a set of cross-platform C/C++ frameworks for audio software development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Plank AtomicP class</div>  </div>
<div class="ingroups"><a class="el" href="group___plank_atomic_classes.html">Plank Atomic operation classes</a></div></div>
<div class="contents">

<p>Atomic pointer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct PlankAtomicP *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque reference to the <em>Plank AtomicP</em> object (atomic pointer).  <a href="#gac6ebd37367523407839a0f9a4fc5d9ea"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga91086b7040d5c5d0594cceb1d8c27550">pl_AtomicP_CreateAndInit</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initialises a <em>Plank AtomicP</em> object and return an oqaque reference to it.  <a href="#ga91086b7040d5c5d0594cceb1d8c27550"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga6d7802aad6952b25b20709f0257e8165">pl_AtomicP_Create</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <em>Plank AtomicD</em> object and return an oqaque reference to it.  <a href="#ga6d7802aad6952b25b20709f0257e8165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#gaaa6bfeaf83df3bc65925013e23b61415">pl_AtomicP_Init</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a <em>Plank AtomicP</em> object.  <a href="#gaaa6bfeaf83df3bc65925013e23b61415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga5e1f3fae6395b53d8dcee30ea05f0764">pl_AtomicP_DeInit</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialise a <em>Plank AtomicP</em> object.  <a href="#ga5e1f3fae6395b53d8dcee30ea05f0764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga48a4a79f0f042e2971afe827db1e5efd">pl_AtomicP_Destroy</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <em>Plank AtomicP</em> object.  <a href="#ga48a4a79f0f042e2971afe827db1e5efd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga68f8298157fccc5a71a0785e37465a03">pl_AtomicP_Get</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value.  <a href="#ga68f8298157fccc5a71a0785e37465a03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga2e426d5cc548af7df01d1455c0709068">pl_AtomicP_GetUnchecked</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value nonatomically.  <a href="#ga2e426d5cc548af7df01d1455c0709068"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankUL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga099f222754557748fe9db77db8428cfe">pl_AtomicP_GetExtra</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used for this class.  <a href="#ga099f222754557748fe9db77db8428cfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PlankUL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#gac1db0b657d75a4100cac3f3b8e454685">pl_AtomicP_GetExtraUnchecked</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used for this class.  <a href="#gac1db0b657d75a4100cac3f3b8e454685"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#gaf34822f085b42e6cf2c8a8bf2a33621c">pl_AtomicP_Swap</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p, PlankP newPtr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the current pointer with a new pointer.  <a href="#gaf34822f085b42e6cf2c8a8bf2a33621c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga98e1591583586b6a0230381f68a860ae">pl_AtomicP_SwapOther</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p1, <a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap over two values.  <a href="#ga98e1591583586b6a0230381f68a860ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga956fba70602f11fa64747eeab5158bec">pl_AtomicP_Set</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p, PlankP newPtr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current pointer to a new pointer.  <a href="#ga956fba70602f11fa64747eeab5158bec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga306a94df2dd34d91234ab9b73bffda4d">pl_AtomicP_Add</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p, PlankL operand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset current pointer.  <a href="#ga306a94df2dd34d91234ab9b73bffda4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga6c4c61a1de6e2f7999c6ff6912dbe4d7">pl_AtomicP_Subtract</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p, PlankL operand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset current pointer in a negative direct.  <a href="#ga6c4c61a1de6e2f7999c6ff6912dbe4d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#gaf79c17977d7445ff5fbf6ba58a34748f">pl_AtomicP_Increment</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the current pointer by 1 byte.  <a href="#gaf79c17977d7445ff5fbf6ba58a34748f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga20daf4da5c87a2d8e48405cc8c091dae">pl_AtomicP_Decrement</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the current pointer by 1 byte.  <a href="#ga20daf4da5c87a2d8e48405cc8c091dae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static PlankB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_atomic_p_class.html#ga7bbfec08311361e425765d80d8ee4287">pl_AtomicP_CompareAndSwap</a> (<a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> p, PlankP oldPtr, PlankP newPtr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the current pointer with a new pointer if a specified old pointer is still current.  <a href="#ga7bbfec08311361e425765d80d8ee4287"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Atomic pointer. </p>
<p>This will be the natural width of the pointer on the runtime platform.</p>
<p>Use <a class="el" href="group___plank_atomic_p_x_class.html">AtomicPX </a> for safer pointer storage. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac6ebd37367523407839a0f9a4fc5d9ea"></a><!-- doxytag: member="plank_Atomic.h::PlankAtomicPRef" ref="gac6ebd37367523407839a0f9a4fc5d9ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct PlankAtomicP* <a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An opaque reference to the <em>Plank AtomicP</em> object (atomic pointer). </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga306a94df2dd34d91234ab9b73bffda4d"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Add" ref="ga306a94df2dd34d91234ab9b73bffda4d" args="(PlankAtomicPRef p, PlankL operand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankL&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset current pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">operand</td><td>The number of bytes by which to offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bbfec08311361e425765d80d8ee4287"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_CompareAndSwap" ref="ga7bbfec08311361e425765d80d8ee4287" args="(PlankAtomicPRef p, PlankP oldPtr, PlankP newPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankB pl_AtomicP_CompareAndSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>oldPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the current pointer with a new pointer if a specified old pointer is still current. </p>
<p>This is the most important atomic operation for each atomic class, many other operations are based on this. If the operation fails the user would generally try again by getting the old pointer again and retrying to write the new pointer (e.g., in a loop) until successful. If there are no other threads contending to write the pointer the operation should succeed without blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">oldPtr</td><td>The expected old pointer being currently stored. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new pointer to attempt to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the swap was successful, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d7802aad6952b25b20709f0257e8165"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Create" ref="ga6d7802aad6952b25b20709f0257e8165" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> pl_AtomicP_Create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a <em>Plank AtomicD</em> object and return an oqaque reference to it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <em>Plank AtomicD</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91086b7040d5c5d0594cceb1d8c27550"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_CreateAndInit" ref="ga91086b7040d5c5d0594cceb1d8c27550" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a> pl_AtomicP_CreateAndInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and initialises a <em>Plank AtomicP</em> object and return an oqaque reference to it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <em>Plank AtomicP</em> object as an opaque reference or PLANK_NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20daf4da5c87a2d8e48405cc8c091dae"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Decrement" ref="ga20daf4da5c87a2d8e48405cc8c091dae" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Decrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement the current pointer by 1 byte. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e1f3fae6395b53d8dcee30ea05f0764"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_DeInit" ref="ga5e1f3fae6395b53d8dcee30ea05f0764" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankResult pl_AtomicP_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deinitialise a <em>Plank AtomicP</em> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48a4a79f0f042e2971afe827db1e5efd"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Destroy" ref="ga48a4a79f0f042e2971afe827db1e5efd" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankResult pl_AtomicP_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a <em>Plank AtomicP</em> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68f8298157fccc5a71a0785e37465a03"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Get" ref="ga68f8298157fccc5a71a0785e37465a03" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga099f222754557748fe9db77db8428cfe"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_GetExtra" ref="ga099f222754557748fe9db77db8428cfe" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankUL pl_AtomicP_GetExtra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Not used for this class. </p>
<p>Use <a class="el" href="group___plank_atomic_p_x_class.html">AtomicPX </a> for safer pointer storage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicI</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1db0b657d75a4100cac3f3b8e454685"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_GetExtraUnchecked" ref="gac1db0b657d75a4100cac3f3b8e454685" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PlankUL pl_AtomicP_GetExtraUnchecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Not used for this class. </p>
<p>Use <a class="el" href="group___plank_atomic_p_x_class.html">AtomicPX </a> for safer pointer storage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicI</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e426d5cc548af7df01d1455c0709068"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_GetUnchecked" ref="ga2e426d5cc548af7df01d1455c0709068" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_GetUnchecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current value nonatomically. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf79c17977d7445ff5fbf6ba58a34748f"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Increment" ref="gaf79c17977d7445ff5fbf6ba58a34748f" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment the current pointer by 1 byte. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa6bfeaf83df3bc65925013e23b61415"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Init" ref="gaaa6bfeaf83df3bc65925013e23b61415" args="(PlankAtomicPRef p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankResult pl_AtomicP_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a <em>Plank AtomicP</em> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PlankResult_OK if successful, otherwise an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga956fba70602f11fa64747eeab5158bec"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Set" ref="ga956fba70602f11fa64747eeab5158bec" args="(PlankAtomicPRef p, PlankP newPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_AtomicP_Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current pointer to a new pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new pointer to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c4c61a1de6e2f7999c6ff6912dbe4d7"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Subtract" ref="ga6c4c61a1de6e2f7999c6ff6912dbe4d7" args="(PlankAtomicPRef p, PlankL operand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankL&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offset current pointer in a negative direct. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">operand</td><td>The number of bytes to subtract from the pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf34822f085b42e6cf2c8a8bf2a33621c"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_Swap" ref="gaf34822f085b42e6cf2c8a8bf2a33621c" args="(PlankAtomicPRef p, PlankP newPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static PlankP pl_AtomicP_Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PlankP&#160;</td>
          <td class="paramname"><em>newPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the current pointer with a new pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">newPtr</td><td>The new value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previously stored pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98e1591583586b6a0230381f68a860ae"></a><!-- doxytag: member="plank_Atomic.h::pl_AtomicP_SwapOther" ref="ga98e1591583586b6a0230381f68a860ae" args="(PlankAtomicPRef p1, PlankAtomicPRef p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void pl_AtomicP_SwapOther </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___plank_atomic_p_class.html#gac6ebd37367523407839a0f9a4fc5d9ea">PlankAtomicPRef</a>&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap over two values. </p>
<p>The contents of p1 is copied to p2 and p2 is copied to p1 in an atomic operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>One <em>Plank AtomicP</em> object. </td></tr>
    <tr><td class="paramname">p2</td><td>The other <em>Plank AtomicP</em> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Feb 8 2014 12:26:51 for pl-nk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
