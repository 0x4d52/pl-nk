<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>plinkplonk: plank_Vectors.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">plinkplonk</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_32e9b716b525e55ddd6949ed964198cf.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_66de319f4396a2b7916472e434c6bf60.html">plank</a>      </li>
      <li class="navelem"><a class="el" href="dir_974ed0dc1fad48201c03d54423eb6e82.html">maths</a>      </li>
      <li class="navelem"><a class="el" href="dir_45ddda15590de563371d6928fb94d327.html">vectors</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">plank_Vectors.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;../plank_Maths.h&quot;</code><br/>
</div>
<p><a href="plank___vectors_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga2294b83bc58f427fba51d5e5f8a2913d">PLANK_VECTOR_NAMEINTERNAL</a>(OP, TYPECODE, SUFFIX)&#160;&#160;&#160;pl_Vector##OP##TYPECODE##SUFFIX</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga23ad596e9c890aac4ca1385b47e87732">PLANK_VECTORUNARYOP_NAME</a>(OP, TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(OP,TYPECODE,_NN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga5356935ad438c479cd8b39e841ed613c">PLANK_VECTORUNARYOP_DEFINE</a>(OP, TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga8918a3b271d7c04aadd73df6ece8e53e">PLANK_VECTORBINARYOPVECTOR_NAME</a>(OP, TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(OP,TYPECODE,_NNN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gafdbb918c1b92c5a8bdfa843a3af9516f">PLANK_VECTORBINARYOPSCALAR_NAME</a>(OP, TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(OP,TYPECODE,_NN1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga2cfbefc59f835e416e8621af51b43b10">PLANK_SCALARBINARYOPVECTOR_NAME</a>(OP, TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(OP,TYPECODE,_N1N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gac669d16ef6a9f370d498382f65cc4c70">PLANK_VECTORBINARYOPVECTOR_DEFINE</a>(OP, TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga1f46b802fc92825f98b13a552dbef80c">PLANK_VECTORBINARYOPSCALAR_DEFINE</a>(OP, TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga4406f528b4bb25b3246f79b5a42e76f6">PLANK_SCALARBINARYOPVECTOR_DEFINE</a>(OP, TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga32eca98475e2a6c35a6a4c3a3acb48ea">PLANK_VECTORBINARYOP_DEFINE</a>(OP, TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga924c6a1e68b27823f27e699bb8c7d7eb">PLANK_VECTORMULADD_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(MulAdd,TYPECODE,_NNN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gadbee61f5f1f02a84e7b1f9858f6372fd">PLANK_VECTORMULADD_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gabac7d14ca50018acde360c496ca4d071">PLANK_VECTORFILL_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Fill,TYPECODE,_N1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga389d5f53d0b8f650812e65f49372bf3e">PLANK_VECTORFILL_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga061a6a31c1bd40f7de9e24b69b3ccf77">PLANK_VECTORCLEAR_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Clear,TYPECODE,_N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga32b0f34701124f75f15a0f3a0f29309c">PLANK_VECTORCLEAR_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gaba7cecacebe95d31bdad7d315418d333">PLANK_VECTORRAMP_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Ramp,TYPECODE,_N11)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga3412479787609ced0f9e26e04e4a0261">PLANK_VECTORRAMP_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gaca04f7f2a4d1721372317cfb27f96c92">PLANK_VECTORLINE_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Line,TYPECODE,_N11)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gaf63600bdea8a53611685a6830bab090d">PLANK_VECTORLINE_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga81d5410ab8f2e8b4c6adb9dbc1884633">PLANK_VECTORLOOKUP_NAME</a>(TYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Lookup,TYPECODE,_NnN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga4d995aa4fa14c8223593c8f51a0b1ceb">PLANK_VECTORLOOKUP_DEFINE</a>(TYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga1f93264b731f30ecf938c74e3b5c59ab">PLANK_VECTORCONVERT_NAME</a>(DSTTYPECODE, SRCTYPECODE)&#160;&#160;&#160;PLANK_VECTOR_NAMEINTERNAL(Convert,SRCTYPECODE##2##DSTTYPECODE,_NN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga0d0c9c6b897c9b48e3ecdc765e5afa11">PLANK_VECTORCONVERT_DEFINE</a>(DSTTYPECODE, SRCTYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#gade11f0765ae8af2defa3b31e81be5b5e">PLANK_VECTORCONVERTERS_DEFINE</a>(DSTTYPECODE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_macros.html#ga1003d48aab416b139a234bcd9bba28c3">PLANK_VECTOR_OPS</a>(TYPECODE)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf264cdbe70928e87484c7ef7c7e770da">pl_VectorFillF_N1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> value, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="group___plank_vector_functions.html#gaf264cdbe70928e87484c7ef7c7e770da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56913dd2881acd870e0bf0b81761f29a">pl_VectorClearF_N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="group___plank_vector_functions.html#ga56913dd2881acd870e0bf0b81761f29a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6083cf8cd3b19b6617c85b81dac22355">pl_VectorRampF_N11</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="group___plank_vector_functions.html#ga6083cf8cd3b19b6617c85b81dac22355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5af8b83ed87be0faee019340b9cc07a3">pl_VectorLineF_N11</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="group___plank_vector_functions.html#ga5af8b83ed87be0faee019340b9cc07a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6afd6f38943e06da5514a63e90c0faf9">pl_VectorMoveF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5c72c816a6aa7e691b5f822f303e2380" title="Just returns the input argument.">pl_MoveF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga6afd6f38943e06da5514a63e90c0faf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3e8bc51e352f9e56102e8a6f8e591369">pl_VectorNegF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga9c53f7694e05268362e4ce21f311a390" title="Returns the negative of the input argument.">pl_NegF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga3e8bc51e352f9e56102e8a6f8e591369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0da76047e2f5935ce69ec1b4084959b7">pl_VectorAbsF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga32c5e9ec697355c3e2a153b3f3950393" title="Returns the absolute of the input argument.">pl_AbsF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga0da76047e2f5935ce69ec1b4084959b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167">pl_VectorLog2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gabdd452e1518a66cf0d9fed691c8b47a0" title="Returns the logarithm base 2 of the input argument.">pl_Log2F()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga6f8cf6b2f7fa17fb800ff0e1d5a2e167"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf552c917a97a8370eb14d70fa7fdbcd4">pl_VectorReciprocalF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cb6feb8a8a34d3323b405650ef1e0ad" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaf552c917a97a8370eb14d70fa7fdbcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8317e0ece295c3fe4c6ddcd0c9291b73">pl_VectorSinF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1fd0eec07e3e032eeec06f614a70754e" title="Returns the sine of the input argument.">pl_SinF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga8317e0ece295c3fe4c6ddcd0c9291b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dc9e1a1005c50962f50b218bdd359f7">pl_VectorCosF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8e0af6f1ad5d3b451566c295f3c0ad34" title="Returns the cosine of the input argument.">pl_CosF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga2dc9e1a1005c50962f50b218bdd359f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ff3f0a747f340ef59eb12ff9f5fa9ce">pl_VectorTanF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa9f0c2dd6ff1434bd8188b20142daf05" title="Returns the tangent of the input argument.">pl_TanF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga0ff3f0a747f340ef59eb12ff9f5fa9ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga40b4fd224d5c1df552bd36fd79e14d46">pl_VectorAsinF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga74148d65fe6c3a44826479200bfaa679" title="Returns the arcsine of the input argument.">pl_AsinF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga40b4fd224d5c1df552bd36fd79e14d46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b0876ed78d4675a40aec91015020543">pl_VectorAcosF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaddd7a8373b601b9c085ac9a86046f75" title="Returns the arcosine of the input argument.">pl_AcosF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga4b0876ed78d4675a40aec91015020543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c392fc9382aa520c8d73f30ce097361">pl_VectorAtanF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab9bb9726978a4930418eda07ec09afdd" title="Returns the arctangent of the input argument.">pl_AtanF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga1c392fc9382aa520c8d73f30ce097361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1d025408ed6a1435023aa7837cbbce26">pl_VectorSinhF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaf682076757a71f9839db7734c9ce4f8f" title="Returns the hyperbolic sine of the input argument.">pl_SinhF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga1d025408ed6a1435023aa7837cbbce26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae7fca130c7b57d8f99ba52546a3d401f">pl_VectorCoshF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05dbce5d0a023eb6fa68d8458c0bbca7" title="Returns the hyperbolic cosine of the input argument.">pl_CoshF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gae7fca130c7b57d8f99ba52546a3d401f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac8184fcb4e00b71d0e152a6cd441e611">pl_VectorTanhF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga913afa2be9670c3019619a5a43231370" title="Returns the hyperbolic tangent of the input argument.">pl_TanhF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gac8184fcb4e00b71d0e152a6cd441e611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac5eb6a022dcc12e47bb871209d94fa5b">pl_VectorSqrtF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1054c302ddd4838a762847abbf7e43f6" title="Returns the square root of the input argument.">pl_SqrtF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gac5eb6a022dcc12e47bb871209d94fa5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6154ea39d75e68b9e9d5330cb3625eec">pl_VectorLogF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3411a481af05f50f2649bfcef48c223a" title="Returns the natural logarithm of the input argument.">pl_LogF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga6154ea39d75e68b9e9d5330cb3625eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5680198a0c9c769ad052a505769d8e65">pl_VectorLog10F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga721bcf745e7cb845b42cda978ad1c5cf" title="Returns the logarithm base 10 of the input argument.">pl_Log10F()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga5680198a0c9c769ad052a505769d8e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2832cd0f9496ce0c593be00454cc1d56">pl_VectorExpF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac90ae85b687ddfe982ab104787bb8a7f" title="Returns the exponent of the input argument.">pl_ExpF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga2832cd0f9496ce0c593be00454cc1d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga138489a0a09ca5131c997c9bf2785020">pl_VectorSquaredF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1ad89904e94262fa52d443da6674517b" title="Returns the input argument squared.">pl_SquaredF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga138489a0a09ca5131c997c9bf2785020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga14c2dd307d97ebea1a2b0a79a4f18f3f">pl_VectorCubedF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaedb66d437bc79576d43c11ba71486853" title="Returns the input argument cubed.">pl_CubedF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga14c2dd307d97ebea1a2b0a79a4f18f3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga624ee54e6e8bab7bd8f81997c07b7242">pl_VectorCeilF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaea7073a4052c7a04dced96c85ddac579" title="Returns the input argument rounded up to the next highest integer.">pl_CeilF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga624ee54e6e8bab7bd8f81997c07b7242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53d443eaba00cc8255d4d1dd7dc3de79">pl_VectorFloorF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gae60d4c966db6b253f1493417ca06f18d" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga53d443eaba00cc8255d4d1dd7dc3de79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga772400768495fd4fd693256ad3c48f33">pl_VectorFracF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gab7f29542e87ca53fd5b4168b6597988b" title="Returns the fractional part of the input argument.">pl_FracF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga772400768495fd4fd693256ad3c48f33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga017d16bd185ae3cf9069e06cc9c2cf88">pl_VectorSignF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga0f25776ceba9bc1831e062af5210df89" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga017d16bd185ae3cf9069e06cc9c2cf88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga434579ecb8b69a86b3c1b5e19640d3e9">pl_VectorM2FF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8a90b2a033250976770d6dfbc26bf02c" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga434579ecb8b69a86b3c1b5e19640d3e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346ccfb5366b8795fb98c20817553baf">pl_VectorF2MF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2fbb504cd6f2549733f07d1fabda6e2b" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga346ccfb5366b8795fb98c20817553baf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6d6a453af826e1347bbe6801068431e4">pl_VectorA2dBF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga50680a3c21e29807f2610a0967e16995" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga6d6a453af826e1347bbe6801068431e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf55e4f2965d3427a503f26e3e3d22a40">pl_VectordB2AF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaaae6e51563bdb41422830414b91e029e" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaf55e4f2965d3427a503f26e3e3d22a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac4ffbe59182ba1514ccd8969ed780394">pl_VectorD2RF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga55565fb50d812509e916d1a5bcd50ed3" title="Returns the input argument converted from degrees to radians.">pl_D2RF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gac4ffbe59182ba1514ccd8969ed780394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdc0d266ab2c818ebf03503c1f1d0044">pl_VectorR2DF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaa294d009df41dd5a5c7ba1f2505ed49d" title="Returns the input argument converted from radians to degrees.">pl_R2DF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gafdc0d266ab2c818ebf03503c1f1d0044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab1abd9fad50bb7512458ef32c19399f3">pl_VectorDistortF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac6733f9a979d84ed6ecdd4288e301b27" title="Returns the input argument distorted.">pl_DistortF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gab1abd9fad50bb7512458ef32c19399f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6bd51dca6361c74850caf92244eefbf4">pl_VectorZapF_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga221e4008898dcbbc16265b267e399350" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapF()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga6bd51dca6361c74850caf92244eefbf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3874b7ec8eb9d6daa7e57928ac093a9c">pl_VectorAddF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga3874b7ec8eb9d6daa7e57928ac093a9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga53fdeba08d131bafeee9e2217b79f77a">pl_VectorAddF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga53fdeba08d131bafeee9e2217b79f77a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c458ac80a73ae97d9836e7cdff6653">pl_VectorAddF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94049aff0b7b8e6710ecde60cd58be33" title="Returns .">pl_AddF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga96c458ac80a73ae97d9836e7cdff6653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9e7dc8aa04be89440e1440b3125cdffc">pl_VectorSubF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga9e7dc8aa04be89440e1440b3125cdffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8935b522deb4e2baf1885c78ef3c5a2">pl_VectorSubF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gad8935b522deb4e2baf1885c78ef3c5a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad545716dacb61f997567075c3a4a6720">pl_VectorSubF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga3195b8723443d971f4b67b6af5f13124" title="Returns .">pl_SubF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gad545716dacb61f997567075c3a4a6720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09b89f66bb8148bc4d7f3ade8f12ab6b">pl_VectorMulF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga09b89f66bb8148bc4d7f3ade8f12ab6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4d02adf1b7e3387b882aee06bf794bab">pl_VectorMulF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga4d02adf1b7e3387b882aee06bf794bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga044d16cfcf2eda7978a038ca4a156144">pl_VectorMulF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0586150351369c6450846b2fb4e99d31" title="Returns .">pl_MulF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga044d16cfcf2eda7978a038ca4a156144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae6db0d03c2bb9e5a663ac3e1d4d3d76a">pl_VectorDivF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gae6db0d03c2bb9e5a663ac3e1d4d3d76a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga647b8c4642bc5c02b4b4ad7fca5434eb">pl_VectorDivF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga647b8c4642bc5c02b4b4ad7fca5434eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fb4b91f3c0068e6b0805195a7899c34">pl_VectorDivF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7cd062d19d3e7c0d5d9c2ad218f016f3" title="Returns .">pl_DivF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga7fb4b91f3c0068e6b0805195a7899c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa31eb103c9cb1b7af8ec1d68940fc816">pl_VectorMinF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaa31eb103c9cb1b7af8ec1d68940fc816"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa3a514ff8c829f3f0c34cc3cb8532fa9">pl_VectorMinF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaa3a514ff8c829f3f0c34cc3cb8532fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8dd296051688e3035e6d0f7dff95c2ab">pl_VectorMinF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga423cca3e7ed31a33d06afb0053ee024a" title="Returns minimum of a and b.">pl_MinF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga8dd296051688e3035e6d0f7dff95c2ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad8ee95f778cdfcd034e902fb81f7c885">pl_VectorMaxF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gad8ee95f778cdfcd034e902fb81f7c885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2e548c19fcaaa84dc28e05af2b4cd88a">pl_VectorMaxF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga2e548c19fcaaa84dc28e05af2b4cd88a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaabafa18c8dd0ec2c12e11b6f42cc2493">pl_VectorMaxF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga7d3f060f2bb9dbd233b679af4f6527b2" title="Returns maximum of a and b.">pl_MaxF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaabafa18c8dd0ec2c12e11b6f42cc2493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadf3b8ea80497eeec187a20e7e2848ed7">pl_VectorPowF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gadf3b8ea80497eeec187a20e7e2848ed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga483ff2d8bea2cdeec487db5efffa3d3a">pl_VectorPowF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga483ff2d8bea2cdeec487db5efffa3d3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga96c1025337d92429c8734e175143f1f7">pl_VectorPowF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga1636222e26b467dba7c062207545cdbd" title="Returns a raised to the power b.">pl_PowF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga96c1025337d92429c8734e175143f1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5cbc606bff150d3be2e698aac7dc5ce4">pl_VectorIsEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga5cbc606bff150d3be2e698aac7dc5ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacf88f51bb6a26c2d0a68e994d863711c">pl_VectorIsEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gacf88f51bb6a26c2d0a68e994d863711c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedb79426fa90a29103fce022679f32f4">pl_VectorIsEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga5f99b2ef37521573669ae59e27be7e18" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaedb79426fa90a29103fce022679f32f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9a46a8c1db7476211bdd6b44fb19d49">pl_VectorIsNotEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gae9a46a8c1db7476211bdd6b44fb19d49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga774c6a0e634df1f397516a6a805a4d6d">pl_VectorIsNotEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga774c6a0e634df1f397516a6a805a4d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga56a9fe4ef33f7d81a29e7aab0a1592c0">pl_VectorIsNotEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8dae0bad8a8e61635058baa7d5d124a7" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga56a9fe4ef33f7d81a29e7aab0a1592c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6030e695b7b354d7c668506b6dd8777e">pl_VectorIsGreaterThanF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga6030e695b7b354d7c668506b6dd8777e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3298d662a1a1002f1a911cf89576f12e">pl_VectorIsGreaterThanF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga3298d662a1a1002f1a911cf89576f12e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7ff4eb184fe6458d583af93f5f5d72a3">pl_VectorIsGreaterThanF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga42224769b1d547f65d7afe530e24a782" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga7ff4eb184fe6458d583af93f5f5d72a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga34dbb414e4e85a5dc21cab04efb36e17">pl_VectorIsGreaterThanOrEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga34dbb414e4e85a5dc21cab04efb36e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5c70aa006400c76931250bdcccf52e37">pl_VectorIsGreaterThanOrEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga5c70aa006400c76931250bdcccf52e37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9563d0b877e5656f9e68dbe1f172b1c2">pl_VectorIsGreaterThanOrEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6135fc355e7b4ecf76afb9293c814f36" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga9563d0b877e5656f9e68dbe1f172b1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafc1473081b72235572bbcb4180f85532">pl_VectorIsLessThanF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gafc1473081b72235572bbcb4180f85532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gada27b912481be2974f2df10287c24cca">pl_VectorIsLessThanF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gada27b912481be2974f2df10287c24cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98ef2362c8ee3b97169746404863b0bb">pl_VectorIsLessThanF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga57a877dffa9aee83b54aebfa40c8e4c6" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga98ef2362c8ee3b97169746404863b0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae336bfe2cf955934a4cee32d66b4817e">pl_VectorIsLessThanOrEqualToF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gae336bfe2cf955934a4cee32d66b4817e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f64176207c3d68ae22cddb34d496266">pl_VectorIsLessThanOrEqualToF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga5f64176207c3d68ae22cddb34d496266"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9b4e616e12b4510ed11658d46985b6d">pl_VectorIsLessThanOrEqualToF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90cceb4d492e11827b62d42d50d65981" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaa9b4e616e12b4510ed11658d46985b6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabff48d9f05d09c6fc3024f2095a91630">pl_VectorHypotF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gabff48d9f05d09c6fc3024f2095a91630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga939e06569593c806d533ea61e4b98327">pl_VectorHypotF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga939e06569593c806d533ea61e4b98327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf0893c32e31d72a7e91badc4abf62b3b">pl_VectorHypotF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaff17fbdad0951763b813ef99e1505ba0" title="Returns .">pl_HypotF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaf0893c32e31d72a7e91badc4abf62b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga44812f3688888b573be8c9db069b936a">pl_VectorAtan2F_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga44812f3688888b573be8c9db069b936a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaece9a054e73c28bd180580b0cd016018">pl_VectorAtan2F_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaece9a054e73c28bd180580b0cd016018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1570febbc25f8b9a3ef7ac8cc7af07ae">pl_VectorAtan2F_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6398472a918e14aeb79f11a8948e6a24" title="Returns .">pl_Atan2F()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga1570febbc25f8b9a3ef7ac8cc7af07ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga52cc262cb6455a1ccb4bb7d6a3b78467">pl_VectorSumSqrF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga52cc262cb6455a1ccb4bb7d6a3b78467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafaba968683dddc1cb6ee402811875181">pl_VectorSumSqrF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gafaba968683dddc1cb6ee402811875181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5484d71a34bd278e75b8cecf45e7263">pl_VectorSumSqrF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaddcbd7645d9348e061fe51e8739b1c28" title="Returns .">pl_SumSqrF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gad5484d71a34bd278e75b8cecf45e7263"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaecd22cb5b339a05a83a47ce9a5eb303d">pl_VectorDifSqrF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaecd22cb5b339a05a83a47ce9a5eb303d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaab11b4161a9b842caf8431aa6e578f81">pl_VectorDifSqrF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaab11b4161a9b842caf8431aa6e578f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga8c6f0bc2d31739420492413ade319f84">pl_VectorDifSqrF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gab3294d19a6d57a7937bc071891252efa" title="Returns .">pl_DifSqrF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga8c6f0bc2d31739420492413ade319f84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa44f0e93a59157dc2ed7a1a320606de3">pl_VectorSqrSumF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaa44f0e93a59157dc2ed7a1a320606de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0cc252e1e632dd35bbb13d318f6bf51b">pl_VectorSqrSumF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga0cc252e1e632dd35bbb13d318f6bf51b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3568d95bc0f3df06126f00db48d52385">pl_VectorSqrSumF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6cc65e053fabc3b4980b1bce2bd265b1" title="Returns .">pl_SqrSumF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga3568d95bc0f3df06126f00db48d52385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae247f0ca7d07614d80fb70fd4f3b20ab">pl_VectorSqrDifF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gae247f0ca7d07614d80fb70fd4f3b20ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2229b5869509b5f0947e8927262f23b0">pl_VectorSqrDifF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga2229b5869509b5f0947e8927262f23b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga381554ead66ca6856122b66b1e9bf063">pl_VectorSqrDifF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabbb0a26f6febc273c32beaa63d130491" title="Returns .">pl_SqrDifF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga381554ead66ca6856122b66b1e9bf063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa9d78883696faed1ffc7b1ed6cbb4bc8">pl_VectorAbsDifF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaa9d78883696faed1ffc7b1ed6cbb4bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1c8da37fdfd80aebd9d1743a0da9b497">pl_VectorAbsDifF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga1c8da37fdfd80aebd9d1743a0da9b497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3a66577c30fc72bd6eff2271f9c10b16">pl_VectorAbsDifF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d9d94b5f83f1b3c59e66fa7816943b6" title="Returns the absolute difference between the input arguments.">pl_AbsDifF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga3a66577c30fc72bd6eff2271f9c10b16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3161963fd5d2e9453250a93f01226f5d">pl_VectorThreshF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga3161963fd5d2e9453250a93f01226f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae27592fcf9a6e2511f691e2b840340a9">pl_VectorThreshF_NN1</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gae27592fcf9a6e2511f691e2b840340a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9bc9357afdaecf35a48a2819a1673ec5">pl_VectorThreshF_N1N</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> a, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac24bec6ed723b1850a02777c03d03837" title="If a is less than b returns 0 otherwise return a.">pl_ThreshF()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga9bc9357afdaecf35a48a2819a1673ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9877065544b3718d8d187d5f50cdf24">pl_VectorMulAddF_NNN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *io, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *mul, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *add, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="group___plank_vector_functions.html#gad9877065544b3718d8d187d5f50cdf24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaddee28f3d1f630066c181c8a6ac97aea">pl_VectorLookupF_NnN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *table, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> n, <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *index, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="group___plank_vector_functions.html#gaddee28f3d1f630066c181c8a6ac97aea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3d51b6cf9010ce1fa63b9762249261a0">pl_VectorFillD_N1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> value, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a constant.  <a href="group___plank_vector_functions.html#ga3d51b6cf9010ce1fa63b9762249261a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa347eccfa116a68b56f8f5eee79e5707">pl_VectorClearD_N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with zeros.  <a href="group___plank_vector_functions.html#gaa347eccfa116a68b56f8f5eee79e5707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac60fec7cc8a88e48270833135205ec12">pl_VectorRampD_N11</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a ramp.  <a href="group___plank_vector_functions.html#gac60fec7cc8a88e48270833135205ec12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga81e869fd2297a6c57b5e3a312fc33b74">pl_VectorLineD_N11</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector with a line.  <a href="group___plank_vector_functions.html#ga81e869fd2297a6c57b5e3a312fc33b74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga92916e1daf6e82d9404d525e42389b45">pl_VectorMoveD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga754d66954713e2d287a4732bc9f3835c" title="Just returns the input argument.">pl_MoveD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga92916e1daf6e82d9404d525e42389b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad49e011e4ca3f76de0b8ec5c1d6d81e6">pl_VectorNegD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gafab5e6f96a4ae2100219c17d4ab33d54" title="Returns the negative of the input argument.">pl_NegD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gad49e011e4ca3f76de0b8ec5c1d6d81e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaec21dab0c087e0b170745b2e3efd207b">pl_VectorAbsD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga3abed4819ea079935becaee097c1b131" title="Returns the absolute of the input argument.">pl_AbsD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaec21dab0c087e0b170745b2e3efd207b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2f77253685ccd08349ad129a0bc09a23">pl_VectorLog2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga63b2b10f119a9e85835cd1c52659db85" title="Returns the logarithm base 2 of the input argument.">pl_Log2D()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga2f77253685ccd08349ad129a0bc09a23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga88f1c17c13d19ff647a659e21164ec91">pl_VectorReciprocalD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad86ace90fe2ea6f9a3fbd6d490411d94" title="Returns the reciprocal of the input argument (i.e, ).">pl_ReciprocalD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga88f1c17c13d19ff647a659e21164ec91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab78a731a99877c501f2531b263ed0ff7">pl_VectorSinD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga05a9ada88f21fae3424b96bc702efbd9" title="Returns the sine of the input argument.">pl_SinD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gab78a731a99877c501f2531b263ed0ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5eb1030590f71b5165e3f72b6bd656e5">pl_VectorCosD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga71e32eb4c3e8a7135f7028a16fb8b55d" title="Returns the cosine of the input argument.">pl_CosD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga5eb1030590f71b5165e3f72b6bd656e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga135af6226d8b96e81abaaba6f9cd0b06">pl_VectorTanD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7c0d061f726b227dc80ef6fcc60399bf" title="Returns the tangent of the input argument.">pl_TanD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga135af6226d8b96e81abaaba6f9cd0b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedae3e19d90c4a4cb5212edadcd76f76">pl_VectorAsinD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4e5d74f2d8fb5d8503c0d1378ff67528" title="Returns the arcsine of the input argument.">pl_AsinD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaedae3e19d90c4a4cb5212edadcd76f76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacac99df0db7dad5461861849601a0dc8">pl_VectorAcosD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaecd4def003a534923d1342fe11af5028" title="Returns the arcosine of the input argument.">pl_AcosD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gacac99df0db7dad5461861849601a0dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2dcc5850da8f410f63fb5c929a0f7e76">pl_VectorAtanD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac9c8a17625345c474954b33c728fba4f" title="Returns the arctangent of the input argument.">pl_AtanD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga2dcc5850da8f410f63fb5c929a0f7e76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaebafcf0bf05dade5b95bf6066808f623">pl_VectorSinhD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga8070a645911752f5e9ac9561f913aef4" title="Returns the hyperbolic sine of the input argument.">pl_SinhD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaebafcf0bf05dade5b95bf6066808f623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5853e6b3aff90d56b2d433da806d858f">pl_VectorCoshD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga93a00c44db3ff597f7a57869dfeedb6e" title="Returns the hyperbolic cosine of the input argument.">pl_CoshD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga5853e6b3aff90d56b2d433da806d858f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga250f2e61d743622a1609f85839f9c4bb">pl_VectorTanhD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga88ca17d57234ef605e2233a118aee8fe" title="Returns the hyperbolic tangent of the input argument.">pl_TanhD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga250f2e61d743622a1609f85839f9c4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga540c096f6e4382440007c878047f4f5d">pl_VectorSqrtD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga1cc033112e9660b8647e74aa3a1b94ed" title="Returns the square root of the input argument.">pl_SqrtD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga540c096f6e4382440007c878047f4f5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b06f007387aeffb3ebd2214f5090fb8">pl_VectorLogD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga112778b49b391a2c444bd1bdd510dc09" title="Returns the natural logarithm of the input argument.">pl_LogD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga3b06f007387aeffb3ebd2214f5090fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a5902d66076b7527b8ca6a674fef22e">pl_VectorLog10D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga7f2cb185c8e2b8a6e17b150903cfb344" title="Returns the logarithm base 10 of the input argument.">pl_Log10D()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga1a5902d66076b7527b8ca6a674fef22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga346a791b777f3fb3ce4a8b5ab8dd0133">pl_VectorExpD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gadaa32d432245768cf1cda0d0997a6308" title="Returns the exponent of the input argument.">pl_ExpD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga346a791b777f3fb3ce4a8b5ab8dd0133"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac6d6857d70c11dac6815925aa5fbe258">pl_VectorSquaredD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga650925e99f01eb75c031f6beb7d20a92" title="Returns the input argument squared.">pl_SquaredD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gac6d6857d70c11dac6815925aa5fbe258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac92318b9550618c0eb61f5c6db28b6f0">pl_VectorCubedD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gac862753d321c0959563fc250e5cfbf5f" title="Returns the input argument cubed.">pl_CubedD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gac92318b9550618c0eb61f5c6db28b6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga50da194cf31d82e931c3d2b3509934b3">pl_VectorCeilD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga022a4169851f70d61d18090f1ed33de3" title="Returns the input argument rounded up to the next highest integer.">pl_CeilD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga50da194cf31d82e931c3d2b3509934b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0fabcca5e7164c365cecccf20a2ad394">pl_VectorFloorD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga00d7b64487da47afe70db45db840e6cc" title="Returns the input argument rounded down to the next lowest integer.">pl_FloorD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga0fabcca5e7164c365cecccf20a2ad394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaeb35318b9e872a8d4d86d9c795d368b2">pl_VectorFracD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga5176c934c987a71c7867af8179486472" title="Returns the fractional part of the input argument.">pl_FracD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaeb35318b9e872a8d4d86d9c795d368b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga35254ed489bf9f5825bac6d353d80eac">pl_VectorSignD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga2c9f56b92320d80feb209b61bc899057" title="Returns 0 if the input is 0, -1 if the input is negative or 1 if the input argument is positive...">pl_SignD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga35254ed489bf9f5825bac6d353d80eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga08b1418b75b12da60a96a514008a3e2d">pl_VectorM2FD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4ed411f2c409aa5a64c96d6ce9529165" title="Returns the input argument converted from MIDI note numbers to frequency (in Hz).">pl_M2FD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga08b1418b75b12da60a96a514008a3e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga781a129439e1bb1dd0295a99085f3a84">pl_VectorF2MD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga4749786c700311a0593cba415177ef1e" title="Returns the input argument converted from frequency (in Hz) to MIDI note numbers.">pl_F2MD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga781a129439e1bb1dd0295a99085f3a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae0e337b7b89735618a1855ea91660bd9">pl_VectorA2dBD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga25500f8339961ab245fea970a454f001" title="Returns the input argument converted from linear amplitude to decibels where 0dB is an amplitude of 1...">pl_A2dBD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gae0e337b7b89735618a1855ea91660bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7bb9f2cc273aaefa164d83f970e30380">pl_VectordB2AD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga89d70c9e30576872fda245aa3ecad1dc" title="Returns the input argument converted from decibels to linear amplitude where 0dB is an amplitude of 1...">pl_dB2AD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#ga7bb9f2cc273aaefa164d83f970e30380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaba41fd68b23cb9bdd1cefb6c4b71c7a4">pl_VectorD2RD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gad5e25003bbb6a68d7ee9ef6295647f5e" title="Returns the input argument converted from degrees to radians.">pl_D2RD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaba41fd68b23cb9bdd1cefb6c4b71c7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa22058ab0b84dd204cd0818f7eee4e71">pl_VectorR2DD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#gaadfb3bf407a277817a4fd7ae67d84c70" title="Returns the input argument converted from radians to degrees.">pl_R2DD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gaa22058ab0b84dd204cd0818f7eee4e71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae1c81935d93b40e48a4986fc20c9e34b">pl_VectorDistortD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga52b93af939f6ca274d514b2ae3ee692b" title="Returns the input argument distorted.">pl_DistortD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gae1c81935d93b40e48a4986fc20c9e34b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabfeb5cce886741713f4db15d8e45530a">pl_VectorZapD_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function <a class="el" href="group___plank_maths_functions.html#ga95dcdb9612f2e6349e9dc07c587562ce" title="Returns the input argument with infinities, NaNs and denormallised numbers removed.">pl_ZapD()</a> to each item in a vector.  <a href="group___plank_vector_functions.html#gabfeb5cce886741713f4db15d8e45530a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga12ef092e0c8e669d7762e69d0559e3a2">pl_VectorAddD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga12ef092e0c8e669d7762e69d0559e3a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae41675932ccb373a167cd2c83e3df768">pl_VectorAddD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gae41675932ccb373a167cd2c83e3df768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5a1316615dc2031b02b71424f44d657f">pl_VectorAddD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga978ae5cc15df8c6bc50c6a9187de3f24" title="Returns .">pl_AddD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga5a1316615dc2031b02b71424f44d657f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa1ad270a88e18f6e9c8a51c450c3e41f">pl_VectorSubD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaa1ad270a88e18f6e9c8a51c450c3e41f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1a28dc464696905e52db911b3f97566e">pl_VectorSubD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga1a28dc464696905e52db911b3f97566e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab8ea462ef620ebc5dd512f0df2224508">pl_VectorSubD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0ece8fe3b61a411cd7f4f47e8e6708ac" title="Returns .">pl_SubD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gab8ea462ef620ebc5dd512f0df2224508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga49295bf725772df3865b0fe99be4552e">pl_VectorMulD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga49295bf725772df3865b0fe99be4552e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1bc824231e441539c1ee7df8b50e0391">pl_VectorMulD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga1bc824231e441539c1ee7df8b50e0391"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf5e80360d5aae32ecddfba037c215af8">pl_VectorMulD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0f8928287a4a4fbfcff5b4843ba6f8e1" title="Returns .">pl_MulD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaf5e80360d5aae32ecddfba037c215af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga1fa89f9180cd6811ec7a0eb94605b996">pl_VectorDivD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga1fa89f9180cd6811ec7a0eb94605b996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa19c40021b63a0d14db1eddd9d0a037e">pl_VectorDivD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaa19c40021b63a0d14db1eddd9d0a037e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a">pl_VectorDivD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga4b48b69d14f582db2a0d2be7a0192cb0" title="Returns .">pl_DivD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga98a3a9eeb92bfa82aa1d7f6d12fbd89a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3267ac92b409d85e0f1195214d19bcf1">pl_VectorMinD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga3267ac92b409d85e0f1195214d19bcf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga750a9c78d6f4857c73ab1ee9cdbd65ad">pl_VectorMinD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga750a9c78d6f4857c73ab1ee9cdbd65ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09f665f6b1bddb3bd7669410e10b3c02">pl_VectorMinD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga90c5aa20c29af981a057f2e215cb4aea" title="Returns minimum of a and b.">pl_MinD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga09f665f6b1bddb3bd7669410e10b3c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab73fa94aad3f3a9ea9b4281fa2a45637">pl_VectorMaxD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gab73fa94aad3f3a9ea9b4281fa2a45637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafdcc887ab924c442c0496cd98cb8bf08">pl_VectorMaxD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gafdcc887ab924c442c0496cd98cb8bf08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad687be0c0ca10457b0d9ea29d3e737c2">pl_VectorMaxD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga26735381f5a1fe41ad8ecbb576ad80f5" title="Returns maximum of a and b.">pl_MaxD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gad687be0c0ca10457b0d9ea29d3e737c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3373906398e94de141273acb0d6390c9">pl_VectorPowD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga3373906398e94de141273acb0d6390c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4b253f22b62b7117f6af0c31abfd6c07">pl_VectorPowD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga4b253f22b62b7117f6af0c31abfd6c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9296c3251eb6571e43019400f83c765c">pl_VectorPowD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga8a45dc6511a59d71dc2d06467b7f9965" title="Returns a raised to the power b.">pl_PowD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga9296c3251eb6571e43019400f83c765c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa6557cbdeb7309d19bb44c69a8b68ac5">pl_VectorIsEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaa6557cbdeb7309d19bb44c69a8b68ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6b41819ebe1d49fbf7fcea593eea1585">pl_VectorIsEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga6b41819ebe1d49fbf7fcea593eea1585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaced300febadf01a9bb061b2eb55b4c82">pl_VectorIsEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gadce33f1551a89e982bfaae51c4769fb8" title="Returns 1 if the inputs are equal otherwise returns 0.">pl_IsEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaced300febadf01a9bb061b2eb55b4c82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4fb086ed252f0f5f8504088cf286ed35">pl_VectorIsNotEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga4fb086ed252f0f5f8504088cf286ed35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga427f715543dfb78fa061b1da9ae2f34c">pl_VectorIsNotEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga427f715543dfb78fa061b1da9ae2f34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacc43628c757ac7fbf663ecf1d09aa5a7">pl_VectorIsNotEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga94470c822ac243f74aff9fd153427154" title="Returns 1 if the inputs are not equal otherwise returns 0.">pl_IsNotEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gacc43628c757ac7fbf663ecf1d09aa5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga742971fee5ae052c2cb95a9955cf7542">pl_VectorIsGreaterThanD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga742971fee5ae052c2cb95a9955cf7542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5fb9c4d06a6d72de5ce40804ff346460">pl_VectorIsGreaterThanD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga5fb9c4d06a6d72de5ce40804ff346460"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75e868cbab5a492e1daebf106fe89d64">pl_VectorIsGreaterThanD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gace2e7d74c4853140b481a4b09dff7bb8" title="Returns 1 if the a is greater than b otherwise returns 0.">pl_IsGreaterThanD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga75e868cbab5a492e1daebf106fe89d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad5db5ae33ecc38702db1987d7f58003d">pl_VectorIsGreaterThanOrEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gad5db5ae33ecc38702db1987d7f58003d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09d06ce6f60c7093743530f7340d0db3">pl_VectorIsGreaterThanOrEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga09d06ce6f60c7093743530f7340d0db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf1b670f32504cfee3765b6f7aec16a60">pl_VectorIsGreaterThanOrEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga267b5f04240db101f50bbddf65c57409" title="Returns 1 if the a is greater than or equal to b otherwise returns 0.">pl_IsGreaterThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaf1b670f32504cfee3765b6f7aec16a60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga991f8dd0bbc5c9dfca56eb70e2139dfe">pl_VectorIsLessThanD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga991f8dd0bbc5c9dfca56eb70e2139dfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7eb97b849367dd8a0b92c4e4cdffe983">pl_VectorIsLessThanD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga7eb97b849367dd8a0b92c4e4cdffe983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3f91ec7596d951ef68b47e277ef6c5ba">pl_VectorIsLessThanD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga0c2e0523e7d1dd182ba3011eaf3dcd06" title="Returns 1 if the a is less than b otherwise returns 0.">pl_IsLessThanD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga3f91ec7596d951ef68b47e277ef6c5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga75601e89fa96c2711c9c1d762bd26633">pl_VectorIsLessThanOrEqualToD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga75601e89fa96c2711c9c1d762bd26633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae14f26d0d6c23b301370264f5d2f5820">pl_VectorIsLessThanOrEqualToD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gae14f26d0d6c23b301370264f5d2f5820"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga883e9677cffce2e7a385c048c0cf6051">pl_VectorIsLessThanOrEqualToD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gacae863b2196244ac11f0575e635ee6a5" title="Returns 1 if the a is less than or equal to b otherwise returns 0.">pl_IsLessThanOrEqualToD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga883e9677cffce2e7a385c048c0cf6051"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga400b8712d0ef2f7222022e3030ab65d5">pl_VectorHypotD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga400b8712d0ef2f7222022e3030ab65d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadefa93b1fb00f994acaf717eb876f05b">pl_VectorHypotD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gadefa93b1fb00f994acaf717eb876f05b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4beba0c36335d94c6c76b9a16aaee33f">pl_VectorHypotD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaf967c719bfec3b395ddf14598a2c71a7" title="Returns .">pl_HypotD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga4beba0c36335d94c6c76b9a16aaee33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga89afb2f55dfc5f5a749799d78aa27693">pl_VectorAtan2D_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga89afb2f55dfc5f5a749799d78aa27693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae9ae9c8c64cfe988951cbc4b51b81abf">pl_VectorAtan2D_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gae9ae9c8c64cfe988951cbc4b51b81abf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadac799a76f6ffc595d2b0771279a48a4">pl_VectorAtan2D_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaea36eb66a008077875488271614dc584" title="Returns .">pl_Atan2D()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gadac799a76f6ffc595d2b0771279a48a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4bb7bd02652c307ae3f496df0354e8a3">pl_VectorSumSqrD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga4bb7bd02652c307ae3f496df0354e8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga79278b4c9dbf253e5179556919e9b35b">pl_VectorSumSqrD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga79278b4c9dbf253e5179556919e9b35b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadc42b9865fb1e2b4f33ec9da262b2092">pl_VectorSumSqrD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga6ae4b646a620622e2776915c82197c8d" title="Returns .">pl_SumSqrD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gadc42b9865fb1e2b4f33ec9da262b2092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaac8f1f8d6c6d929b667f15dbe053831c">pl_VectorDifSqrD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#gaac8f1f8d6c6d929b667f15dbe053831c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga46775562a5d0bbd8d670bd7e95284783">pl_VectorDifSqrD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga46775562a5d0bbd8d670bd7e95284783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9d40bd884f8f805edebd3c59ca883a38">pl_VectorDifSqrD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga9d0baaacc5e3c7b0d29c7b3c2107dbc7" title="Returns .">pl_DifSqrD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga9d40bd884f8f805edebd3c59ca883a38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga788004c04a717f469b0f1998d4f62067">pl_VectorSqrSumD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga788004c04a717f469b0f1998d4f62067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac9a2a0223d3af7c542c0fa570ce00a17">pl_VectorSqrSumD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gac9a2a0223d3af7c542c0fa570ce00a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5f56150d804d6952997e90fb803958e4">pl_VectorSqrSumD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gabd69fea93b359ded950ec2b2f174fffc" title="Returns .">pl_SqrSumD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga5f56150d804d6952997e90fb803958e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4e737d98b7ad71c71432248a39c2ce16">pl_VectorSqrDifD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga4e737d98b7ad71c71432248a39c2ce16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga6f6940ac9a86f57efe4bce7400d9234b">pl_VectorSqrDifD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga6f6940ac9a86f57efe4bce7400d9234b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2001054b1fcbeee5191c265bcbaeea2c">pl_VectorSqrDifD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#ga03cfbc0e0273810105de847c874a6331" title="Returns .">pl_SqrDifD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga2001054b1fcbeee5191c265bcbaeea2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5778badb734f9dc6fab15eadd6e31bc7">pl_VectorAbsDifD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga5778badb734f9dc6fab15eadd6e31bc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf7625f658d95e5bfaa275bcb24560575">pl_VectorAbsDifD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#gaf7625f658d95e5bfaa275bcb24560575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga7fcc23c11a1a0ef8790d60c4be0ce4fd">pl_VectorAbsDifD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gac953475056afca0d56c2bf794921a61f" title="Returns the absolute difference between the input arguments.">pl_AbsDifD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga7fcc23c11a1a0ef8790d60c4be0ce4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga57d7f27f996ba4e74be09197791e404d">pl_VectorThreshD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to each item in two input vectors.  <a href="group___plank_vector_functions.html#ga57d7f27f996ba4e74be09197791e404d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga87f14ff8770a1f823a4157bc40e1e5d6">pl_VectorThreshD_NN1</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga87f14ff8770a1f823a4157bc40e1e5d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0ddd02df030d53aa2e7ef50e24d6aa84">pl_VectorThreshD_N1N</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> a, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *b, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the binary operator function <a class="el" href="group___plank_maths_functions.html#gaba2dbb4ba56bfd9897a0edb5198afd2b" title="If a is less than b returns 0 otherwise return a.">pl_ThreshD()</a> to an input vector and a scalar value.  <a href="group___plank_vector_functions.html#ga0ddd02df030d53aa2e7ef50e24d6aa84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4f1ffab901ada34b727346e72b700627">pl_VectorMulAddD_NNN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *io, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *mul, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *add, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the multiply and add operator to a set of vectors.  <a href="group___plank_vector_functions.html#ga4f1ffab901ada34b727346e72b700627"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gadaaf12325ee661c80ccc2c3a227ddf5d">pl_VectorLookupD_NnN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *table, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> n, <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *index, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector by using another vector as the indices into a lookup table.  <a href="group___plank_vector_functions.html#gadaaf12325ee661c80ccc2c3a227ddf5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gacbc71dd2eca4c999c95c102a9c73cc93">pl_VectorConvertF2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gacbc71dd2eca4c999c95c102a9c73cc93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab24285a50f2a54306afd123b26565712">pl_VectorConvertD2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gab24285a50f2a54306afd123b26565712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5cc444c966b81277ed6ee74d9c886739">pl_VectorConvertC2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga5cc444c966b81277ed6ee74d9c886739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5eaf68cc4df2f0c8fad4539b56a18d51">pl_VectorConvertI2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga5eaf68cc4df2f0c8fad4539b56a18d51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga3b51b5328580cc5ddf4521f4703c5b55">pl_VectorConvertS2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga3b51b5328580cc5ddf4521f4703c5b55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafbd6fd167171c338f68603c0702f163e">pl_VectorConvertL2F_NN</a> (<a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gafbd6fd167171c338f68603c0702f163e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4e285c9f6dcaa89e390afa72c6a6b09b">pl_VectorConvertF2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga4e285c9f6dcaa89e390afa72c6a6b09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga9f42da972277e2deb1bf0dcf69db01e8">pl_VectorConvertD2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga9f42da972277e2deb1bf0dcf69db01e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaedc6a191f061ddada0e208e42f8f838d">pl_VectorConvertC2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gaedc6a191f061ddada0e208e42f8f838d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaced113e4c43b1e2215f05dbdd8b12acf">pl_VectorConvertI2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gaced113e4c43b1e2215f05dbdd8b12acf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga0d3db035bc4c110b3e12a119f6160282">pl_VectorConvertS2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga0d3db035bc4c110b3e12a119f6160282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gababc20fcad2f2a506e40821426a23477">pl_VectorConvertL2D_NN</a> (<a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gababc20fcad2f2a506e40821426a23477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga942c4382f9ae4bd6978b49f53c43a03c">pl_VectorConvertF2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga942c4382f9ae4bd6978b49f53c43a03c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga80f5fee7b516ceaaa0b261589d3ee87c">pl_VectorConvertD2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga80f5fee7b516ceaaa0b261589d3ee87c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gad9ee67f05d621c58833ae61bedf7393e">pl_VectorConvertC2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gad9ee67f05d621c58833ae61bedf7393e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gab931e55a5e5c2dc325262ddce0b6c900">pl_VectorConvertI2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gab931e55a5e5c2dc325262ddce0b6c900"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga5ff4edc54c8076017f196becd1dd3138">pl_VectorConvertS2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga5ff4edc54c8076017f196becd1dd3138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga59ebc7d932991c002cba1f42758477ca">pl_VectorConvertL2C_NN</a> (<a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga59ebc7d932991c002cba1f42758477ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga466e308e8944174cd5f8202a1bcc5baa">pl_VectorConvertF2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga466e308e8944174cd5f8202a1bcc5baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga09cd4d35ff54eddd0c90639e00307112">pl_VectorConvertD2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga09cd4d35ff54eddd0c90639e00307112"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga69f7eb876585caae9455b5e328774831">pl_VectorConvertC2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga69f7eb876585caae9455b5e328774831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gafcda88f35a46b22d02cbc9a107121573">pl_VectorConvertI2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gafcda88f35a46b22d02cbc9a107121573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gae3b94b589f0cb52834f70a44afb3658a">pl_VectorConvertS2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gae3b94b589f0cb52834f70a44afb3658a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaa13285fa1d5084041fe8c964a544c1b2">pl_VectorConvertL2I_NN</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gaa13285fa1d5084041fe8c964a544c1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga64328cc0671095e95ce6980ab94713db">pl_VectorConvertF2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga64328cc0671095e95ce6980ab94713db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaf8d79e8f5006f3a67310223f4aa94d13">pl_VectorConvertD2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gaf8d79e8f5006f3a67310223f4aa94d13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gade5aa6494a873eb2f9387846caf271f8">pl_VectorConvertC2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gade5aa6494a873eb2f9387846caf271f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gade71481d4db8844ba37b7eb0ca2a18aa">pl_VectorConvertI2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gade71481d4db8844ba37b7eb0ca2a18aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabc6677e90f170c8309699d4e2ea5a4ac">pl_VectorConvertS2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gabc6677e90f170c8309699d4e2ea5a4ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gabb50f2151ee649452a81e9aa985e4756">pl_VectorConvertL2S_NN</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gabb50f2151ee649452a81e9aa985e4756"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gaec26c24ad8939fe96a95aed17fefebf5">pl_VectorConvertF2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a112bc0a07d6c7fa2ac00ab91046f7a4c">PlankF</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gaec26c24ad8939fe96a95aed17fefebf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2b10e4b7de6bc78ce1e0ba5f5a6b8552">pl_VectorConvertD2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#af1b487c8f51d07cf53b0341c67ce2d03">PlankD</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga2b10e4b7de6bc78ce1e0ba5f5a6b8552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga95770db3f02219ab53d8cf0ae65dae49">pl_VectorConvertC2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a5310c6b3fc8ca859506373d71afdd89a">PlankC</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga95770db3f02219ab53d8cf0ae65dae49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga2c3df1cbf15e2ce9476b2ce45b807e50">pl_VectorConvertI2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga2c3df1cbf15e2ce9476b2ce45b807e50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#ga4aa5ede069e1c9a8a6fc9c954fdc82dc">pl_VectorConvertS2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#ga4aa5ede069e1c9a8a6fc9c954fdc82dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_vector_functions.html#gac52c925e70f7b708c5439692c8d27c22">pl_VectorConvertL2L_NN</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *result, const <a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *a, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of one data type to another.  <a href="group___plank_vector_functions.html#gac52c925e70f7b708c5439692c8d27c22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#gaad47ed6ec1112e62fbcf37d52bf3e8ba">pl_VectorSwapEndianUS</a> (<a class="el" href="plank___standard_header_8h.html#ac403835a47846de2698d75c6089ba2a2">PlankUS</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of unsigned short elements.  <a href="group___plank_endian_functions.html#gaad47ed6ec1112e62fbcf37d52bf3e8ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#gac2a9bbe8bd68d2e4f0ad845302a35e41">pl_VectorSwapEndianS</a> (<a class="el" href="plank___standard_header_8h.html#aed2b7d72d154175c22ab3263ab7a9dda">PlankS</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of short elements.  <a href="group___plank_endian_functions.html#gac2a9bbe8bd68d2e4f0ad845302a35e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga95ac1433588bc708224d63b722b8f5f8">pl_VectorSwapEndianUI24</a> (<a class="el" href="struct_plank_u_i24.html">PlankUI24</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of unsigned 24-bit int elements.  <a href="group___plank_endian_functions.html#ga95ac1433588bc708224d63b722b8f5f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga7604245ac9f66736a91b5021f3de2b37">pl_VectorSwapEndianI24</a> (<a class="el" href="struct_plank_i24.html">PlankI24</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of 24-bit int elements.  <a href="group___plank_endian_functions.html#ga7604245ac9f66736a91b5021f3de2b37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga6375760408bb72569315fd789584f54d">pl_VectorSwapEndianUI</a> (<a class="el" href="plank___standard_header_8h.html#a534ce6be2740f71e6fdde856c4ce8ee2">PlankUI</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of unsigned int elements.  <a href="group___plank_endian_functions.html#ga6375760408bb72569315fd789584f54d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga50132656767457518fb71a5fa1a16f8a">pl_VectorSwapEndianI</a> (<a class="el" href="plank___standard_header_8h.html#adc55cc3e1effd5d94c88cc90d1117ce5">PlankI</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of int elements.  <a href="group___plank_endian_functions.html#ga50132656767457518fb71a5fa1a16f8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga13e357d6631b9249b071eed95bab3427">pl_VectorSwapEndianUL</a> (<a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of unsigned long elements.  <a href="group___plank_endian_functions.html#ga13e357d6631b9249b071eed95bab3427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga4a934295b74de6f927562b60ca42082c">pl_VectorSwapEndianL</a> (<a class="el" href="plank___standard_header_8h.html#a56a3a82c06ac0807a6e4c7afbece3c3f">PlankL</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of long elements.  <a href="group___plank_endian_functions.html#ga4a934295b74de6f927562b60ca42082c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#ga7c453b13e7b777fbff26687a54638069">pl_VectorSwapEndianULL</a> (<a class="el" href="plank___standard_header_8h.html#a173f1d590f482a0eefff64a9f90a9d26">PlankULL</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of unsigned long long (64-bit) elements.  <a href="group___plank_endian_functions.html#ga7c453b13e7b777fbff26687a54638069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___plank_endian_functions.html#gafe44c27a16eb8deaa2ef6b98515715be">pl_VectorSwapEndianLL</a> (<a class="el" href="plank___standard_header_8h.html#a854e96ed6d678b7cbcbedffce1c0844d">PlankLL</a> *data, <a class="el" href="plank___standard_header_8h.html#aadd8b55b4dce98c3c059523e13f065fe">PlankUL</a> N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the endianness of a vector of long long (64-bit) elements.  <a href="group___plank_endian_functions.html#gafe44c27a16eb8deaa2ef6b98515715be"></a><br/></td></tr>
</table>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 11 2012 19:17:25 for plinkplonk by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
